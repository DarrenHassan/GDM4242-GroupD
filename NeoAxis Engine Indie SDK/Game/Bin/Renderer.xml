<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Renderer</name>
    </assembly>
    <members>
        <member name="T:Engine.Renderer.ParticleAffector">
            <summary>
            Abstract class defining the interface to be implemented by particle affectors.
            </summary>
            <remarks>
            <para>
            Particle affectors modify particles in a particle system over their lifetime. They can be
            grouped into types, e.g. 'vector force' affectors, 'fader' affectors etc; each type will 
            modify particles in a different way, using different parameters.
            </para>
            <para>
            Because there are so many types of affectors you could use, Engine chooses not to dictate
            the available types. It comes with some in-built, but allows plugins or applications to extend the 
            affector types available.
            This is done by subclassing ParticleAffector to have the appropriate emission behaviour you want,
            and also creating a subclass of ParticleAffectorFactory which is responsible for creating instances 
            of your new affector type. You register this factory with the ParticleSystemManager using
            addAffectorFactory, and from then on affectors of this type can be created either from code or through
            text particle scripts by naming the type.
            </para>
            <para>
            This same approach is used for ParticleEmitters (which are the source of particles in a system).
            This means that Engine is particularly flexible when it comes to creating particle system effects,
            with literally infinite combinations of affector and affector types, and paramters within those
            types.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.ParticleAffector.ToString">
            <summary>
            Returns the name of the type of affector. 
            </summary>
            <returns>The name of the type of affector.</returns>
        </member>
        <member name="T:Engine.Renderer.LinearForceAffector">
            <summary>
            This class defines a ParticleAffector which applies a linear force to particles in a system.
            </summary>
            <remarks>
            <para>
            This affector applies a linear force, such as gravity, to a particle system.
            This force can be applied in 2 ways: by taking the average of the particle's current momentum and the 
            force vector, or by adding the force vector to the current particle's momentum. 
            </para>
            <para>
            The former approach is self-stabilising i.e. once a particle's momentum
            is equal to the force vector, no further change is made to it's momentum. It also results in
            a non-linear acceleration of particles.
            The latter approach is simpler and applies a constant acceleration to particles. However,
            it is not self-stabilising and can lead to perpetually increasing particle velocities. 
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.LinearForceAffector.ForceApplication">
            <summary>
            Gets or sets how the force vector is applied to a particle.
            </summary>
        </member>
        <member name="P:Engine.Renderer.LinearForceAffector.ForceVector">
            <summary>
            Gets or sets the force vector to apply to the particles in a system.
            </summary>
        </member>
        <member name="T:Engine.Renderer.LinearForceAffector.ForceApplicationType">
            <summary>
            Choice of how to apply the force vector to particles.
            </summary>
        </member>
        <member name="F:Engine.Renderer.LinearForceAffector.ForceApplicationType.Average">
            <summary>Take the average of the force vector and the particle momentum.</summary>
        </member>
        <member name="F:Engine.Renderer.LinearForceAffector.ForceApplicationType.Add">
            <summary>Add the force vector to the particle momentum.</summary>
        </member>
        <member name="T:Engine.Renderer.ColourFaderAffector">
            <summary>
            This subclass of ParticleAffector allows you to alter the colour of particles.
            </summary>
            <remarks>
            This class supplies the ParticleAffector implementation required to modify the colour of
            particle in mid-flight.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ColourFaderAffector.Adjust">
            <summary>
            Gets or sets the colour adjustment to be made per second to particles.
            </summary>
            <summary>
            Gets or sets the adjustment to be made to each of the colour components per second. These
            values will be added to the colour of all particles every second, scaled over each frame
            for a smooth adjustment.
            </summary>
        </member>
        <member name="T:Engine.Renderer.ColourFaderAffector2">
            <summary>
            This subclass of ParticleAffector allows you to alter the colour of particles.
            </summary>
            <remarks>
            This class supplies the ParticleAffector implementation required to modify the colour of
            particle in mid-flight.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ColourFaderAffector2.Adjust1">
            <summary>
            Gets or sets the colour adjustment to be made per second to particles.
            </summary>
            <remarks>
            Gets or sets the adjustment to be made to each of the colour components per second. These
            values will be added to the colour of all particles every second, scaled over each frame
            for a smooth adjustment.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ColourFaderAffector2.Adjust2">
            <summary>
            Gets or sets the colour adjustment to be made per second to particles.
            </summary>
            <remarks>
            Gets or sets the adjustment to be made to each of the colour components per second. These
            values will be added to the colour of all particles every second, scaled over each frame
            for a smooth adjustment.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.ColourInterpolatorAffector">
            <summary>
            This subclass of ParticleAffector allows you to alter the colour of particles.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item0Color">
            <summary>
            Gets or sets the color for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item0Time">
            <summary>
            Gets or sets the time for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item1Color">
            <summary>
            Gets or sets the color for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item1Time">
            <summary>
            Gets or sets the time for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item2Color">
            <summary>
            Gets or sets the color for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item2Time">
            <summary>
            Gets or sets the time for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item3Color">
            <summary>
            Gets or sets the color for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item3Time">
            <summary>
            Gets or sets the time for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item4Color">
            <summary>
            Gets or sets the color for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item4Time">
            <summary>
            Gets or sets the time for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item5Color">
            <summary>
            Gets or sets the color for item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ColourInterpolatorAffector.Item5Time">
            <summary>
            Gets or sets the time for item.
            </summary>
        </member>
        <member name="T:Engine.Renderer.ScaleAffector">
            <summary>
            This subclass of ParticleAffector allows you to alter the scale of particles.
            </summary>
            <remarks>
            This class supplies the ParticleAffector implementation required to make the particle expand
            or contract in mid-flight.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ScaleAffector.Adjust">
            <summary>
            Gets or sets the scale adjustment to be made per second to particles. 
            </summary>
            <remarks>
            Gets os sets the adjustment to be made to the x and y scale components per second. These
            values will be added to the scale of all particles every second, scaled over each frame
            for a smooth adjustment.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RotationAffector">
            <summary>
            This subclass of ParticleAffector allows you to alter the rotation of particles.
            </summary>
            <remarks>
            This class supplies the ParticleAffector implementation required to make the particle expand
            or contract in mid-flight.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RotationAffector.RotationSpeed">
            <summary>
            Gets or sets the rotation speed range of particles to be emitted.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RotationAffector.Rotation">
            <summary>
            Gets or sets the rotation range of particles to be emitted.
            </summary>
        </member>
        <member name="T:Engine.Renderer.DirectionRandomiserAffector">
            <summary>
            This class defines a ParticleAffector which applies randomness to the movement of the particles.
            </summary>
            <remarks>
            <para>
            This affector applies randomness to the movement of the particles by
            changing the direction vectors.
            </para>
            The most important parameter to control the effect is randomness. It controls the range in which changes
            are applied to each axis of the direction vector.
            The parameter scope can be used to limit the effect to a certain percentage of the particles.
            <para>
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.DirectionRandomiserAffector.Randomness">
            <summary>
            Gets or sets the randomness to apply to the particles in a system.
            </summary>
        </member>
        <member name="P:Engine.Renderer.DirectionRandomiserAffector.Scope">
            <summary>
            Gets or sets the scope (percentage of particles which are randomised).
            </summary>
        </member>
        <member name="P:Engine.Renderer.DirectionRandomiserAffector.KeepVelocity">
            <summary>
            Gets or sets flag which detemines whether particle speed is changed.
            </summary>
        </member>
        <member name="T:Engine.Renderer.DeflectorPlaneAffector">
            <summary>
            This class defines a ParticleAffector which deflects particles.
            </summary>
            <remarks>
            <para>
            This affector offers a simple (and inaccurate) physical deflection.
            All particles which hit the plane are reflected.
            </para>
            <para>
            The plane is defined by a point (plane_point) and the normal (plane_normal).
            In addition it is possible to change the strenght of the recoil by using the bounce parameter.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.DeflectorPlaneAffector.PlanePoint">
            <summary>
            Gets or sets the plane point of the deflector plane.
            </summary>
        </member>
        <member name="P:Engine.Renderer.DeflectorPlaneAffector.PlaneNormal">
            <summary>
            Gets or sets the plane normal of the deflector plane.
            </summary>
        </member>
        <member name="P:Engine.Renderer.DeflectorPlaneAffector.Bounce">
            <summary>
            Gets or sets the bounce value of the deflection.
            </summary>
        </member>
        <member name="T:Engine.Renderer.MovableObject">
            <summary>
            Abstract class definining a movable object in a scene.
            </summary>
            <remarks>
            Instances of this class are discrete, relatively small, movable objects
            which are attached to <see cref="T:Engine.Renderer.SceneNode"/> objects to define their position.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MovableObject.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="P:Engine.Renderer.MovableObject.Visible">
            <summary>
            Gets or sets this object whether to be visible or not, if it has a renderable component.
            </summary>
        </member>
        <member name="P:Engine.Renderer.MovableObject.UserData">
            <summary>
            Gets or sets user data.
            </summary>
        </member>
        <member name="P:Engine.Renderer.MovableObject.ParentSceneNode">
            <summary>
            Returns the scene node to which this object is attached.
            </summary>
            <remarks>
            A MovableObject may be attached to either a <see cref="T:Engine.Renderer.SceneNode"/>, 
            the latter case if it's attached to a bone on an animated entity. 
            This method will return the scene node of the parent object 
            if the latter is true.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.MovableObject.RenderQueueGroup">
            <summary>
            Gets or sets the render queue group this object will be rendered through.
            </summary>
            <remarks>
            Render queues are grouped to allow you to more tightly control the ordering
            of rendered objects. If you do not call this method, all movable objects default
            to the default queue, which is fine for most objects. You may want to alter this
            if you want this entity to always appear in front of other objects, e.g. for
            a 3D menu system or such.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.MovableObject.Bounds">
            <summary>
            Gets the local axis-aligned bounding box for this object.
            </summary>
            <remarks>
            This bounding box is in local coordinates.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.MovableObject.CastShadows">
            <summary>
            Gets or sets whether or not this object will cast shadows.
            </summary>
            <remarks>
            <para>
            This setting simply allows you to turn on/off shadows for a given object.
            An object will not cast shadows unless the scene supports it in any case,
            and also the material which is
            in use must also have shadow casting enabled. By default all entities cast
            shadows. If, however, for some reason you wish to disable this for a single 
            object then you can do so using this method.
            </para>
            <para>
            This method normally refers to objects which block the light, but
            since Light is also a subclass of MovableObject, in that context it means
            whether the light causes shadows itself.
            </para>
            </remarks>
        </member>
        <member name="T:Engine.Renderer.KeyFrame">
            <summary>
            A key frame in an animation sequence defined by an <see cref="T:Engine.Renderer.AnimationTrack"/>.
            </summary>
            <remarks>
            This class can be used as a basis for all kinds of key frames. 
            The unifying principle is that multiple KeyFrames define an 
            animation sequence, with the exact state of the animation being an 
            interpolation between these key frames. 
            </remarks>
        </member>
        <member name="P:Engine.Renderer.KeyFrame.Time">
            <summary>
            Gets the time of this keyframe in the animation sequence.
            </summary>
        </member>
        <member name="T:Engine.Renderer.VertexMorphKeyFrame">
            <summary>
            
            </summary>
        </member>
        <member name="M:Engine.Renderer.VertexMorphKeyFrame.SetVertexBuffer(Engine.Renderer.HardwareVertexBuffer)">
            <summary>
            Sets the vertex buffer containing the source positions for this keyframe. 
            We assume that positions are the first 3 float elements in this buffer,
            although we don't necessarily assume they're the only ones in there.
            </summary>
            <param name="buffer">
            Vertex buffer link; will not be modified so can be shared read-only data.
            </param>
        </member>
        <member name="M:Engine.Renderer.VertexMorphKeyFrame.GetVertexBuffer">
            <summary>
            Gets the vertex buffer containing positions for this keyframe.
            </summary>
            <remarks>
            Must call HardwareVertexBuffer.Dispose() when buffer not needed anymore.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.VertexPoseKeyFrame">
            <summary>
            Specialised KeyFrame which references a Mesh.Pose at a certain influence
            level, which stores offsets for a subset of the vertices 
            in a buffer to provide a blendable pose.
            </summary>
        </member>
        <member name="M:Engine.Renderer.VertexPoseKeyFrame.AddPoseReference(System.Int32,System.Single)">
            <summary>
            Add a new pose reference.
            </summary>
            <param name="poseIndex">The pose index (not the index of the reference).</param>
            <param name="influence">The influence coefficient.</param>
        </member>
        <member name="M:Engine.Renderer.VertexPoseKeyFrame.UpdatePoseReference(System.Int32,System.Single)">
            <summary>
            Update the influence of a pose reference.
            </summary>
            <param name="poseIndex">The pose index (not the index of the reference).</param>
            <param name="influence">The influence coefficient.</param>
        </member>
        <member name="M:Engine.Renderer.VertexPoseKeyFrame.RemovePoseReference(System.Int32)">
            <summary>
            Remove reference to a given pose.
            </summary>
            <param name="poseIndex">The pose index (not the index of the reference).</param>
        </member>
        <member name="M:Engine.Renderer.VertexPoseKeyFrame.RemoveAllPoseReferences">
            <summary>
            Remove all pose references.
            </summary>
        </member>
        <member name="T:Engine.Renderer.TransformKeyFrame">
            <summary>
             Specialised KeyFrame which stores a full transform.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TransformKeyFrame.Position">
            <summary>
            Gets or sets the translation associated with this keyframe.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TransformKeyFrame.Rotation">
            <summary>
            Gets or sets the rotation applied by this keyframe.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TransformKeyFrame.Scale">
            <summary>
            Gets or sets the scaling factor applied by this keyframe to the animable
            object at it's time index.
            </summary>
        </member>
        <member name="T:Engine.Renderer.AnimationTrack">
            <summary>
            A 'track' in an animation sequence, ie a sequence of keyframes which affect a
            certain type of animable object.
            </summary>
            <remarks>
            <para>
            This class is intended as a base for more complete classes which will actually
            animate specific types of object, e.g. a bone in a skeleton to affect
            skeletal animation. An animation will likely include multiple tracks each of which
            can be made up of many KeyFrame instances. Note that the use of tracks allows each animable
            object to have it's own number of keyframes, i.e. you do not have to have the
            maximum number of keyframes for all animable objects just to cope with the most
            animated one.
            </para>
            <para>
            Since the most common animable object is a Node, there are options in this class 
            for associating the track with a Node which will receive keyframe updates 
            automatically when the 'Apply' method is called.
            </para>
            <para>
            By default rotation is done using shortest-path algorithm.
            It is possible to change this behaviour using
            SetUseShortestRotationPath() method.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.AnimationTrack.Optimize">
            <summary>
            Optimize the current track by removing any duplicate keyframes.
            </summary>
        </member>
        <member name="M:Engine.Renderer.AnimationTrack.GetKeyFramesCount">
            <summary>
            Returns the number of keyframes in this animation.
            </summary>
        </member>
        <member name="P:Engine.Renderer.AnimationTrack.Handle">
            <summary>
            Get the handle associated with this track.
            </summary>
        </member>
        <member name="T:Engine.Renderer.VertexAnimationType">
            <summary>
            Type of vertex animation.
            </summary>
            <remarks>
            <para>
            Vertex animation comes in 2 types, morph and pose. The reason
            for the 2 types is that we have 2 different potential goals - to encapsulate
            a complete, flowing morph animation with multiple keyframes (a typical animation,
            but implemented by having snapshots of the vertex data at each keyframe), 
            or to represent a single pose change, for example a facial expression. 
            Whilst both could in fact be implemented using the same system, we choose
            to separate them since the requirements and limitations of each are quite
            different.
            </para>
            <para>
            Morph animation is a simple approach where we have a whole series of 
            snapshots of vertex data which must be interpolated, e.g. a running 
            animation implemented as morph targets. Because this is based on simple
            snapshots, it's quite fast to use when animating an entire mesh because 
            it's a simple linear change between keyframes. However, this simplistic 
            approach does not support blending between multiple morph animations. 
            If you need animation blending, you are advised to use skeletal animation
            for full-mesh animation, and pose animation for animation of subsets of 
            meshes or where skeletal animation doesn't fit - for example facial animation.
            For animating in a vertex shader, morph animation is quite simple and 
            just requires the 2 vertex buffers (one the original position buffer) 
            of absolute position data, and an interpolation factor. Each track in 
            a morph animation refrences a unique set of vertex data.
            </para>
            <para>
            Pose animation is more complex. Like morph animation each track references
            a single unique set of vertex data, but unlike morph animation, each 
            keyframe references 1 or more 'poses', each with an influence level. 
            A pose is a series of offsets to the base vertex data, and may be sparse - ie it
            may not reference every vertex. Because they're offsets, they can be 
            blended - both within a track and between animations. This set of features
            is very well suited to facial animation.
            </para>
            <para>
            For example, let's say you modelled a face (one set of vertex data), and 
            defined a set of poses which represented the various phonetic positions 
            of the face. You could then define an animation called 'SayHello', containing
            a single track which referenced the face vertex data, and which included 
            a series of keyframes, each of which referenced one or more of the facial 
            positions at different influence levels - the combination of which over
            time made the face form the shapes required to say the word 'hello'. Since
            the poses are only stored once, but can be referenced may times in 
            many animations, this is a very powerful way to build up a speech system.
            </para>
            <para>
            The downside of pose animation is that it can be more difficult to set up.
            Also, since it uses more buffers (one for the base data, and one for each
            active pose), if you're animating in hardware using vertex shaders you need
            to keep an eye on how many poses you're blending at once. You define a
            maximum supported number in your vertex program definition, see the 
            includes_pose_animation material script entry. 
            </para>
            <para>
            So, by partitioning the vertex animation approaches into 2, we keep the
            simple morph technique easy to use, whilst still allowing all 
            the powerful techniques to be used. Note that morph animation cannot
            be blended with other types of vertex animation (pose animation or other
            morph animation); pose animation can be blended with other pose animation
            though, and both types can be combined with skeletal animation. Also note
            that all morph animation can be expressed as pose animation, but not vice
            versa.
            </para>
            </remarks>
        </member>
        <member name="F:Engine.Renderer.VertexAnimationType.None">
            <summary>No animation.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexAnimationType.Morph">
            <summary>Morph animation is made up of many interpolated snapshot keyframes.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexAnimationType.Pose">
            <summary>Pose animation is made up of a single delta pose keyframe.</summary>
        </member>
        <member name="T:Engine.Renderer.VertexAnimationTrack">
            <summary>
            Specialised AnimationTrack for dealing with changing vertex position information.
            See <see cref="T:Engine.Renderer.VertexAnimationType"/>.
            </summary>
        </member>
        <member name="M:Engine.Renderer.VertexAnimationTrack.CreateVertexPoseKeyFrame(System.Single)">
            <summary>
            Creates the single pose KeyFrame and adds it to this animation.
            </summary>
        </member>
        <member name="M:Engine.Renderer.VertexAnimationTrack.CreateVertexMorphKeyFrame(System.Single)">
            <summary>
            Creates the single morph KeyFrame and adds it to this animation.
            </summary>
        </member>
        <member name="M:Engine.Renderer.VertexAnimationTrack.GetKeyFrame(System.Int32)">
            <summary>
            Returns the KeyFrame at the specified index.
            </summary>
        </member>
        <member name="P:Engine.Renderer.VertexAnimationTrack.AnimationType">
            <summary>
            Get the type of vertex animation we're performing.
            </summary>
        </member>
        <member name="M:Engine.Renderer.NodeAnimationTrack.SetAssociatedBone(Engine.Renderer.Bone)">
            <summary>
            Gets or sets reference to the associated <see cref="T:Engine.Renderer.Bone"/> object.
            </summary>
        </member>
        <member name="M:Engine.Renderer.NodeAnimationTrack.CreateNodeKeyFrame(System.Single)">
            <summary>
            Creates a new KeyFrame and adds it to this animation at the given time index.
            </summary>
            <param name="timePosition">
            The time from which this KeyFrame will apply.
            </param>
            <returns></returns>
            <remarks>
            It is better to create KeyFrames in time order. Creating them out of order can result 
            in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            for you, so you don't need to create this one.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.VertexElementSemantic">
            <summary>Vertex element semantics, used to identify the meaning of vertex buffer contents.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.Position">
            <summary>Position, 3 reals per vertex.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.BlendWeights">
            <summary>Blending weights.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.BlendIndices">
            <summary>Blending indices.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.Normal">
            <summary>Normal, 3 reals per vertex.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.Diffuse">
            <summary>Diffuse colors.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.Specular">
            <summary>Specular colors.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.TextureCoordinates">
            <summary>Texture coordinates.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.Binormal">
            <summary>Binormal.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementSemantic.Tangent">
            <summary>Tangent.</summary>
        </member>
        <member name="T:Engine.Renderer.VertexElementType">
            <summary>Vertex element type, used to identify the base types of the vertex contents.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Float1">
            <summary>Float 1.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Float2">
            <summary>Float 2.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Float3">
            <summary>Float 3.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Float4">
            <summary>Float 4.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Color">
            <summary>alias to more specific color type - use the current rendersystem's color packing.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Short1">
            <summary>Short 1.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Short2">
            <summary>Short 2.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Short3">
            <summary>Short 3.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.Short4">
            <summary>Short 4.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.UByte4">
            <summary>Byte 4.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.ColorARGB">
            <summary>D3D style compact color.</summary>
        </member>
        <member name="F:Engine.Renderer.VertexElementType.ColorABGR">
            <summary>GL style compact color.</summary>
        </member>
        <member name="T:Engine.Renderer.VertexElement">
            <summary>
            This class declares the usage of a single vertex buffer as a component
            of a complete <see cref="T:Engine.Renderer.VertexDeclaration"/>.
            </summary>
            <remarks>
            Several vertex buffers can be used to supply the input geometry for a
            rendering operation, and in each case a vertex buffer can be used in
            different ways for different operations; the buffer itself does not
            define the semantics (position, normal etc), the VertexElement
            class does.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexElement.GetSizeInBytes">
            <summary>Gets the size of this element in bytes.</summary>
            <returns>The size of this element in bytes.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexElement.GetTypeSize(Engine.Renderer.VertexElementType)">
            <summary>Utility method for helping to calculate offsets.</summary>
            <param name="type">The element type.</param>
            <returns>The type size in bytes.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexElement.GetTypeCount(Engine.Renderer.VertexElementType)">
            <summary>Utility method which returns the count of values in a given type.</summary>
            <param name="type">The element type.</param>
            <returns>The types count.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexElement.MultiplyTypeCount(Engine.Renderer.VertexElementType,System.Int32)">
            <summary>
            Simple converter function which will turn a single-value type into a
            multi-value type based on a parameter.
            </summary>
            <param name="baseType">The base type.</param>
            <param name="count">The count.</param>
            <returns>The element type.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexElement.GetBaseType(Engine.Renderer.VertexElementType)">
            <summary>
            Simple converter function which will a type into it's single-value
            equivalent - makes switches on type easier.
            </summary>
            <param name="multiType">The multi type.</param>
            <returns>The element type.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexElement.ConvertColorValue(Engine.MathEx.ColorValue@,Engine.Renderer.VertexElementType)">
            <summary>Utility method for converting color to a packed 32-bit color type.</summary>
            <param name="color">The source color.</param>
            <param name="destinationType">The destination type.</param>
            <returns>The packed color type.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexElement.ConvertColorValue(Engine.MathEx.ColorValue,Engine.Renderer.VertexElementType)">
            <summary>Utility method for converting color to a packed 32-bit color type.</summary>
            <param name="color">The source color.</param>
            <param name="destinationType">The destination type.</param>
            <returns>The packed color type.</returns>
        </member>
        <member name="P:Engine.Renderer.VertexElement.Source">
            <summary>Gets the vertex buffer index from where this element draws it's values.</summary>
        </member>
        <member name="P:Engine.Renderer.VertexElement.Offset">
            <summary>Gets the offset into the buffer where this element starts.</summary>
        </member>
        <member name="P:Engine.Renderer.VertexElement.Type">
            <summary>Gets the data format of this element.</summary>
        </member>
        <member name="P:Engine.Renderer.VertexElement.Semantic">
            <summary>Gets the meaning of this element.</summary>
        </member>
        <member name="P:Engine.Renderer.VertexElement.Index">
            <summary>Gets the index of this element, only applicable for repeating elements.</summary>
        </member>
        <member name="T:Engine.Renderer.VertexDeclaration">
            <summary>
            This class declares the format of a set of vertex inputs, which
            can be issued to the rendering API.
            </summary>
            <remarks>
            <para>
            You should be aware that the ordering and structure of the
            VertexDeclaration can be very important on DirectX with older
            cards,so if you want to maintain maximum compatibility with
            all render systems.
            Whilst GL and more modern graphics cards in D3D will allow you to defy these rules,
            sticking to them will ensure that your buffers have the maximum compatibility.
            </para>
            <para>
            Like the other classes in this functional area, these declarations should be created and
            destroyed using the <see cref="T:Engine.Renderer.HardwareBufferManager"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.Sort">
            <summary>
            Sorts the elements in this list to be compatible with the maximum
            number of rendering APIs / graphics cards.
            </summary>
            <remarks>
            Older graphics cards require vertex data to be presented in a more
            rigid way, as defined in the main documentation for this class. As well
            as the ordering being important, where shared source buffers are used, the
            declaration must list all the elements for each source in turn.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.GetMaxSource">
            <summary>Gets the index of the highest source value referenced by this declaration.</summary>
            <returns>The index of the highest source value referenced by this declaration.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.AddElement(System.Int32,System.Int32,Engine.Renderer.VertexElementType,Engine.Renderer.VertexElementSemantic,System.Int32)">
            <summary>
            Adds a new VertexElement to this declaration.
            </summary>
            <param name="source">
            The binding index of <see cref="T:Engine.Renderer.HardwareVertexBuffer"/> 
            which will provide the source for this element.
            See <see cref="T:Engine.Renderer.VertexBufferBinding"/> for full information.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">The element index.</param>
            <remarks>
            This method adds a single element (positions, normals etc) to the end of the
            vertex declaration. <b>Please read the information in VertexDeclaration about
            the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.AddElement(System.Int32,System.Int32,Engine.Renderer.VertexElementType,Engine.Renderer.VertexElementSemantic)">
            <summary>
            Adds a new VertexElement to this declaration.
            </summary>
            <param name="source">
            The binding index of <see cref="T:Engine.Renderer.HardwareVertexBuffer"/> 
            which will provide the source for this element.
            See <see cref="T:Engine.Renderer.VertexBufferBinding"/> for full information.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <remarks>
            This method adds a single element (positions, normals etc) to the end of the
            vertex declaration. <b>Please read the information in VertexDeclaration about
            the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.InsertElement(System.Int32,System.Int32,System.Int32,Engine.Renderer.VertexElementType,Engine.Renderer.VertexElementSemantic,System.Int32)">
            <summary>
            Inserts a new VertexElement at a given position in this declaration.
            </summary>
            <param name="atPosition">The insert position.</param>
            <param name="source">
            The binding index of <see cref="T:Engine.Renderer.HardwareVertexBuffer"/> 
            which will provide the source for this element.
            See <see cref="T:Engine.Renderer.VertexBufferBinding"/> for full information.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">The element index.</param>
            <remarks>
            This method adds a single element (positions, normals etc) to the end of the
            vertex declaration. <b>Please read the information in VertexDeclaration about
            the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.InsertElement(System.Int32,System.Int32,System.Int32,Engine.Renderer.VertexElementType,Engine.Renderer.VertexElementSemantic)">
            <summary>
            Inserts a new VertexElement at a given position in this declaration.
            </summary>
            <param name="atPosition">The insert position.</param>
            <param name="source">
            The binding index of <see cref="T:Engine.Renderer.HardwareVertexBuffer"/> 
            which will provide the source for this element.
            See <see cref="T:Engine.Renderer.VertexBufferBinding"/> for full information.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <remarks>
            This method adds a single element (positions, normals etc) to the end of the
            vertex declaration. <b>Please read the information in VertexDeclaration about
            the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.RemoveElement(System.Int32)">
            <summary>Remove the element at the given index from this declaration.</summary>
            <param name="elementIndex">The element index.</param>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.RemoveElement(Engine.Renderer.VertexElementSemantic,System.Int32)">
            <summary>Remove the element with the given semantic and usage index.</summary>
            <param name="semantic">The semantic.</param>
            <param name="index">The index.</param>
            <remarks>
            In this case 'index' means the usage index for repeating elements such
            as texture coordinates. For other elements this will always be 0 and does
            not refer to the index in the vector.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.RemoveElement(Engine.Renderer.VertexElementSemantic)">
            <summary>Remove the element with the given semantic and usage index.</summary>
            <param name="semantic">The semantic.</param>
            <remarks>
            In this case 'index' means the usage index for repeating elements such
            as texture coordinates. For other elements this will always be 0 and does
            not refer to the index in the vector.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.RemoveAllElements">
            <summary>Remove all elements.</summary>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.ModifyElement(System.Int32,System.Int32,System.Int32,Engine.Renderer.VertexElementType,Engine.Renderer.VertexElementSemantic,System.Int32)">
            <summary>
            Modify an element in-place, params as AddElement.
            </summary>
            <param name="elementIndex">The element index.</param>
            <param name="source">
            The binding index of <see cref="T:Engine.Renderer.HardwareVertexBuffer"/> 
            which will provide the source for this element.
            See <see cref="T:Engine.Renderer.VertexBufferBinding"/> for full information.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">The element index.</param>
            <remarks>
            Please read the information in <see cref="T:Engine.Renderer.VertexDeclaration"/> about
            the importance of ordering and structure for compatibility with older D3D drivers.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.ModifyElement(System.Int32,System.Int32,System.Int32,Engine.Renderer.VertexElementType,Engine.Renderer.VertexElementSemantic)">
            <summary>
            Modify an element in-place, params as AddElement.
            </summary>
            <param name="elementIndex">The element index.</param>
            <param name="source">
            The binding index of <see cref="T:Engine.Renderer.HardwareVertexBuffer"/> 
            which will provide the source for this element.
            See <see cref="T:Engine.Renderer.VertexBufferBinding"/> for full information.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <remarks>
            Please read the information in <see cref="T:Engine.Renderer.VertexDeclaration"/> about
            the importance of ordering and structure for compatibility with older D3D drivers.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.FindElementBySemantic(Engine.Renderer.VertexElementSemantic,System.Int32)">
            <summary>
            Finds a vertex element with the given semantic and index.
            </summary>
            <remarks>
            If the element is not found, this method returns -1.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.FindElementBySemantic(Engine.Renderer.VertexElementSemantic)">
            <summary>
            Finds a first in the vertex elements list element with the given semantic.
            </summary>
            <remarks>
            If the element is not found, this method returns -1.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexDeclaration.GetVertexSizeInBytes(System.Int32)">
            <summary>Gets the vertex size defined by this declaration for a given source.</summary>
            <param name="source">The source.</param>
            <returns>The vertex size in bytes.</returns>
        </member>
        <member name="P:Engine.Renderer.VertexDeclaration.Elements">
            <summary>Gets elements in the declaration. Don't modify.</summary>
        </member>
        <member name="T:Engine.Renderer.VertexBufferBinding">
            <summary>
            Records the state of all the vertex buffer bindings required to provide a vertex declaration
            with the input data it needs for the vertex elements.
            </summary>
            <remarks>
            <para>
            Why do we have this binding list rather than just have <see cref="T:Engine.Renderer.VertexElement"/> referring to the
            vertex buffers direct? Well, in the underlying APIs, binding the vertex buffers to an
            index (or 'stream') is the way that vertex data is linked, so this structure better
            reflects the realities of that. In addition, by separating the vertex declaration from
            the list of vertex buffer bindings, it becomes possible to reuse bindings between declarations
            and vice versa, giving opportunities to reduce the state changes required to perform rendering.
            </para>
            <para>
            Like the other classes in this functional area, these binding maps should be created and
            destroyed using the <see cref="T:Engine.Renderer.HardwareBufferManager"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.SetBinding(System.Int32,Engine.Renderer.HardwareVertexBuffer,System.Boolean)">
            <summary>
            Set a binding, associating a vertex buffer with a given index.
            </summary>
            <param name="source">The source.</param>
            <param name="buffer">The hardware vertex buffer.</param>
            <param name="shouldDispose">
            Whether it is necessary to make Dispose after deletion of object.
            </param>
            <remarks>
            If the index is already associated with a vertex buffer,
            the association will be replaced. This may cause the old buffer
            to be destroyed if nothing else is referring to it.
            You should assign bindings from 0 and not leave gaps, although you can
            bind them in any order.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.UnsetBinding(System.Int32)">
            <summary>Removes an existing binding.</summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.UnsetAllBindings">
            <summary>Removes all the bindings.</summary>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.GetBuffer(System.Int32)">
            <summary>Gets the buffer bound to the given source index.</summary>
            <param name="source">The source.</param>
            <returns>the buffer bound to the given source index.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.IsBufferBound(System.Int32)">
            <summary>Gets whether a buffer is bound to the given source index.</summary>
            <param name="source">The source.</param>
            <returns><b>true</b> if such buffer is bound; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.GetBufferCount">
            <summary>Gets the buffer count.</summary>
            <returns>The buffer count.</returns>
        </member>
        <member name="M:Engine.Renderer.VertexBufferBinding.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="T:Engine.Renderer.VertexData">
            <summary>Summary class collecting together vertex source information.</summary>
        </member>
        <member name="M:Engine.Renderer.VertexData.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.VertexData.Clone(System.Boolean)">
            <summary>
            Clones this vertex data, potentially including replicating any vertex buffers.
            </summary>
            <param name="copyData">Whether the flag indicating needs to be copied data.</param>
            <returns>The cloned vertex data.</returns>
            <remarks>
            The caller is expected to delete the returned pointer when ready.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexData.Clone">
            <summary>
            Clones this vertex data, potentially including replicating any vertex buffers.
            </summary>
            <returns>The cloned vertex data.</returns>
            <remarks>
            The caller is expected to delete the returned pointer when ready.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexData.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec2}@)">
            <summary>
            Gets the some buffers geometry.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="texCoords0">The vertices texture coordinates.</param>
        </member>
        <member name="M:Engine.Renderer.VertexData.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec3}@)">
            <summary>
            Gets the some buffers geometry.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
        </member>
        <member name="M:Engine.Renderer.VertexData.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@)">
            <summary>
            Gets the some buffers geometry.
            </summary>
            <param name="positions">The vertices positions.</param>
        </member>
        <member name="M:Engine.Renderer.VertexData.CreateFromList(Engine.Renderer.VertexDeclaration,System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Creates the vertex data from list.
            </summary>
            <param name="vertexDeclaration">The vertex declaration.</param>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:Engine.Renderer.VertexData.CreateFromArray(Engine.Renderer.VertexDeclaration,System.IntPtr,System.Int32)">
            <summary>
            Creates the vertex data from array.
            </summary>
            <param name="vertexDeclaration">The vertex declaration.</param>
            <param name="vertices">The vertices.</param>
            <param name="bufferSize">The size of vertices buffer in bytes.</param>
        </member>
        <member name="M:Engine.Renderer.VertexData.CreateFromArray(Engine.Renderer.VertexDeclaration,System.Byte[])">
            <summary>
            Creates the vertex data from array.
            </summary>
            <param name="vertexDeclaration">The vertex declaration.</param>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:Engine.Renderer.VertexData.CloseGapsInBindings">
            <summary>
            Remove any gaps in the vertex buffer bindings.
            </summary>
            <remarks>
            <para>
            This is useful if you've removed elements and buffers from this vertex
            data and want to remove any gaps in the vertex buffer bindings. This
            method is mainly useful when reorganising vertex data manually.
            </para>
            <para>
            This will cause binding index of the elements in the vertex declaration
            to be altered to new binding index.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.VertexData.RemoveUnusedBuffers">
            <summary>
            Remove all vertex buffers that never used by the vertex declaration.
            </summary>
            <remarks>
            <para>
            This is useful if you've removed elements from the vertex declaration
            and want to unreference buffers that never used any more. This method
            is mainly useful when reorganising vertex data manually.
            </para>
            <para>
            This also remove any gaps in the vertex buffer bindings.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.VertexData.VertexDeclaration">
            <summary>Gets the declaration of the vertex to be used in this operation.</summary>
        </member>
        <member name="P:Engine.Renderer.VertexData.VertexBufferBinding">
            <summary>Gets the vertex buffer bindings to be used.</summary>
        </member>
        <member name="P:Engine.Renderer.VertexData.VertexStart">
            <summary>
            Gets or sets the base vertex index to start from.
            </summary>
        </member>
        <member name="P:Engine.Renderer.VertexData.VertexCount">
            <summary>
            Gets or sets the number of vertices used in this operation.
            </summary>
        </member>
        <member name="T:Engine.Renderer.TextureAddressingMode">
            <summary>
            Texture addressing modes.
            </summary>
            <remarks>
            These settings are relevant in both the fixed-function and the programmable pipeline.
            </remarks>
        </member>
        <member name="F:Engine.Renderer.TextureAddressingMode.Wrap">
            <summary>Texture wraps at values over 1.0.</summary>
        </member>
        <member name="F:Engine.Renderer.TextureAddressingMode.Mirror">
            <summary>Texture mirrors (flips) at joins over 1.0.</summary>
        </member>
        <member name="F:Engine.Renderer.TextureAddressingMode.Clamp">
            <summary>Texture clamps at 1.0.</summary>
        </member>
        <member name="F:Engine.Renderer.TextureAddressingMode.Border">
            <summary>Texture coordinates outside the range [0.0, 1.0] are set to the border colour.</summary>
        </member>
        <member name="T:Engine.Renderer.TextureUnitState">
            <summary>
            Class representing the state of a single texture unit during a Pass of a
            <see cref="T:Engine.Renderer.Technique"/>, of a <see cref="T:Engine.Renderer.Material"/>.
            </summary>
            <remarks>
            <para>
            <see cref="T:Engine.Renderer.Texture"/> units are pipelines for retrieving texture data for rendering onto
            your objects in the world. Using them is common to both the fixed-function and 
            the programmable (vertex and fragment program) pipeline, but some of the 
            settings will only have an effect in the fixed-function pipeline (for example, 
            setting a texture rotation will have no effect if you use the programmable
            pipeline, because this is overridden by the fragment program). The effect
            of each setting as regards the 2 pipelines is commented in each setting.
            </para>
            <para>
            When I use the term 'fixed-function pipeline' I mean traditional rendering
            where you do not use vertex or fragment programs (shaders). Programmable 
            pipeline means that for this pass you are using vertex or fragment programs.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetTextureName(System.String,Engine.Renderer.Texture.Type)">
            <summary>
            Sets this texture layer to use a single texture, given the
            name of the texture to use on this layer.
            </summary>
            <param name="name">The name of a texture.</param>
            <param name="type">The type of a texture.</param>
            <remarks>
            Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetTextureName(System.String)">
            <summary>
            Sets this texture layer to use a single texture, given the
            name of the texture to use on this layer.
            </summary>
            <param name="name">The name of a texture.</param>
            <remarks>
            Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetCubicTextureName(System.String,System.Boolean)">
            <summary>
            Sets this texture layer to use a combination of 6 texture maps, each one 
            relating to a face of a cube.
            </summary>
            <remarks>
            Cubic textures are made up of 6 separate texture images. Each one of these 
            is an orthoganal view of the world with a FOV of 90 degrees and an aspect 
            ratio of 1:1. You can generate these from 3D Studio by rendering a scene to 
            a reflection map of a transparent cube and saving the output files.
            </remarks>
            <param name="name">
            name The basic name of the texture e.g. brickwall.jpg, stonefloor.png. There must be 6 versions
            of this texture with the suffixes _fr, _bk, _up, _dn, _lf, and _rt (before the extension) which
            make up the 6 sides of the box. The textures must all be the same size and be powers of 2 in width and height.
            If you can't make your texture names conform to this, use the alternative method of the same name which takes
            an array of texture names instead.
            </param>
            <param name="forUVW">
            forUVW Set to true if you want a single 3D texture addressable with 3D texture coordinates rather than
            6 separate textures. Useful for cubic environment mapping.
            </param>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetTextureAddressingMode(Engine.Renderer.TextureAddressingMode)">
            <summary>
            Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
            </summary>
            <param name="mode">The addressing mode.</param>
            <remarks>
            <para>
            The default is <b>Wrap</b> i.e. the texture repeats over values of 1.0.
            </para>
            <para>
            This is a shortcut method which sets the addressing mode for all
            coordinates at once; you can also call the more specific method
            to set the addressing mode per coordinate.
            </para>
            <para>
            This applies for both the fixed-function and programmable pipelines.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetProjectiveTexturing(Engine.Renderer.RenderFrustum)">
            <summary>
            Enables projective texturing on this texture unit.
            </summary>
            <param name="projectionSettings">
            The Frustum which will be used to derive the 
            projection parameters.
            </param>
            <remarks>
            <para>
            Projective texturing allows you to generate texture coordinates 
            based on a Frustum, which gives the impression that a texture is
            being projected onto the surface. Note that once you have called
            this method, the texture unit continues to monitor the Frustum you 
            passed in and the projection will change if you can alter it. It also
            means that you must ensure that the Frustum object you pass a pointer
            to remains in existence for as long as this <see cref="T:Engine.Renderer.TextureUnitState"/> does.
            </para>
            <para>
            This effect cannot be combined with other texture generation effects, 
            such as environment mapping. It also has no effect on passes which 
            have a vertex program enabled - projective texturing has to be done
            in the vertex program instead.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.ResetProjectiveTexturing">
            <summary>
            Disables projective texturing on this texture unit.
            </summary>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)">
            <summary>
            Determines how this texture layer is combined with the one below it 
            (or the diffuse colour of the geometry if this is layer 0).
            </summary>
            <param name="operation">
            One of the <b>LayerBlendOperation</b> enumerated blending types.
            </param>
            <remarks>
            <para>
            This method is the simplest way to blend tetxure layers, because it requires only one parameter,
            gives you the most common blending types, and automatically sets up 2 blending methods: one for
            if single-pass multitexturing hardware is available, and another for if it is not and the blending must
            be achieved through multiple rendering passes. It is, however, quite limited and does not expose
            the more flexible multitexturing operations, simply because these can't be automatically supported in
            multipass fallback mode.
            </para>
            <para>
            The default method is <b>Modulate</b> for all layers.
            </para>
            <para>
            This option has no effect in the programmable pipeline.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetColorOperationEx(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,Engine.MathEx.ColorValue,Engine.MathEx.ColorValue,System.Single)">
            <summary>
            Setting advanced blending options.
            </summary>
            <remarks>
            <para>
            This is an extended version of the <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/> 
            method which allows extremely detailed control over the blending applied between 
            this and earlier layers. See the IMPORTANT note below about the issues between 
            mulitpass and multitexturing that using this method can create.
            </para>
            <para>
            Texture color operations determine how the final color of the surface appears when
            rendered. Texture units are used to combine color values from various sources (ie. the
            diffuse color of the surface from lighting calculations, combined with the color of
            the texture). This method allows you to specify the 'operation' to be used, ie. the
            calculation such as adds or multiplies, and which values to use as arguments, such as
            a fixed value or a value from a previous calculation.
            </para>
            <para>
            The defaults for each layer are:
            <ul>
            <li>operation = Modulate</li>
            <li>source1 = Texture</li>
            <li>source2 = Current</li>
            </ul>
            ie. each layer takes the color results of the previous layer, and multiplies them
            with the new texture being applied. Bear in mind that colors are RGB values from
            0.0 - 1.0 so multiplying them together will result in values in the same range,
            'tinted' by the multiply. Note however that a straight multiply normally has the
            effect of darkening the textures - for this reason there are brightening operations
            like ModulateX2. See the <see cref="T:Engine.Renderer.LayerBlendOperation"/> and 
            <see cref="T:Engine.Renderer.LayerBlendSource"/> enumerated types for full details.
            </para>
            <para>
            Because of the limitations on some underlying APIs (Direct3D included)
            the "Texture" argument can only be used as the first argument, not the second.
            </para>
            <para>
            The final 3 parameters are only required if you decide to pass values manually
            into the operation, i.e. you want one or more of the inputs to the color calculation
            to come from a fixed value that you supply. Hence you only need to fill these in if
            you supply "Manual" to the corresponding source, or use the "BlendManual"
            operation.
            </para>
            <para>
            Ogre tries to use multitexturing hardware to blend texture layers
            together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a
            GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object
            multiple times with different textures. This is both less efficient and there is a smaller
            range of blending operations which can be performed. For this reason, if you use this method
            you MUST also call <see cref="M:Engine.Renderer.TextureUnitState.SetColorOpMultipassFallback(Engine.Renderer.SceneBlendFactor,Engine.Renderer.SceneBlendFactor)"/> to specify 
            which effect you want to fall back on if sufficient hardware is not available.
            </para>
            <para>
            If you wish to avoid having to do this, use the simpler 
            <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/> method which allows less flexible 
            blending options but sets up the multipass fallback automatically,
            since it only allows operations which have direct multipass equivalents.
            </para>
            <para>
            This has no effect in the programmable pipeline.
            </para>
            </remarks>
            <param name="operation">
            The operation to be used, e.g. modulate (multiply), add, subtract.
            </param>
            <param name="source1">
            The source of the first color to the operation e.g. texture color.
            </param>
            <param name="source2">
            The source of the second color to the operation e.g. current surface color.
            </param>
            <param name="argument1">
            Manually supplied color value (only required if source1 = Manual).
            </param>
            <param name="argument2">
            Manually supplied color value (only required if source2 = Manual).
            </param>
            <param name="manualBlend">
            Manually supplied 'blend' value - only required for operations
            which require manual blend e.g. BlendManual.
            </param>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetAlphaOperation(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,System.Single,System.Single,System.Single)">
            <summary>
            Sets the alpha operation to be applied to this texture.
            </summary>
            <remarks>
            <para>
             This works in exactly the same way as <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/>, except
             that the effect is applied to the level of alpha (i.e. transparency)
             of the texture rather than its color. When the alpha of a texel (a pixel
             on a texture) is 1.0, it is opaque, wheras it is fully transparent if the
             alpha is 0.0. Please refer to the <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/> method for more info.
            </para>
            <para>
            This option has no effect in the programmable pipeline.
            </para>
            </remarks>
            <param name="operation">
            The operation to be used, e.g. modulate (multiply), add, subtract.
            </param>
            <param name="source1">
            The source of the first alpha value to the operation e.g. texture alpha.
            </param>
            <param name="source2">
            The source of the second alpha value to the operation e.g. current surface alpha.
            </param>
            <param name="argument1">
            Manually supplied alpha value (only required if source1 = Manual).
            </param>
            <param name="argument2">
            Manually supplied alpha value (only required if source2 = Manual).
            </param>
            <param name="manualBlend">
            Manually supplied 'blend' value - only required for operations
            which require manual blend e.g. BlendManual.
            </param>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetColorOpMultipassFallback(Engine.Renderer.SceneBlendFactor,Engine.Renderer.SceneBlendFactor)">
            <summary>
            Sets the multipass fallback operation for this layer, if you used 
            <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperationEx(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,Engine.MathEx.ColorValue,Engine.MathEx.ColorValue,System.Single)"/> and not enough multitexturing 
            hardware is available.
            </summary>
            <remarks>
            <para>
            Because some effects exposed using <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperationEx(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,Engine.MathEx.ColorValue,Engine.MathEx.ColorValue,System.Single)"/> 
            are only supported under multitexturing hardware, if the hardware is lacking 
            the system must fallback on multipass rendering, which unfortunately doesn't 
            support as many effects. This method is for you to specify the fallback
            operation which most suits you.
            </para>
            <para>
            You'll notice that the interface is the same as the <see cref="P:Engine.Renderer.Pass.SourceBlendFactor"/> 
            and <see cref="P:Engine.Renderer.Pass.DestBlendFactor"/> properties; this is because multipass 
            rendering is effectively scene blending, since each 
            layer is rendered on top of the last using the same mechanism as making an object 
            transparent, it's just being rendered in the same place repeatedly to get the 
            multitexture effect.
            </para>
            <para>
            If you use the simpler (and hence less flexible) 
            <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/> method you don't need to call this 
            as the system sets up the fallback for you.
            </para>
            <para>
            This option has no effect in the programmable pipeline, because there is no multipass 
            fallback and multitexture blending is handled by the fragment shader.
            </para>
            </remarks>
            <param name="sourceFactor"></param>
            <param name="destFactor"></param>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetTextureFiltering(Engine.Renderer.FilterOptions,Engine.Renderer.FilterOptions,Engine.Renderer.FilterOptions)">
            <summary>
            Set a the detailed filtering options on this texture unit. 
            </summary>
            <param name="minFilter">
            The filtering to use when reducing the size of the texture. 
            Can be <b>Point</b>, <b>Linear</b> or <b>Anisotropic</b>.
            </param>
            <param name="magFilter">
            The filtering to use when increasing the size of the texture
            Can be <b>Point</b>, <b>Linear</b> or <b>Anisotropic</b>.
            </param>
            <param name="mipFilter">
            The filtering to use between mip levels
            Can be <b>None</b> (turns off mipmapping), <b>Point</b> or <b>Linear</b> 
            (trilinear filtering)
            </param>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetScrollAnimation(Engine.MathEx.Vec2)">
            <summary>
            Sets up an animated scroll for the texture layer.
            </summary>
            <remarks>
            <para>
            Useful for creating constant scrolling effects on a texture layer.
            </para>
            <para>
            This option has no effect in the programmable pipeline.
            </para>
            </remarks>
            <param name="speed">
            The number of loops per second.
            </param>
        </member>
        <member name="M:Engine.Renderer.TextureUnitState.SetRotateAnimation(System.Single)">
            <summary>
            Sets up an animated texture rotation for this layer.
            </summary>
            <remarks>
            <para>
            Useful for constant rotations.
            </para>
            <para>
            This option has no effect in the programmable pipeline.
            </para>
            </remarks>
            <param name="speed">
            The number of complete anticlockwise revolutions per second (use -ve for clockwise).
            </param>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.Parent">
            <summary>
            Gets the parent Pass object
            </summary>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureName">
            <summary>
            Get the name of current texture image for this layer.
            </summary>
            <remarks>
            This will either always be a single name for this layer,
            or will be the name of the current frame for an animated
            or otherwise multi-frame texture.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.NumMipmaps">
            <summary>
            Gets or sets how many mipmaps have been requested for the texture.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.IsAlpha">
            <summary>
            Gets or sets whether this texture is requested to be loaded as alpha if single channel.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureBorderColor">
            <summary>
            Gets or sets the texture border color.
            </summary>
            <remarks>
            The default is black, and this value only used when addressing mode Border.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureCoordinatesSet">
            <summary>
            Gets or sets the index of the set of texture coordinates this layer uses.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureNameAlias">
            <summary>
            Gets or sets the alias name used for texture frame names.
            </summary>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureScroll">
            <summary>
            Gets or sets the translation offset of the texture, ie scrolls the texture.
            </summary>
            <remarks>
            <para>
            This method sets the translation element of the texture transformation, and is easier to use than setTextureTransform if
            you are combining translation, scaling and rotation in your texture transformation. Again if you want
            to animate these values you need to use a Controller
            </para>
            <para>
            This option has no effect in the programmable pipeline.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureRotate">
            <summary>
            Gets or sets the anticlockwise rotation factor applied to texture coordinates.
            </summary>
            <remarks>
            This option has no effect in the programmable pipeline.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.TextureScale">
            <summary>
            Gets or sets the scaling factor applied to texture coordinates.
            </summary>
            <remarks>
            <para>
            Has no effect in the programmable pipeline.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.TextureUnitState.ContentType">
            <summary>
            Set the type of content this TextureUnitState references.
            </summary>
            <remarks>
            The default is to reference a standard named texture, but this unit
            can also reference automated content like a shadow texture.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.TextureUnitState.ContentTypes">
            <summary>
            Enum identifying the type of content this texture unit contains.
            </summary>
        </member>
        <member name="F:Engine.Renderer.TextureUnitState.ContentTypes.Named">
            <summary>Normal texture identified by name.</summary>
        </member>
        <member name="F:Engine.Renderer.TextureUnitState.ContentTypes.Shadow">
            <summary>A shadow texture, automatically bound by engine.</summary>
        </member>
        <member name="F:Engine.Renderer.TextureUnitState.ContentTypes.Lightmap">
            <summary>A lightmap, automatically bound by engine.</summary>
        </member>
        <member name="T:Engine.Renderer.HardwareIndexBuffer">
            <summary>
            Specialisation of HardwareBuffer for vertex index buffers.
            </summary>
        </member>
        <member name="T:Engine.Renderer.HardwareBuffer">
            <summary>
            Abstract class defining common features of hardware buffers.
            </summary>
            <remarks>
            <para>
            A 'hardware buffer' is any area of memory held outside of core system ram,
            and in our case refers mostly to video ram, although in theory this class
            could be used with other memory areas such as sound card memory, custom
            coprocessor memory etc.
            </para>
            <para>
            This reflects the fact that memory held outside of main system RAM must 
            be interacted with in a more formal fashion in order to promote
            cooperative and optimal usage of the buffers between the various 
            processing units which manipulate them.
            </para>
            <para>
            This abstract class defines the core interface which is common to all
            buffers, whether it be vertex buffers, index buffers, texture memory
            or framebuffer memory etc.
            </para>
            <para>
            Buffers have the ability to be 'shadowed' in system memory, this is because
            the kinds of access allowed on hardware buffers is not always as flexible as
            that allowed for areas of system memory - for example it is often either 
            impossible, or extremely undesirable from a performance standpoint to read from
            a hardware buffer; when writing to hardware buffers, you should also write every
            byte and do it sequentially. In situations where this is too restrictive, 
            it is possible to create a hardware, write-only buffer (the most efficient kind) 
            and to back it with a system memory 'shadow' copy which can be read and updated arbitrarily.
            Ogre handles synchronising this buffer with the real hardware buffer (which should still be
            created with the <b>Usage.Dynamic</b> flag if you intend to update it very frequently). Whilst this
            approach does have it's own costs, such as increased memory overhead, these costs can 
            often be outweighed by the performance benefits of using a more hardware efficient buffer.
            You should look for the 'useShadowBuffer' parameter on the creation methods used to create
            the buffer of the type you require (see <see cref="T:Engine.Renderer.HardwareBufferManager"/>) to enable this feature.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.Lock(Engine.Renderer.HardwareBuffer.LockOptions)">
            <summary>
            Lock the buffer for (potentially) reading / writing.
            </summary>
            <param name="lockOptions">Locking options.</param>
            <returns>The unmanaged pointer to locked memory.</returns>
            <remarks>
            <para>
            Locking and unlocking a buffer can, in some rare circumstances such as 
            switching video modes whilst the buffer is locked, corrupt the 
            contents of a buffer. This is pretty rare, but if it occurs, 
            this method will throw an exception, meaning you
            must re-upload the data.
            </para>
            <para>
            Note that using the 'read' and 'write' forms of updating the buffer does not
            suffer from this problem, so if you want to be 100% sure your
            data will not be lost, use the 'read' and 'write' forms instead.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.Lock(Engine.Renderer.HardwareBuffer.LockOptions,System.Int32,System.Int32)">
            <summary>
            Lock the buffer for (potentially) reading / writing.
            </summary>
            <param name="lockOptions">Locking options.</param>
            <returns>The unmanaged pointer to locked memory.</returns>
            <remarks>
            <para>
            Locking and unlocking a buffer can, in some rare circumstances such as 
            switching video modes whilst the buffer is locked, corrupt the 
            contents of a buffer. This is pretty rare, but if it occurs, 
            this method will throw an exception, meaning you
            must re-upload the data.
            </para>
            <para>
            Note that using the 'read' and 'write' forms of updating the buffer does not
            suffer from this problem, so if you want to be 100% sure your
            data will not be lost, use the 'read' and 'write' forms instead.
            </para>
            </remarks>
            <param name="offset">The byte offset from the start of the buffer to lock.</param>
            <param name="length">The size of the area to lock, in bytes.</param>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.Unlock">
            <summary>
            Releases the lock on this buffer.
            </summary>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.GetUnmanagedLockPointer">
            <summary>
            Returns the unmanaged pointer to locked memory.
            </summary>
            <returns>The unmanaged pointer to locked memory.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.GetSizeInBytes">
            <summary>
            Returns the size of this buffer in bytes.
            </summary>
            <returns>The size of this buffer in bytes.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.GetUsage">
            <summary>
            Returns the Usage flags with which this buffer was created.
            </summary>
            <returns>The Usage flags with which this buffer was created.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.IsSystemMemory">
            <summary>
            Returns whether this buffer is held in system memory.
            </summary>
            <returns><b>true</b> if this buffer is held in system memory; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.HasShadowBuffer">
            <summary>
            Returns whether this buffer has a system memory shadow for quicker reading.
            </summary>
            <returns><b>true</b> if this buffer has a system memory shadow for quicker reading; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareBuffer.IsLocked">
            <summary>
            Returns whether or not this buffer is currently locked.
            </summary>
            <returns><b>true</b> if this buffer is currently locked; otherwise, <b>false</b>.</returns>
        </member>
        <member name="T:Engine.Renderer.HardwareBuffer.Usage">
            <summary>
            Enums describing buffer usage; not mutually exclusive.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.Static">
            <summary>
            Static buffer which the application rarely modifies once created. Modifying 
            the contents of this buffer will involve a performance hit.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.Dynamic">
            <summary>
            Indicates the application would like to modify this buffer with the CPU
            fairly often. 
            Buffers created with this flag will typically end up in AGP memory rather 
            than video memory.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.WriteOnly">
            <summary>
            Indicates the application will never read the contents of the buffer back, 
            it will only ever write data. Locking a buffer with this flag will ALWAYS 
            return a pointer to new, blank memory rather than the memory associated 
            with the contents of the buffer; this avoids DMA stalls because you can 
            write to a new memory area while the previous one is being used. 
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.Discardable">
            <summary>
            Indicates that the application will be refilling the contents
            of the buffer regularly (not just updating, but generating the
            contents from scratch), and therefore does not mind if the contents 
            of the buffer are lost somehow and need to be recreated. This
            allows and additional level of optimisation on the buffer.
            This option only really makes sense when combined with 
            <b>DynamicWriteOnly</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.StaticWriteOnly">
            <summary>
            Combination of <b>Static</b> and <b>WriteOnly</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.DynamicWriteOnly">
            <summary>
            Combination of <b>Dynamic</b> and <b>WriteOnly</b>. If you use 
            this, strongly consider using <b>DynamicWriteOnlyDiscardable</b>
            instead if you update the entire contents of the buffer very 
            regularly. 
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.Usage.DynamicWriteOnlyDiscardable">
            <summary>
            Combination of <b>Dynamic</b>, <b>WriteOnly</b> and <b>Discardable</b>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.HardwareBuffer.LockOptions">
            <summary>
            Locking options.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.LockOptions.Normal">
            <summary>
            Normal mode, ie allows read/write and contents are preserved.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.LockOptions.Discard">
            <summary>
            Discards the <em>entire</em> buffer while locking; this allows optimisation to be 
            performed because synchronisation issues are relaxed. Only allowed on buffers 
            created with the <b>Dynamic</b> flag.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.LockOptions.ReadOnly">
            <summary>
            Lock the buffer for reading only. Not allowed in buffers which are created with <b>WriteOnly</b>.
            Mandatory on statuc buffers, ie those created without the <b>Dynamic</b> flag. 
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareBuffer.LockOptions.NoOverwrite">
            <summary>
            As <b>Normal</b>, except the application guarantees not to overwrite any 
            region of the buffer which has already been used in this frame, can allow
            some optimisation on some APIs.
            </summary>
        </member>
        <member name="M:Engine.Renderer.HardwareIndexBuffer.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="P:Engine.Renderer.HardwareIndexBuffer.Type">
            <summary>
            Gets the type of indexes used in this buffer.
            </summary>
        </member>
        <member name="P:Engine.Renderer.HardwareIndexBuffer.IndexCount">
            <summary>
            Gets the number of indexes in this buffer.
            </summary>
        </member>
        <member name="P:Engine.Renderer.HardwareIndexBuffer.IndexSizeInBytes">
            <summary>
            Gets the size in bytes of each index.
            </summary>
        </member>
        <member name="T:Engine.Renderer.HardwareIndexBuffer.IndexType">
            <summary>
            The index type.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HardwareIndexBuffer.IndexType._16Bit">
            <summary>32-bit.</summary>
        </member>
        <member name="F:Engine.Renderer.HardwareIndexBuffer.IndexType._32Bit">
            <summary>16-bit.</summary>
        </member>
        <member name="T:Engine.Renderer.BillboardChain">
            <summary>Allows the rendering of a chain of connected billboards.</summary>
            <remarks>
            <para>
            A billboard chain operates much like a traditional billboard, ie its
            segments always face the camera; the difference being that instead of
            a set of disconnected quads, the elements in this class are connected
            together in a chain which must always stay in a continuous strip. This
            kind of effect is useful for creating effects such as trails, beams,
            lightning effects, etc.
            </para>
            <para>
            A single instance of this class can actually render multiple separate
            chain segments in a single render operation, provided they all use the
            same material. To clarify the terminology: a 'segment' is a separate 
            sub-part of the chain with its own start and end (called the 'head'
            and the 'tail'. An 'element' is a single position / colour / texcoord
            entry in a segment. You can add items to the head of a chain, and 
            remove them from the tail, very efficiently. Each segment has a max
            size, and if adding an element to the segment would exceed this size, 
            the tail element is automatically removed and re-used as the new item
            on the head.
            </para>
            <para>
            This class has no auto-updating features to do things like alter the
            colour of the elements or to automatically add / remove elements over
            time - you have to do all this yourself as a user of the class. 
            Subclasses can however be used to provide this kind of behaviour 
            automatically.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.BillboardChain.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.MaxChainElements">
            <summary>Gets and sets the maximum number of chain elements per chain.</summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.ChainCount">
            <summary>
            Gets and sets the number of chain segments 
            (this class can render multiple chains at once using the same material).
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.UseTextureCoords">
            <summary>
            Gets and sets whether texture coordinate information should be included in the
            final buffers generated.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.TextureCoordDirection">
            <summary>
            Gets and sets the direction in which texture coords specified on each element are 
            deemed to run.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.OtherTextureCoordRange">
            <summary>
            Get the range of the texture coordinates generated across the width of
            the chain elements.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.UseVertexColors">
            <summary>
            Gets or sets whether vertex colour information should be included in the
            final buffers generated.
            </summary>
            <remarks>
            You must use either texture coordinates or vertex colour since the
            vertices have no normals and without one of these there is no source of
            colour for the vertices.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.Dynamic">
            <summary>
            Gets or sets whether or not the buffers created for this object are suitable 
            for dynamic alteration.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardChain.MaterialName">
            <summary>Gets or sets the material name to use for rendering.</summary>
        </member>
        <member name="T:Engine.Renderer.BillboardChain.TexCoordDirection">
            <summary>
            The direction in which texture coordinates from elements of the chain are used.
            </summary>
        </member>
        <member name="F:Engine.Renderer.BillboardChain.TexCoordDirection.U">
            <summary>Tex coord in elements is treated as the 'u' texture coordinate.</summary>
        </member>
        <member name="F:Engine.Renderer.BillboardChain.TexCoordDirection.V">
            <summary>Tex coord in elements is treated as the 'v' texture coordinate.</summary>
        </member>
        <member name="T:Engine.Renderer.Technique">
            <summary>
            Class representing an approach to rendering this particular <see cref="T:Engine.Renderer.Material"/>.
            </summary>
            <remarks>
            Engine will attempt to use the best technique supported by the active hardware, 
            unless you specifically request a lower detail technique (say for distant rendering).
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Technique.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Technique.CreatePass">
            <summary>
            Creates a new Pass for this Technique.
            </summary>
            <remarks>
            A Pass is a single rendering pass, ie a single draw of the given material.
            Note that if you create a pass without a fragment program, during compilation of the
            material the pass may be split into multiple passes if the graphics card cannot
            handle the number of texture units requested. For passes with fragment programs, however, 
            the number of passes you create will never be altered, so you have to make sure 
            that you create an alternative fallback Technique for if a card does not have 
            enough facilities for what you're asking for.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Technique.RemovePass(System.Int32)">
            <summary>Removes the Pass with the given index.</summary>
        </member>
        <member name="M:Engine.Renderer.Technique.RemovePass(Engine.Renderer.Pass)">
            <summary>Removes the Pass.</summary>
        </member>
        <member name="M:Engine.Renderer.Technique.RemoveAllPasses">
            <summary>Removes all Passes from this Technique.</summary>
        </member>
        <member name="M:Engine.Renderer.Technique.IsSupported">
            <summary>
            Indicates if this technique is supported by the current graphics card.
            </summary>
            <remarks>
            This will only be correct after the Technique has been compiled, which is
            usually done from Material.Compile.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Technique.Name">
            <summary>
            Gets or sets the name of the technique.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Technique.Passes">
            <summary>
            Gets the passes collection. <b>Don't modify array elements.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.Technique.SchemeName">
            <summary>
            Gets or sets the 'scheme name' for this technique. 
            </summary>
            <remarks>
            <para>
            Material schemes are used to control top-level switching from one
            set of techniques to another. For example, you might use this to 
            define 'high', 'medium' and 'low' complexity levels on materials
            to allow a user to pick a performance / quality ratio. Another
            possibility is that you have a fully HDR-enabled pipeline for top
            machines, rendering all objects using unclamped shaders, and a 
            simpler pipeline for others; this can be implemented using 
            schemes.
            </para>
            <para>
            Every technique belongs to a scheme - if you don't specify one, the
            Technique belongs to the scheme called 'Default', which is also the
            scheme used to render by default. The active scheme is set 
            either by calling Viewport.MaterialScheme.
            </para>
            </remarks>
        </member>
        <member name="T:Engine.Renderer.FontManager">
            <summary>
            Manages font resources, parsing .fontDefinition files and generally organising them.
            </summary>
        </member>
        <member name="M:Engine.Renderer.FontManager.LoadFont(System.String,System.String,System.Single)">
            <summary>Loads font or returns already loaded font.</summary>
            <param name="name">The font name.</param>
            <param name="language">The font language.</param>
            <param name="height">The font height.</param>
            <returns><see cref="T:Engine.Renderer.Font"/> if the font has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.FontManager.LoadFont(System.String,System.Single)">
            <summary>Loads font or returns already loaded font.</summary>
            <param name="name">The font name.</param>
            <param name="height">The font height.</param>
            <returns><see cref="T:Engine.Renderer.Font"/> if the font has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.FontManager.DisposeFonts">
            <summary>Dispose all loaded fonts.</summary>
        </member>
        <member name="P:Engine.Renderer.FontManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.FontManager"/>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.BillboardSet">
            <summary>
            A collection of billboards (faces which are always facing the given direction) 
            with the same (default) dimensions, material and which are fairly close 
            proximity to each other.
            </summary>
            <remarks>
            <para>
            Billboards are rectangles made up of 2 tris which are always facing the given direction. They are typically used
            for special effects like particles. This class collects together a set of billboards with the same (default) dimensions,
            material and relative locality in order to process them more efficiently. The entire set of billboards will be
            culled as a whole (by default, although this can be changed if you want a large set of billboards
            which are spread out and you want them culled individually), individual Billboards have locations which are relative to the set (which itself derives it's
            position from the SceneNode it is attached to since it is a <see cref="T:Engine.Renderer.MovableObject"/>), 
            they will be rendered as a single rendering operation,
            and some calculations will be sped up by the fact that they use the same dimensions so some workings can be reused.
            </para>
            <para>
            A BillboardSet can be created using the SceneManager.CreateBillboardSet method. 
            </para>
            </remarks>
            <seealso cref="T:Engine.Renderer.BillboardSet"/>
        </member>
        <member name="M:Engine.Renderer.BillboardSet.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.BillboardSet.CreateBillboard(Engine.MathEx.Vec3,Engine.MathEx.ColorValue)">
            <summary>
            Creates a new billboard and adds it to this set.
            </summary>
            <param name="position">The position of the new billboard realtive to the certer of the set.</param>
            <param name="color">Base colour of the billboard.</param>
            <returns>On failiure (i.e. no more space and can't autoextend), <b>null</b> is returned.</returns>
        </member>
        <member name="M:Engine.Renderer.BillboardSet.CreateBillboard(Engine.MathEx.Vec3)">
            <summary>
            Creates a new billboard and adds it to this set.
            </summary>
            <param name="position">The position of the new billboard realtive to the certer of the set.</param>
            <returns>On failiure (i.e. no more space and can't autoextend), <b>null</b> is returned.</returns>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.Sorting">
            <summary>
            Gets or sets sorting of billboards value based on their distance from the camera.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.Billboards">
            <summary>
            Gets the billboards collection. <b>Don't modify array elements.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.Origin">
            <summary>
            Gets or sets the point which acts as the origin point for all billboards in this set.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.RotationType">
            <summary>
            Gets or sets billboard rotation type.
            </summary>
            <remarks>
            This setting controls the billboard rotation type, you can deciding rotate the billboard's vertices
            around their facing direction or rotate the billboard's texture coordinates.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.DefaultSize">
            <summary>
            Gets or sets the default dimensions of the billboards in this set.
            </summary>
            <remarks>
            All billboards in a set are created with these default dimensions. The set will render most efficiently if
            all the billboards in the set are the default size. It is possible to alter the size of individual
            billboards at the expense of extra calculation. See the Billboard class for more info.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.MaterialName">
            <summary>
            Gets or sets the name of the material to be used for this billboard set.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.CullIndividually">
            <summary>
            Gets or sets whether or not billbards in this are tested individually for culling.
            </summary>
            <remarks>
            <para>
            Billboard sets are always culled as a whole group, based on a bounding box which 
            encloses all billboards in the set. For fairly localised sets, this is enough. However, you
            can optionally tell the set to also cull individual billboards in the set, i.e. to test
            each individual billboard before rendering. The default is not to do this.
            </para>
            <para>
            This is useful when you have a large, fairly distributed set of billboards, like maybe 
            trees on a landscape. You probably still want to group them into more than one
            set (maybe one set per section of landscape), which will be culled coarsely, but you also
            want to cull the billboards individually because they are spread out. Whilst you could have
            lots of single-tree sets which are culled separately, this would be inefficient to render
            because each tree would be issued as it's own rendering operation.
            </para>
            <para>
            By calling this method with a parameter of true, you can have large billboard sets which 
            are spaced out and so get the benefit of batch rendering and coarse culling, but also have
            fine-grained culling so unnecessary rendering is avoided.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.BillboardType">
            <summary>
            Get or sets the type of billboard to render.
            </summary>
            <remarks>
            <para>
            The default sort of billboard (<b>Point</b>), always has both x and y axes parallel to 
            the camera's local axes. This is fine for 'point' style billboards (e.g. flares,
            smoke, anything which is symmetrical about a central point) but does not look good for
            billboards which have an orientation (e.g. an elongated raindrop). In this case, the
            oriented billboards are more suitable (<b>OrientedCommon</b> or <b>OrientedSelf</b>) since
            they retain an independant Y axis and only the X axis is generated, perpendicular to both
            the local Y and the camera Z.
            </para>
            <para>
            In some case you might want the billboard has fixed Z axis and doesn't need to face to
            camera (e.g. an aureola around the player and parallel to the ground). You can use
            <b>PerpendicularSelf</b> which the billboard plane perpendicular to the billboard own
            direction. Or <b>PerpendicularCommon</b> which the billboard plane perpendicular to the
            common direction.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.CommonDirection">
            <summary>
            Gets or sets the common direction for all billboards
            </summary>
            <remarks>
            <para>
            Use <b>OrientedCommon</b> when you want oriented billboards but you know they are always going to 
            be oriented the same way (e.g. rain in calm weather). It is faster for the system to calculate
            the billboard vertices if they have a common direction.
            </para>
            <para>
            The common direction also use in <b>PerpendicularCommon</b>, in this case the common direction
            treat as Z axis, and an additional common up-vector was use to determine billboard X and Y
            axis.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.CommonUpVector">
            <summary>
            Gets or sets the common up-vector for all billboards
            </summary>
            <remarks>
            <para>
            Use <b>PerpendicularSelf</b> or <b>PerpendicularCommon</b> when you want oriented billboards
            perpendicular to specify direction vector (or, Z axis), and doesn't face to camera.
            In this case, we need an additional up-vector to determine the billboard X and Y axis.
            The generated billboard plane and X-axis guarantee perpendicular to specify direction.
            </para>
            <para>
            The specify direction is billboard own direction when billboard type is <b>PerpendicularSelf</b>,
            and it's shared common direction when billboard type is <b>PerpendicularCommon</b>.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardSet.AccurateFacing">
            <summary>
            Gets whether or not billboards use an 'accurate' facing model
            based on the vector from each billboard to the camera, rather than 
            an optimised version using just the camera direction.			
            </summary>
            <remarks>
            By default, the axes for all billboards are calulated using the 
            camera's view direction, not the vector from the camera position to
            the billboard. The former is faster, and most of the time the difference
            is not noticeable. However for some purposes (e.g. very large, static
            billboards) the changing billboard orientation when rotating the camera
            can be off putting, therefore you can enable this option to use a
            more expensive, but more accurate version.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.SceneManager">
            <summary>
            Manages the organisation and rendering of a 'scene' i.e. a collection 
            of objects.
            </summary>
            <remarks>
            <para>
            This class defines the interface and the basic behaviour of a 
            'Scene Manager'. A SceneManager organises the culling and rendering of
            the scene, in conjunction with the render queue. This class is designed 
            to be extended through subclassing in order to provide more specialised
            scene organisation structures for particular needs.
            </para>
            <para>
            There is a distinction between 'objects' (which subclass <see cref="T:Engine.Renderer.MovableObject"/>, 
            and are movable, discrete objects in the world), and 'world geometry',
            which is large, generally static geometry. World geometry tends to 
            influence the SceneManager organisational structure (e.g. lots of indoor
            static geometry might result in a spatial tree structure) and as such
            world geometry is generally tied to a given SceneManager implementation,
            whilst <see cref="T:Engine.Renderer.MovableObject"/> instances can be used with any SceneManager.
            Subclasses are free to define world geometry however they please.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.SceneManager.GetSkyBoxTextureName">
            <summary>
            Returns sky box texture file path.
            </summary>
            <returns>File path if the sky box has been created; otherwise, empty string.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.AddRenderQueueListener(Engine.Renderer.RenderQueueListener)">
            <summary>
            Registers a new RenderQueueListener which will be notified when render queues
            are processed.
            </summary>
            <param name="listener">The render queue listener.</param>
        </member>
        <member name="M:Engine.Renderer.SceneManager.RemoveRenderQueueListener(Engine.Renderer.RenderQueueListener)">
            <summary>
            Removes a listener previously added with <see cref="M:Engine.Renderer.SceneManager.AddRenderQueueListener(Engine.Renderer.RenderQueueListener)"/>.
            </summary>
            <param name="listener">The render queue listener.</param>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateLight">
            <summary>
            Creates a light for use in the scene.
            </summary>
            <remarks>
            Lights can either be in a fixed position and independent of the
            scene graph, or they can be attached to SceneNodes so they derive
            their position from the parent node. Either way, they are created
            using this method so that the SceneManager manages their
            existence.
            </remarks>
            <returns><see cref="T:Engine.Renderer.RenderLight"/> if the light has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateCamera">
            <summary>
            Creates a camera to be managed by this scene manager.
            </summary>
            <returns><see cref="T:Engine.Renderer.Camera"/> if the camera has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.GetFogMode">
            <summary>
            Returns the fog mode for the scene.
            </summary>
        </member>
        <member name="M:Engine.Renderer.SceneManager.GetFogColor">
            <summary>
            Returns the fog color for the scene.
            </summary>
        </member>
        <member name="M:Engine.Renderer.SceneManager.GetFogStart">
            <summary>
            Returns the fog start distance for the scene.
            </summary>
        </member>
        <member name="M:Engine.Renderer.SceneManager.GetFogEnd">
            <summary>
            Returns the fog end distance for the scene.
            </summary>
        </member>
        <member name="M:Engine.Renderer.SceneManager.GetFogDensity">
            <summary>
            Returns the fog density for the scene.
            </summary>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateParticleSystem(System.String)">
            <summary>
            Creates a particle system object.
            </summary>
            <remarks>
            <para>
            This method creates a new ParticleSystem instance based on the named template and returns a 
            pointer to the caller.
            </para>
            <para>
            Each system created from a template takes the template's settings at the time of creation, 
            but is completely separate from the template from there on. 
            </para>
            <para>
            Creating a particle system does not make it a part of the scene. As with other <see cref="T:Engine.Renderer.MovableObject"/>
            subclasses, a ParticleSystem is not rendered until it is attached to a <see cref="T:Engine.Renderer.SceneNode"/>. 
            </para>
            <para>
            This is probably the more useful particle system creation method since it does not require manual
            setup of the system. Note that the initial quota is based on the template but may be changed later.
            </para>
            </remarks>
            <param name="templateName">The name of the template to base the new instance on.</param>
            <returns><see cref="T:Engine.Renderer.ParticleSystem"/> if the particle system has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateRibbonTrail">
            <summary>
            Create a RibbonTrail, an object which you can use to render
            a linked chain of billboards which follows one or more nodes.
            </summary>
            <returns><see cref="T:Engine.Renderer.RibbonTrail"/> if the ribbon trail has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateBillboardSet(System.Int32)">
            <summary>
            Creates a new BillboardSet for use with this scene manager.
            </summary>
            <param name="poolSize">The initial size of the pool of billboards (see <see cref="T:Engine.Renderer.BillboardSet"/> for more information).</param>
            <returns><see cref="T:Engine.Renderer.BillboardSet"/> if the billboard set has been created; otherwise, <b>null</b>.</returns>
            <remarks>
            <para>
            This method creates a new BillboardSet which is registered with the SceneManager.
            </para>
            <para>
            See the <see cref="T:Engine.Renderer.BillboardSet"/> documentations for full details of the
            returned class.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateMeshObject(System.String)">
            <summary>
            Creates a mesh object.
            </summary>
            <param name="meshName">The mesh name.</param>
            <returns><see cref="T:Engine.Renderer.MeshObject"/> if the mesh object has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateStaticMeshObject(Engine.MathEx.Bounds,Engine.MathEx.Vec3,Engine.MathEx.Quat,Engine.MathEx.Vec3,Engine.Renderer.Material,Engine.Renderer.VertexData,Engine.Renderer.IndexData,System.Boolean,System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:Engine.Renderer.StaticMeshObject"/> class.
            </summary>
            <param name="worldBounds">The object bounds.</param>
            <param name="position">The object position.</param>
            <param name="rotation">The object rotation.</param>
            <param name="scale">The object scale.</param>
            <param name="material">The material.</param>
            <param name="vertexData">The vertex data.</param>
            <param name="indexData">The index data.</param>
            <param name="needDisposeVertexIndexData">
            <param name="precalculatedEdgeList"></param>
            Whether it is necessary to delete the vertex and index data after object delete.
            </param>
            <returns><see cref="T:Engine.Renderer.StaticMeshObject"/> instance.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateStaticMeshObject(Engine.MathEx.Bounds,Engine.MathEx.Vec3,Engine.MathEx.Quat,Engine.MathEx.Vec3,Engine.Renderer.Material,Engine.Renderer.VertexData,Engine.Renderer.IndexData,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Engine.Renderer.StaticMeshObject"/> class.
            </summary>
            <param name="worldBounds">The object bounds.</param>
            <param name="position">The object position.</param>
            <param name="rotation">The object rotation.</param>
            <param name="scale">The object scale.</param>
            <param name="material">The material.</param>
            <param name="vertexData">The vertex data.</param>
            <param name="indexData">The index data.</param>
            <param name="needDisposeVertexIndexData">
            Whether it is necessary to delete the vertex and index data after object delete.
            </param>
            <returns><see cref="T:Engine.Renderer.StaticMeshObject"/> instance.</returns>
        </member>
        <member name="M:Engine.Renderer.SceneManager.CreateDummyMovableObject">
            <summary>
            Create a dummy movable object, an object which you can occurs to custom 
            scene management events.
            </summary>
            <returns><see cref="T:Engine.Renderer.DummyMovableObject"/> if the object has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="P:Engine.Renderer.SceneManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.SceneManager"/>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneManager.AmbientLight">
            <summary>
            Gets or sets the ambient light level to be used for the scene.
            </summary>
            <remarks>
            <para>
            This sets the color and intensity of the ambient light in the scene, i.e. the
            light which is 'sourceless' and illuminates all objects equally.
            The color of an object is affected by a combination of the light in the scene,
            and the amount of light that object reflects.
            </para>
            <para>
            By default the ambient light in the scene is Black, i.e. no ambient light. This
            means that any objects rendered with a Material which has lighting enabled
            will not be visible unless you have some dynamic lights in your scene.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowColor">
            <summary>
            Gets or sets the color used to modulate areas in shadow. 
            </summary>
            <remarks>
            This is only applicable for shadow techniques which involve 
            darkening the area in shadow, as opposed to masking out the light. 
            This color provided is used as a modulative value to darken the
            areas.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowFarDistance">
            <summary>
            Gets or sets the maximum distance away from the camera that shadows
            will be visible.
            </summary>
            <remarks>
            <para>
            Shadow techniques can be expensive, therefore it is a good idea
            to limit them to being rendered close to the camera if possible,
            and to skip the expense of rendering shadows for distance objects.
            This method allows you to set the distance at which shadows will no
            longer be rendered.
            </para>
            <para>
            Each shadow technique can interpret this subtely differently.
            For example, one technique may use this to eliminate casters,
            another might use it to attenuate the shadows themselves.
            You should tweak this value to suit your chosen shadow technique
            and scene setup.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowTechnique">
            <summary>
            Gets or sets the general shadow technique to be used in this scene.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowCasterRenderBackFaces">
            <summary>
            Sets whether or not shadow casters should be rendered into shadow
            textures using their back faces rather than their front faces. 
            </summary>
            <remarks>
            Rendering back faces rather than front faces into a shadow texture
            can help minimise depth comparison issues, if you're using depth
            shadowmapping. You will probably still need some biasing but you
            won't need as much. For solid objects the result is the same anyway,
            if you have objects with holes you may want to turn this option off.
            The default is to enable this option.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowTextureSelfShadow">
            <summary>
            Gets or sets whether or not texture shadows should attempt to self-shadow.
            </summary>
            <remarks>
            The default implementation of texture shadows uses a fixed-function 
            colour texture projection approach for maximum compatibility, and 
            as such cannot support self-shadowing. However, if you decide to 
            implement a more complex shadowing technique using the 
            setShadowTextureCasterMaterial and setShadowTextureReceiverMaterial 
            there is a possibility you may be able to support 
            self-shadowing (e.g by implementing a shader-based shadow map). In 
            this case you might want to enable this option.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowDirLightTextureOffset">
            <summary>
            Gets or sets the proportional distance which a texture shadow which is generated from a
            directional light will be offset into the camera view to make best use of texture space.
            </summary>
            <remarks>
            When generating a shadow texture from a directional light, an approximation is used
            since it is not possible to render the entire scene to one texture. 
            The texture is projected onto an area centred on the camera, and is
            the shadow far distance * 2 in length (it is square). This wastes
            a lot of texture space outside the frustum though, so this offset allows
            you to move the texture in front of the camera more. However, be aware
            that this can cause a little shadow 'jittering' during rotation, and
            that if you move it too far then you'll start to get artefacts close 
            to the camera. The value is represented as a proportion of the shadow
            far distance, and the default is 0.6.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowDirectionalLightExtrusionDistance">
            <summary>
            Gets or sets the distance a shadow volume is extruded for a directional light.
            </summary>
            <remarks>
            <para>
            Although directional lights are essentially infinite, there are many
            reasons to limit the shadow extrusion distance to a finite number, 
            not least of which is compatibility with older cards (which do not
            support infinite positions), and shadow caster elimination.
            </para>
            <para>
            The default value is 1,000 world units. This does not apply to
            point lights or spotlights, since they extrude up to their 
            attenuation range.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.ShadowTextureDefaultCasterMaterialName">
            <summary>
            Gets or sets the default material to use for rendering shadow casters.
            </summary>
            <remarks>
            <para>
            By default shadow casters are rendered into the shadow texture using
            an automatically generated fixed-function pass. This allows basic
            projective texture shadows, but it's possible to use more advanced
            shadow techniques by overriding the caster and receiver materials, for
            example providing vertex and fragment programs to implement shadow
            maps.
            </para>
            <para>
            You can rely on the ambient light in the scene being set to the 
            requested texture shadow colour, if that's useful. 
            </para>
            <para>
            Individual objects may also override the vertex program in
            your default material if their materials include 
            shadow_caster_vertex_program_ref shadow_receiver_vertex_program_ref
            entries, so if you use both make sure they are compatible.
            </para>
            <para>
            Only a single pass is allowed in your material, although multiple
            techniques may be used for hardware fallback.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SceneManager.SceneNodes">
            <summary>
            Gets the scene nodes collection.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneManager.MovableObjects">
            <summary>
            Gets the movable objects collection.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneManager.DrawModels">
            <summary>
            Gets or sets which sets a flag of rendering of models.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneManager.DrawEffects">
            <summary>
            Gets or sets flag which sets a flag of rendering of effects.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneManager.StaticMeshObjects">
            <summary>
            Gets the static mesh objects collection.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RenderWindow">
            <summary>
            Manages the target rendering window.
            </summary>
            <remarks>
            <para>
            </para>
            This class handles a window into which the contents
            of a scene are rendered. There is a many-to-1 relationship
            between instances of this class an instance of RenderSystem
            which controls the rendering of the scene. There may be
            more than one window in the case of level editor tools etc.
            This class is abstract since there may be
            different implementations for different windowing systems.
            <para>
            Instances are created and communicated with by the render system
            although client programs can get a reference to it from
            the render system if required for resizing or moving.
            Note that you can have multiple viewpoints
            in the window for effects like rear-view mirrors and
            picture-in-picture views (see <see cref="T:Engine.Renderer.Viewport"/> and <see cref="T:Engine.Renderer.Camera"/>).
            </para>
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RenderTarget">
            <summary>
            A 'canvas' which can receive the results of a rendering operation.
            </summary>
            <remarks>
            This class defines a common root to all targets of rendering operations. A
            render target could be a window on a screen, or another
            offscreen surface like a texture or bump map etc.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTarget.DisposeInternal">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.RenderTarget.AddViewport(Engine.Renderer.Camera)">
            <summary>
            Adds a viewport to the rendering target.
            </summary>
            <param name="camera">The camera from which the viewport contents will be rendered.</param>
            <returns>The viewport.</returns>
            <remarks>
            A viewport is the rectangle into which redering output is sent. This method adds
            a viewport to the render target, rendering from the supplied camera. The
            rest of the parameters are only required if you wish to add more than one viewport
            to a single rendering target. Note that size information passed to this method is
            passed as a parametric, i.e. it is relative rather than absolute. This is to allow
            viewports to automatically resize along with the target.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTarget.Update(System.Boolean)">
            <summary>
            Tells the target to update it's contents.
            </summary>
            <remarks>
            <param name="forceBeginNewRenderFrame">
            This parameter means, whether it will be begun new the render frame.
            Set it to <b>true</b> only for contents to be refreshed only when required.
            For default behaviour (per frame updating) this parameter should set to <b>false</b>.
            </param>
            <para>
            If render target is not running in an automatic rendering loop,
            the user of the library is responsible for asking each render
            target to refresh. This is the method used to do this. It automatically
            re-renders the contents of the target using whatever cameras have been
            pointed at it.
            </para>
            <para>
            This allows Engine to be used in multi-windowed utilities
            and for contents to be refreshed only when required, rather than
            constantly as with the automatic rendering loop.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTarget.AddListener(Engine.Renderer.RenderTargetListener)">
            <summary>
            Add a listener to this RenderTarget which will be called back before and after rendering.
            </summary>
            <param name="listener">The render target listener.</param>
            <remarks>
            If you want notifications before and after a target is updated by the system, use
            this method to register your own custom RenderTargetListener class. This is useful
            for potentially adding your own manual rendering commands before and after the
            'normal' system rendering.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTarget.RemoveListener(Engine.Renderer.RenderTargetListener)">
            <summary>
            Removes a RenderTargetListener previously registered.
            </summary>
            <param name="listener">The render target listener.</param>
        </member>
        <member name="M:Engine.Renderer.RenderTarget.WriteContentsToFile(System.String)">
            <summary>
            Writes the current contents of the render target to the named file.
            </summary>
            <param name="fileName">The file name.</param>
        </member>
        <member name="P:Engine.Renderer.RenderTarget.Active">
            <summary>
            Gets or sets the active state of the render target.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderTarget.AutoUpdate">
            <summary>
            Gets or sets whether this target should be automatically updated.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderTarget.Size">
            <summary>
            Gets the render target size.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderWindow.DisposeInternal">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.RenderWindow.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="T:Engine.Renderer.RenderTargetEvent">
            <summary>Struct containing information about a RenderTarget event.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderTargetEvent.Source">
            <summary>The source of the event being raised.</summary>
        </member>
        <member name="T:Engine.Renderer.RenderTargetViewportEvent">
            <summary>Struct containing information about a RenderTarget Viewport-specific event.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderTargetViewportEvent.Source">
            <summary>The source of the event being raised.</summary>
        </member>
        <member name="T:Engine.Renderer.RenderTargetListener">
            <summary>
            A interface class defining a listener which can be used to receive
            notifications of RenderTarget events.
            </summary>
            <remarks>
            <para>
            A 'listener' is an interface designed to be called back when
            particular events are called. This class defines the
            interface relating to RenderTarget events. In order to receive
            notifications of RenderTarget events, you should create a subclass of
            RenderTargetListener and override the methods for which you would like
            to customise the resulting processing. You should then call
            RenderTarget.AddListener passing an instance of this class.
            There is no limit to the number of RenderTarget listeners you can register,
            allowing you to register multiple listeners for different purposes.
            </para>
            <para>
            RenderTarget events occur before and after the target is updated as a whole,
            and before and after each viewport on that target is updated. Each RenderTarget
            holds it's own set of listeners, but you can register the same listener on
            multiple render targets if you like since the event contains details of the
            originating RenderTarget.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.OnPreRenderTargetUpdate(Engine.Renderer.RenderTargetEvent)">
            <summary>
            Called just before a RenderTarget is about to be rendered into.
            </summary>
            <param name="evt">The event.</param>
            <remarks>
            This event is raised just before any of the viewports on the target
            are rendered to.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.OnPostRenderTargetUpdate(Engine.Renderer.RenderTargetEvent)">
            <summary>
            Called just after a RenderTarget has been rendered to.
            </summary>
            <param name="evt">The event.</param>
            <remarks>
            This event is called just after all the viewports attached to the target
            in question have been rendered to.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.OnPreViewportUpdate(Engine.Renderer.RenderTargetViewportEvent)">
            <summary>
            Called just before a Viewport on a RenderTarget is to be updated.
            </summary>
            <param name="evt">The event.</param>
            <remarks>
            This method is called before each viewport on the RenderTarget is
            rendered to. You can use this to perform per-viewport settings changes.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.OnPostViewportUpdate(Engine.Renderer.RenderTargetViewportEvent)">
            <summary>
            Called just after a Viewport on a RenderTarget is to be updated.
            </summary>
            <param name="evt">The event.</param>
            <remarks>
            This method is called after each viewport on the RenderTarget is
            rendered to. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.OnViewportAdded(Engine.Renderer.RenderTargetViewportEvent)">
            <summary>
            Called to notify listener that a Viewport has been added to the target in question.
            </summary>
            <param name="evt">The event.</param>
        </member>
        <member name="M:Engine.Renderer.RenderTargetListener.OnViewportRemoved(Engine.Renderer.RenderTargetViewportEvent)">
            <summary>
            Called to notify listener that a Viewport has been removed from the target in question.
            </summary>
            <param name="evt">The event.</param>
        </member>
        <member name="T:Engine.Renderer.Pass">
            <summary>
            Class defining a single pass of a <see cref="T:Engine.Renderer.Technique"/> (of a <see cref="T:Engine.Renderer.Material"/>), ie
            a single rendering call.
            </summary>
            <remarks>
            <para>
            Rendering can be repeated with many passes for more complex effects.
            Each pass is either a fixed-function pass (meaning it does not use
            a vertex or fragment program) or a programmable pass (meaning it does
            use either a vertex and fragment program, or both). 
            </para>
            <para>
            Programmable passes are complex to define, because they require custom
            programs and you have to set all constant inputs to the programs (like
            the position of lights, any base material colors you wish to use etc), but
            they do give you much total flexibility over the algorithms used to render your
            pass, and you can create some effects which are impossible with a fixed-function pass.
            On the other hand, you can define a fixed-function pass in very little time, and
            you can use a range of fixed-function effects like environment mapping very
            easily, plus your pass will be more likely to be compatible with older hardware.
            There are pros and cons to both, just remember that if you use a programmable
            pass to create some great effects, allow more time for definition and testing.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Pass.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Pass.CreateTextureUnitState(System.String,System.Int32)">
            <summary>
            Inserts a new TextureUnitState object into the Pass.
            </summary>
            <param name="textureName">The texture name.</param>
            <param name="texCoordSet">The index of the texture coordinate set to use.</param>
            <returns>The new TextureUnitState object</returns>
            <remarks>
            This unit is is added on top of all previous units. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Pass.CreateTextureUnitState(System.String)">
            <summary>
            Inserts a new TextureUnitState object into the Pass.
            </summary>
            <param name="textureName">The texture name.</param>
            <returns>The new TextureUnitState object</returns>
            <remarks>
            This unit is is added on top of all previous units. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Pass.CreateTextureUnitState">
            <summary>
            Inserts a new TextureUnitState object into the Pass.
            </summary>
            <returns>The new TextureUnitState object</returns>
            <remarks>
            This unit is is added on top of all previous units. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Pass.SetFogOverride(Engine.Renderer.FogMode,Engine.MathEx.ColorValue,System.Single,System.Single,System.Single)">
            <summary>
            Sets the fogging mode applied to this pass.
            </summary>
            <remarks>
            <para>
            Fogging is an effect that is applied as polys are rendered. Sometimes, you want
            fog to be applied to an entire scene. Other times, you want it to be applied to a few
            polygons only. This pass-level specification of fog parameters lets you easily manage
            both.
            </para>
            </remarks>
            <param name="mode">
            Set a pass-specific fog mode as defined in the enum <see cref="T:Engine.Renderer.FogMode"/>.
            </param>
            <param name="color">
            The color of the fog. Either set this to the same as your viewport background color,
            or to blend in with a skydome or skybox.
            </param>
            <param name="expDensity">
            The density of the fog in <b>Exp</b> or <b>Exp2</b> mode, as a value between 0 and 1.
            The default is 0.001.
            </param>
            <param name="linearStart">
            Distance in world units at which linear fog starts to encroach.
            Only applicable if mode is <b>Linear</b>.
            </param>
            <param name="linearEnd">
            Distance in world units at which linear fog becomes completely opaque.
            Only applicable if mode is <b>Linear</b>.
            </param>
        </member>
        <member name="M:Engine.Renderer.Pass.ResetFogOverride">
            <summary>
            Reset the fogging mode applied to this pass.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pass.GetFogOverride">
            <summary>
            Returns true if this pass is to override the scene fog settings.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pass.GetFogMode">
            <summary>
            Returns the fog mode for this pass.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pass.GetFogColor">
            <summary>
            Returns the fog color for this pass.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pass.GetFogStart">
            <summary>
            Returns the fog start distance for this pass.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pass.GetFogEnd">
            <summary>
            Returns the fog end distance for this pass.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pass.GetFogDensity">
            <summary>
            Returns the fog density for this pass.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.Parent">
            <summary>
            Gets the parent Technique
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.TextureUnitStates">
            <summary>Gets the texture unit states collection. <b>Don't modify array elements.</b></summary>
        </member>
        <member name="P:Engine.Renderer.Pass.VertexProgramParameters">
            <summary>
            Gets the vertex program parameters.
            </summary>
            <remarks>
            Only applicable to programmable passes.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.FragmentProgramParameters">
            <summary>
            Gets the fragment program parameters.
            </summary>
            <remarks>
            Only applicable to programmable passes.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.VertexProgramName">
            <summary>
            Gets or sets the name of the vertex program used by this pass.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.FragmentProgramName">
            <summary>
            Gets or sets the name of the fragment program used by this pass.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.Ambient">
            <summary>
            Gets or sets the ambient color reflectance properties of this pass.
            </summary>
            <remarks>
            This setting has no effect if dynamic lighting is disabled, or if this 
            is a programmable pass.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.Diffuse">
            <summary>
            Gets or sets the diffuse color reflectance properties of this pass.
            </summary>
            <remarks>
            This setting has no effect if dynamic lighting is disabled, or if this 
            is a programmable pass.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.Specular">
            <summary>
            Gets or sets the specular color reflectance properties of this pass.
            </summary>
            <remarks>
            This setting has no effect if dynamic lighting is disabled, or if this 
            is a programmable pass.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.SelfIllumination">
            <summary>
            Gets or sets the amount of self-illumination an object has.
            </summary>
            <remarks>
            This setting has no effect if dynamic lighting is disabled, or if this 
            is a programmable pass.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.Shininess">
            <summary>
            Gets or sets the shininess of the pass, affecting the size of specular highlights.
            </summary>
            <remarks>
            This setting has no effect if dynamic lighting is disabled, or if this 
            is a programmable pass.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.SourceBlendFactor">
            <summary>
            Gets or sets the source blend factor.
            </summary>
            <remarks>
            <para>
            Allows very fine control of blending this Pass with the existing contents of the scene.
            Wheras the texture blending operations seen in the TextureUnitState class are 
            concerned with blending between texture layers, this blending is about combining 
            the output of the material as a whole with the existing contents of the rendering 
            target. This blending therefore allows object transparency and other special effects.
            </para>
            <para>
            This version of the method allows complete control over the blending operation, 
            by specifying the source and destination blending factors. The result of the 
            blending operation is: final = (texture * sourceFactor) + (pixel * destFactor)
            </para>
            <para>
            Each of the factors is specified as one of a number of options, as specified 
            in the SceneBlendFactor enumerated type.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.DestBlendFactor">
            <summary>
            Gets or sets the destination blend factor.
            </summary>
            <remarks>
            <para>
            Allows very fine control of blending this Pass with the existing contents of the scene.
            Wheras the texture blending operations seen in the TextureUnitState class are 
            concerned with blending between texture layers, this blending is about combining 
            the output of the material as a whole with the existing contents of the rendering 
            target. This blending therefore allows object transparency and other special effects.
            </para>
            <para>
            This version of the method allows complete control over the blending operation, 
            by specifying the source and destination blending factors. The result of the 
            blending operation is: final = (texture * sourceFactor) + (pixel * destFactor)
            </para>
            <para>
            Each of the factors is specified as one of a number of options, as specified 
            in the SceneBlendFactor enumerated type.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.DepthCheck">
            <summary>
            Gets or sets whether or not this pass renders with depth-buffer checking on or not.
            </summary>
            <remarks>
            <para>
            If depth-buffer checking is on, whenever a pixel is about to be written to the 
            frame buffer the depth buffer is checked to see if the pixel is in front 
            of all other pixels written at that point. If not, the pixel is not written.
            </para>
            <para>
            If depth checking is off, pixels are written no matter what has been rendered before.
            Also see setDepthFunction for more advanced depth check configuration.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.DepthWrite">
            <summary>
            Gets or sets whether or not this pass renders with depth-buffer writing on or not.
            </summary>
            <remarks>
            <para>
            If depth-buffer writing is on, whenever a pixel is written to the frame buffer
            the depth buffer is updated with the depth value of that new pixel, thus affecting future
            rendering operations if future pixels are behind this one.
            </para>
            <para>
            If depth writing is off, pixels are written without updating the depth buffer 
            Depth writing should normally be on but can be turned off when rendering 
            static backgrounds or when rendering a collection of transparent objects 
            at the end of a scene so that they overlap each other correctly.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.IteratePerLight">
            <summary>
            Gets or sets whether or not this pass should iterate per light or number of
            lights which can affect the object being rendered.
            </summary>
            <remarks>
            <para>
            The default behaviour for a pass (when this option is 'false'), is
            for a pass to be rendered only once (or the number of times set in
            SetPassIterationCount), with all the lights which could
            affect this object set at the same time (up to the maximum lights
            allowed in the render system, which is typically 8).
            </para>
            <para>
            Setting this option to 'true' changes this behaviour, such that
            instead of trying to issue render this pass once per object, it
            is run <b>per light</b>, or for a group of 'n' lights each time
            which can affect this object, the number of
            times set in setPassIterationCount (default is once). In
            this case, only light index 0 is ever used, and is a different light
            every time the pass is issued, up to the total number of lights
            which is affecting this object. This has 2 advantages:
            <ul><li>There is no limit on the number of lights which can be
            supported</li>
            <li>It's easier to write vertex / fragment programs for this because
            a single program can be used for any number of lights</li>
            </ul>
            However, this technique is more expensive, and typically you
            will want an additional ambient pass, because if no lights are 
            affecting the object it will not be rendered at all, which will look
            odd even if ambient light is zero (imagine if there are lit objects
            behind it - the objects silhouette would not show up). Therefore,
            use this option with care, and you would be well advised to provide
            a less expensive fallback technique for use in the distance.
            </para>
            <para>
            The number of times this pass runs is still limited by the maximum
            number of lights allowed as set in SetMaxSimultaneousLights, so
            you will never get more passes than this. Also, the iteration is
            started from the 'start light' as set in Pass.SetStartLight, and
            the number of passes is the number of lights to iterate over divided
            by the number of lights per iteration (default 1, set by 
            SetLightCountPerIteration).
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.RunOnlyForOneLightType">
            <summary>
            Does this pass run only for a single light type 
            (if <see cref="P:Engine.Renderer.Pass.IteratePerLight"/> is <b>true</b>).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.OnlyLightType">
            <summary>
            Gets the single light type this pass runs for if <see cref="P:Engine.Renderer.Pass.IteratePerLight"/> and
            <see cref="P:Engine.Renderer.Pass.RunOnlyForOneLightType"/> are both <b>true</b>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.Lighting">
            <summary>
            Gets or sets whether or not dynamic lighting is enabled.
            </summary>
            <remarks>
            <para>
            If <b>true</b>, dynamic lighting is performed on geometry with normals supplied, 
            geometry without normals will not be displayed.
            </para>
            <para>
            If <b>false</b>, no lighting is applied and all geometry will be full brightness.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.CullingMode">
            <summary>
            Gets or sets the culling mode for this pass based on the 'vertex winding'.
            </summary>
            <remarks>
            <para>
            A typical way for the rendering engine to cull triangles is based on the 
            'vertex winding' of triangles. Vertex winding refers to the direction in 
            which the vertices are passed or indexed to in the rendering operation as 
            viewed from the camera, and will wither be clockwise or anticlockwise.
            The default is <b>CullingMode.Clockwise</b> i.e. that only triangles whose 
            vertices are passed/indexed in anticlockwise order are rendered - this is a common 
            approach and is used in 3D studio models for example. You can alter this 
            culling mode if you wish but it is not advised unless you know what you are doing.
            </para>
            <para>
            You may wish to use the <b>CullingMode.None</b> option for mesh data that you cull 
            yourself where the vertex winding is uncertain.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.AlphaRejectFunction">
            <summary>
            Gets or sets the way the pass will have use alpha to totally reject pixels 
            from the pipeline.
            </summary>
            <remarks>
            <para>
            The default is <b>CompareFunction.AlwaysPass</b> i.e. alpha is not used to reject pixels.
            </para>
            <para>
            This option applies in both the fixed function and the programmable pipeline.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.AlphaRejectValue">
            <summary>
            Gets or sets the alpha reject value.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.AlphaToCoverage">
            <summary>
            Gets or sets whether to use alpha to coverage (A2C) when blending alpha rejected values.
            </summary>
            <remarks>
            Alpha to coverage performs multisampling on the edges of alpha-rejected
            textures to produce a smoother result. It is only supported when multisampling
            is already enabled on the render target, and when the hardware supports
            alpha to coverage (see RenderSystemCapabilities). 
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.PolygonMode">
            <summary>
            Gets or sets the type of polygon rendering required
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pass.ColorWrite">
            <summary>
            Gets or sets whether or not colour buffer writing is enabled for this Pass.
            </summary>
            <remarks>
            For some effects, you might wish to turn off the colour write operation
            when rendering geometry; this means that only the depth buffer will be
            updated (provided you have depth buffer writing enabled, which you
            probably will do, although you may wish to only update the stencil
            buffer for example - stencil buffer state is managed at the RenderSystem
            level only, not the Material since you are likely to want to manage it
            at a higher level).
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Pass.StencilShadowsIlluminationStage">
            <summary>
            Manually set which illumination stage this pass is a member of.
            </summary>
            <remarks>
            <para>
            When using an additive lighting mode (shadow stencil additive or
            shadow texture additive), the scene is rendered in 3 discrete
            stages, ambient (or pre-lighting), per-light (once per light, with 
            shadowing) and decal (or post-lighting). Usually engine figures out how
            to categorise your passes automatically, but there are some effects you
            cannot achieve without manually controlling the illumination. For example
            specular effects are muted by the typical sequence because all textures
            are saved until the StencilShadowsIlluminationStage.Decal stage which mutes the 
            specular effect. 
            Instead, you could do texturing within the per-light stage if it's
            possible for your material and thus add the specular on after the
            decal texturing, and have no post-light rendering.
            </para>
            <para>
            If you assign an illumination stage to a pass you have to assign it
            to all passes in the technique otherwise it will be ignored. Also note
            that whilst you can have more than one pass in each group, they cannot
            alternate, ie all ambient passes will be before all per-light passes, 
            which will also be before all decal passes. Within their categories
            the passes will retain their ordering though.
            </para>
            </remarks>
        </member>
        <member name="T:Engine.Renderer.ParticleEmitter">
            <summary>
            Abstract class defining the interface to be implemented by particle emitters.
            </summary>
            <remarks>
            <para>
            Particle emitters are the sources of particles in a particle system. 
            This class defines the ParticleEmitter interface, and provides a basic implementation 
            for tasks which most emitters will do (these are of course overridable).
            Particle emitters can be  grouped into types, e.g. 'point' emitters, 'box' emitters etc; each type will 
            create particles with a different starting point, direction and velocity (although
            within the types you can configure the ranges of these parameters). 
            </para>
            <para>
            Because there are so many types of emitters you could use, Engine chooses not to dictate
            the available types. It comes with some in-built, but allows plugins or applications to extend the emitter types available.
            This is done by subclassing ParticleEmitter to have the appropriate emission behaviour you want,
            and also creating a subclass of ParticleEmitterFactory which is responsible for creating instances 
            of your new emitter type. You register this factory with the ParticleSystemManager using
            addEmitterFactory, and from then on emitters of this type can be created either from code or through
            text particle scripts by naming the type.
            </para>
            <para>
            This same approach is used for ParticleAffectors (which modify existing particles per frame).
            This means that Engine is particularly flexible when it comes to creating particle system effects,
            with literally infinite combinations of emitter and affector types, and paramters within those
            types.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.ParticleEmitter.ToString">
            <summary>
            Returns the name of the type of emitter.
            </summary>
            <returns>The name of the type of emitter.</returns>
        </member>
        <member name="M:Engine.Renderer.ParticleEmitter.IsAlwaysEmitted">
            <summary>
            Returns a value which indicates a emitter which will be never turn off.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.Enable">
            <summary>
            Gets or sets the flag indicating if this emitter is enabled or not.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.Position">
            <summary>
            Gets or sets the position of this emitter relative to thte center of the particle system.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.Direction">
            <summary>
            Gets or sets the direction of the emitter.
            </summary>
            <remarks>
            Most emitters will have a base direction in which they emit particles (those which
            emit in all directions will ignore this parameter). They may not emit exactly along this
            vector for every particle, many will introduce a random scatter around this vector using 
            the angle property.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.Angle">
            <summary>
            Gets or sets the maximum angle away from the emitter direction which particle will be emitted.
            </summary>
            <remarks>
            Whilst the direction property defines the general direction of emission for particles, 
            this property defines how far the emission angle can deviate away from this base direction.
            This allows you to create a scatter effect - if set to 0, all particles will be emitted
            exactly along the emitters direction vector, wheras if you set it to 180 degrees or more,
            particles will be emitted in a sphere, i.e. in all directions.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.ParticleVelocity">
            <summary>
            Gets or sets the initial velocity range of particles emitted.
            </summary>
            <remarks>
            This property gets or sets the range of starting speeds for emitted particles. 
            See the alternate version of this method which takes 1 parameter if you want a 
            constant speed. This emitter will randomly choose a speed between the minimum and 
            maximum for each particle.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.EmissionRate">
            <summary>
            Gets or sets the emission rate for this emitter.
            </summary>
            <remarks>
            This method tells the emitter how many particles per second should be emitted. The emitter
            subclass does not have to emit these in a continuous burst - this is a relative parameter
            and the emitter may choose to emit all of the second's worth of particles every half-second
            for example. This is controlled by the emitter's GetEmissionCount method.
            <para>
            </para>
            <para>
            Also, if the ParticleSystem's particle quota is exceeded, not all the particles requested
            may be actually emitted.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.TimeToLive">
            <summary>
            Gets or sets the lifetime of all particles emitted.
            </summary>
            <remarks>
            <para>
            The emitter initialises particles with a time-to-live (TTL), the number of seconds a particle
            will exist before being destroyed. This method sets a constant TTL for all particles emitted.
            Note that affectors are able to modify the TTL of particles later.
            </para>
            <para>
            Also see the alternate version of this method which takes a min and max TTL in order to 
            have the TTL vary per particle.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.Color">
            <summary>
            Gets or sets the initial colour of particles emitted.
            </summary>
            <remarks>
            Particles have an initial colour on emission which the emitter sets. This method sets
            this colour. See the alternate version of this method which takes 2 colours in order to establish 
            a range of colours to be assigned to particles.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.Duration">
            <summary>
            Gets or sets the duration of the emitter.
            </summary>
            <remarks>
            <para>
            By default emitters run indefinitely (unless you manually disable them). By setting this
            parameter, you can make an emitter turn off on it's own after a set number of seconds. It
            will then remain disabled until either <see cref="P:Engine.Renderer.ParticleEmitter.Enable"/> = <b>true</b> is called, or if the 'repeatAfter' parameter
            has been set it will also repeat after a number of seconds.
            </para>
            <para>
            Also see the alternative version of this method which allows you to set a min and max duration for
            a random variable duration.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleEmitter.RepeatDelay">
            <summary>
            Gets or sets the time between repeats of the emitter.
            </summary>
            <remarks>
            <para>
            By default emitters run indefinitely (unless you manually disable them). However, if you manually
            disable the emitter (by calling <see cref="P:Engine.Renderer.ParticleEmitter.Enable"/> = <b>false</b>, or it's duration runs out, it will cease to emit
            </para>
            <para>
            Also see the alternative version of this method which allows you to set a min and max duration for
            a random variable duration.
            </para>
            </remarks>
        </member>
        <member name="T:Engine.Renderer.PointEmitter">
            <summary>
            Particle emitter which emits particles from a single point.
            </summary>
            <remarks>
            This basic particle emitter emits particles from a single point in space. The
            initial direction of these particles can either be a single direction (i.e. a line),
            a random scattering inside a cone, or a random scattering in all directions, 
            depending the 'angle' parameter, which is the angle across which to scatter the 
            particles either side of the base direction of the emitter. 
            </remarks>
        </member>
        <member name="T:Engine.Renderer.AreaEmitter">
            <summary>
            Particle emitter which emits particles randomly from points inside
            an area (box, sphere, ellipsoid whatever subclasses choose to be).
            </summary>
            <remarks>
            This is an empty superclass and needs to be subclassed. Basic particle
            emitter emits particles from/in an (unspecified) area. The
            initial direction of these particles can either be a single direction
            (i.e. a line), a random scattering inside a cone, or a random
            scattering in all directions, depending the 'angle' parameter, which
            is the angle across which to scatter the particles either side of the
            base direction of the emitter. 
            </remarks>
        </member>
        <member name="P:Engine.Renderer.AreaEmitter.Size">
            <summary>
            Gets or sets the size of the area from which particles are emitted.
            </summary>
            <remarks>
            Vector describing the size of the area. The area extends
            around the center point by half the x, y and z components of
            this vector. The box is aligned such that it's local Z axis points
            along it's direction (see <see cref="P:Engine.Renderer.ParticleEmitter.Direction"/>)
            </remarks>
        </member>
        <member name="T:Engine.Renderer.BoxEmitter">
            <summary>
            Particle emitter which emits particles randomly from points inside a box.
            </summary>
            <remarks>
            This basic particle emitter emits particles from a box area. The
            initial direction of these particles can either be a single direction (i.e. a line),
            a random scattering inside a cone, or a random scattering in all directions, 
            depending the 'angle' parameter, which is the angle across which to scatter the 
            particles either side of the base direction of the emitter. 
            </remarks>
        </member>
        <member name="T:Engine.Renderer.CylinderEmitter">
            <summary>
            Particle emitter which emits particles randomly from points inside a cylinder.
            </summary>
            <remarks>
            This basic particle emitter emits particles from a cylinder area. The
            initial direction of these particles can either be a single direction
            (i.e. a line), a random scattering inside a cone, or a random
            scattering in all directions, depending the 'angle' parameter, which
            is the angle across which to scatter the particles either side of the
            base direction of the emitter. 
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RingEmitter">
            <summary>
            Particle emitter which emits particles randomly from points inside a ring (e.g. a tube).
            </summary>
            <remarks>
            This particle emitter emits particles from a ring-shaped area.
            The initial direction of these particles can either be a single
            direction (i.e. a line), a random scattering inside a cone, or a random
            scattering in all directions, depending the 'angle' parameter, which
            is the angle across which to scatter the particles either side of the
            base direction of the emitter. 
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RingEmitter.InnerSize">
            <summary>
            Gets or sets the size of the clear space inside the area from where <b>no</b> particles are emitted.
            </summary>
        </member>
        <member name="T:Engine.Renderer.EllipsoidEmitter">
            <summary>
            Particle emitter which emits particles randomly from points inside an ellipsoid.
            </summary>
            <remarks>
            This basic particle emitter emits particles from a ellipsoid area.
            The initial direction of these particles can either be a single
            direction (i.e. a line), a random scattering inside a cone, or a random
            scattering in all directions, depending the 'angle' parameter, which
            is the angle across which to scatter the particles either side of the
            base direction of the emitter. 
            </remarks>
        </member>
        <member name="T:Engine.Renderer.HollowEllipsoidEmitter">
            <summary>
            Particle emitter which emits particles randomly from points inside a hollow ellipsoid.
            </summary>
            <remarks>
            This particle emitter emits particles from a hollow ellipsoid area.
            The initial direction of these particles can either be a single
            direction (i.e. a line), a random scattering inside a cone, or a random
            scattering in all directions, depending the 'angle' parameter, which
            is the angle across which to scatter the particles either side of the
            base direction of the emitter. 
            </remarks>
        </member>
        <member name="P:Engine.Renderer.HollowEllipsoidEmitter.InnerSize">
            <summary>
            Gets or sets the size of the clear space inside the area from where <b>no</b> particles are emitted.
            </summary>
        </member>
        <member name="T:Engine.Renderer.MeshObject">
            <summary>
            Defines an instance of a discrete, movable object based on a Mesh.
            </summary>
            <remarks>
            <para>
            Engine generally divides renderable objects into 2 groups, discrete
            (separate) and relatively small objects which move around the world,
            and large, sprawling geometry which makes up generally immovable
            scenery, aka 'level geometry'.
            </para>
            <para>
            The <see cref="P:Engine.Renderer.MeshObject.Mesh"/> and <see cref="T:Engine.Renderer.SubMesh"/> classes deal with the 
            definition of the geometry
            used by discrete movable objects. Objects are actual instances of
            objects based on this geometry in the world. Therefore there is
            usually a single set <see cref="P:Engine.Renderer.MeshObject.Mesh"/> for a car, but there may be multiple
            objects based on it in the world. Mesh objects are able to override
            aspects of the <see cref="P:Engine.Renderer.MeshObject.Mesh"/> it is defined by, such as changing material
            properties per instance (so you can have many cars using the same
            geometry but different textures for example). Because a Mesh is split
            into SubMeshes for this purpose, the MeshObject class is a grouping class
            (much like the <see cref="P:Engine.Renderer.MeshObject.Mesh"/> class) and much of the detail regarding
            individual changes is kept in the SubObject class. There is a 1:1
            relationship between <see cref="T:Engine.Renderer.MeshObject.SubObject"/> instances and 
            the <see cref="T:Engine.Renderer.SubMesh"/> instances associated with the <see cref="P:Engine.Renderer.MeshObject.Mesh"/> the 
            <see cref="T:Engine.Renderer.MeshObject"/> is based on.
            </para>
            <para>
            Mesh objects are included in the scene by associating them with a
            <see cref="T:Engine.Renderer.SceneNode"/>, using the <see cref="M:Engine.Renderer.SceneNode.Attach(Engine.Renderer.MovableObject)"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MeshObject.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.MeshObject.GetAnimationState(System.String)">
            <summary>Returns animation state by name.</summary>
            <param name="name">The animation state name.</param>
            <returns><see cref="T:Engine.Renderer.MeshObject.AnimationState"/> if such animation state is exists; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.MeshObject.SetMaterialNameForAllSubObjects(System.String)">
            <summary>
            Sets the material to use for the whole of this mesh object.
            </summary>
            <param name="name">The material name.</param>
            <remarks>
            This is a shortcut method to set all the materials for all
            subobjects of this object. Only use this method is you want to
            set the same material for all subobjects or if you know there
            is only one. Otherwise call <see cref="P:Engine.Renderer.MeshObject.SubObjects"/> and call the same
            method on the individual <see cref="T:Engine.Renderer.MeshObject.SubObject"/>.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MeshObject.SetMeshLodBias(System.Single,System.Int32,System.Int32)">
            <summary>
            Sets a level-of-detail bias for the mesh detail of this object.
            </summary>
            <remarks>
            <para>
            Level of detail reduction is normally applied automatically based on the Mesh 
            settings. However, it is possible to influence this behaviour for this object
            by adjusting the LOD bias. This 'nudges' the mesh level of detail used for this 
            object up or down depending on your requirements. You might want to use this
            if there was a particularly important object in your scene which you wanted to
            detail better than the others, such as a player model.
            </para>
            <para>
            There are three parameters to this method; the first is a factor to apply; it 
            defaults to 1.0 (no change), by increasing this to say 2.0, this model would 
            take twice as long to reduce in detail, whilst at 0.5 this object would use lower
            detail versions twice as quickly. The other 2 parameters are hard limits which 
            let you set the maximum and minimum level-of-detail version to use, after all
            other calculations have been made. This lets you say that this object should
            never be simplified, or that it can only use LODs below a certain level even
            when right next to the camera.
            </para>
            </remarks>
            <param name="factor">
            Proportional factor to apply to the distance at which LOD is changed. 
            Higher values increase the distance at which higher LODs are displayed (2.0 is 
            twice the normal distance, 0.5 is half).
            </param>
            <param name="maxDetailIndex">
            The index of the maximum LOD this object is allowed to use (lower
            indexes are higher detail: index 0 is the original full detail model).
            </param>
            <param name="minDetailIndex">
            The index of the minimum LOD this object is allowed to use (higher
            indexes are lower detail). Use something like 99 if you want unlimited LODs (the actual
            LOD will be limited by the number in the Mesh)
            </param>
        </member>
        <member name="M:Engine.Renderer.MeshObject.SetMeshLodBias(System.Single)">
            <summary>
            Sets a level-of-detail bias for the mesh detail of this mesh object.
            </summary>
            <remarks>
            Level of detail reduction is normally applied automatically based on the Mesh 
            settings. However, it is possible to influence this behaviour for this object
            by adjusting the LOD bias. This 'nudges' the mesh level of detail used for this 
            object up or down depending on your requirements. You might want to use this
            if there was a particularly important object in your scene which you wanted to
            detail better than the others, such as a player model.
            </remarks>
            <param name="factor">
            Proportional factor to apply to the distance at which LOD is changed. 
            Higher values increase the distance at which higher LODs are displayed (2.0 is 
            twice the normal distance, 0.5 is half).
            </param>
        </member>
        <member name="M:Engine.Renderer.MeshObject.ShareSkeletonInstanceWith(Engine.Renderer.MeshObject)">
            <summary>
            Shares the SkeletonInstance with the supplied entity.
            Note that in order for this to work, both entities must have the same
            Skeleton.
            </summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.Mesh">
            <summary>Gets the Mesh that this MeshObject is based on.</summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationStates">
            <summary>
            Gets animation states collection.
            </summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.SubObjects">
            <summary>Gets sub objects collection. <b>Don't modify array items</b>.</summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.ManualLodLevels">
            <summary>
            Gets manual lod collection. <b>Don't modify array items</b>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.MeshObject.SubObject">
            <summary>
            Utility class which defines the sub-parts of a MeshObject.
            </summary>
            <remarks>
            <para>
            Just as meshes are split into submeshes, an <see cref="T:Engine.Renderer.MeshObject"/> is made up of
            potentially multiple SubMeshes. These are mainly here to provide the
            link between the <see cref="T:Engine.Renderer.Material"/> which the SubObject uses (which may be the
            default Material for the SubMesh or may have been changed for this
            object) and the <see cref="T:Engine.Renderer.SubMesh"/> data.
            </para>
            <para>
            The SubObject also allows the application some flexibility in the
            material properties for this section of a particular instance of this
            <see cref="P:Engine.Renderer.MeshObject.Mesh"/>, e.g. tinting the windows on a car model.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.MeshObject.SubObject.MaterialName">
            <summary>
            Gets or sets the material name.
            </summary>
        </member>
        <member name="T:Engine.Renderer.MeshObject.AnimationState">
            <summary>
            Represents the state of an animation and the weight of it's influence. 
            </summary>
            <remarks>
            Other classes can hold instances of this class to store the state of any animations
            they are using.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MeshObject.AnimationState.HasEnded">
            <summary>
            Returns true if the animation has reached the end and is not looping.
            </summary>
        </member>
        <member name="M:Engine.Renderer.MeshObject.AnimationState.AddTime(System.Single)">
            <summary>
            Modifies the time position, adjusting for animation length.
            </summary>
            <param name="time">The time in seconds.</param>
            <remarks>
            This method loops at the edges if animation looping is enabled.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MeshObject.AnimationState.ToString">
            <summary>Returns the name of the animation to which this state applies.</summary>
            <returns>The name of the animation to which this state applies.</returns>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationState.Name">
            <summary>Gets the name of the animation to which this state applies.</summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationState.Length">
            <summary>
            Gets the total length of this animation (may be shorter than whole animation).
            </summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationState.Enable">
            <summary>Gets or sets whether this animation is enabled.</summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationState.Loop">
            <summary>Gets or sets whether or not this animation loops.</summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationState.TimePosition">
            <summary>
            Gets or sets the total length of this animation (may be shorter than whole animation).
            </summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.AnimationState.Weight">
            <summary>
            Gets or sets the weight (influence) of this animation.
            </summary>
        </member>
        <member name="P:Engine.Renderer.MeshObject.ManualLodMeshObject.SubObjects">
            <summary>Gets sub objects collection. <b>Don't modify array items</b>.</summary>
        </member>
        <member name="T:Engine.Renderer.GpuProgramManager">
            <summary>
            GPU Program manager class.
            </summary>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.IsSyntaxSupported(System.String)">
            <summary>
            Returns whether a given syntax code (e.g. "ps_1_3", "fp20", "arbvp1") is supported.
            </summary>
            <param name="syntaxCode">The syntax code.</param>
            <returns><b>true</b> if such syntax supported; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.IsOneOfSyntaxesSupported(System.String)">
            <summary>
            Returns whether a given one of the syntax list (e.g. "ps_2_0 arbvp1") is supported.
            </summary>
            <param name="syntaxCodes">The syntax codes.</param>
            <returns><b>true</b> if one syntax supported; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.CreateHighLevelProgram(System.String,System.String,Engine.Renderer.GpuProgramType)">
            <summary>
            Creates a new, unloaded high level gpu program.
            </summary>
            <remarks>
            This method creates a new program of the type specified as the 
            second and third parameters. You will have to call further methods 
            on the returned program in order to define the program fully before you 
            can load it.
            </remarks>
            <param name="name">
            The identifying name to give this program, which can be used to
            retrieve this program later with <see cref="M:Engine.Renderer.GpuProgramManager.GetByName(System.String)"/>.
            </param>
            <param name="language">Language code of the language to use (e.g. "cg").</param>
            <param name="programType">The type of prgram to create.</param>
            <returns><see cref="T:Engine.Renderer.GpuProgram"/> if such program created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.GetByName(System.String)">
            <summary>
            Returns gpu program by name.
            </summary>
            <param name="name">The program name.</param>
            <returns><see cref="T:Engine.Renderer.GpuProgram"/> if such program exists; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.GetUniqueName(System.String)">
            <summary>
            Returns the generated the unique gpu program name with prefix.
            </summary>
            <param name="prefix">The name prefix.</param>
            <returns>The generated unique the gpu program name with prefix.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.UnloadProgram(System.String)">
            <summary>Unloads program.</summary>
            <param name="name">The program name.</param>
        </member>
        <member name="M:Engine.Renderer.GpuProgramManager.ReadProgramNamesFromFile(System.String)">
            <summary>
            Returns the program names from file.
            </summary>
            <param name="fileName">The gpu program or material file name.</param>
            <returns>The program names.</returns>
        </member>
        <member name="P:Engine.Renderer.GpuProgramManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.GpuProgramManager"/>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgramManager.SupportedSyntaxes">
            <summary>
            Returns the syntaxes that this manager supports.
            </summary>
            <returns>The syntaxes that this manager supports.</returns>
        </member>
        <member name="M:Engine.Renderer.Pose.AddVertex(System.Int32,Engine.MathEx.Vec3)">
            <summary>
            Adds an offset to a vertex for this pose. 
            <param name="index">The vertex index</param>
            <param name="offset">The position offset for this pose</param>
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pose.GetVertexOffsetIndices">
            <summary>
            Gets the list of vertex indices for this pose.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Pose.GetVertexOffset(System.Int32)">
            <summary>
            Gets the vertex offset for vertex with current index.
            <param name="index">The offset index.</param>
            </summary>
        </member>
        <member name="P:Engine.Renderer.Pose.Name">
            <summary>
            Gets the name of this pose.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Viewport">
            <summary>
            Viewport class, i.e. a rendering region on a render target.
            </summary>
            <remarks>
            A viewport is the meeting of a camera and a rendering surface -
            the camera renders the scene from a viewpoint, and places its
            results into some subset of a rendering target, which may be the
            whole surface or just a part of the surface. Each viewport has a
            single camera as source and a single target as destination. A
            camera only has 1 viewport, but a render target may have several.
            A viewport also has a Z-order, i.e. if there is more than one
            viewport on a single render target and they overlap, one must
            obscure the other in some predetermined way.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Viewport.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Viewport.SetClearEveryFrame(System.Boolean,Engine.Renderer.FrameBufferType)">
            <summary>
            Determines whether to clear the viewport before rendering.
            </summary>
            <param name="clear">Whether or not to clear any buffers.</param>
            <param name="buffers">
            One or more values from <see cref="T:Engine.Renderer.FrameBufferType"/> denoting
            which buffers to clear, if clear is set to true. Note you should
            not clear the stencil buffer here unless you know what you're doing.
            </param>
            <remarks>
            You can use this method to set which buffers are cleared
            (if any) before rendering every frame.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Viewport.SetClearEveryFrame(System.Boolean)">
            <summary>
            Determines whether to clear the viewport before rendering.
            </summary>
            <param name="clear">Whether or not to clear any buffers.</param>
            <remarks>
            You can use this method to set which buffers are cleared
            (if any) before rendering every frame.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Viewport.GetClearEveryFrame">
            <summary>
            Determines if the viewport is cleared before every frame.
            </summary>
            <returns><b>true</b> if the viewport is cleared before every frame; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.Viewport.AddCompositor(System.String,System.Int32)">
            <summary>
            Add a compositor to a viewport. By default, it is added to end of the chain,
            after the other compositors.
            </summary>
            <param name="name">The name of the compositor to apply.</param>
            <param name="addPosition">At which position to add, defaults to the end (-1).</param>
            <returns>The compositor instance.</returns>
        </member>
        <member name="M:Engine.Renderer.Viewport.AddCompositor(System.String)">
            <summary>
            Add a compositor to a viewport. By default, it is added to end of the chain,
            after the other compositors.
            </summary>
            <param name="name">The name of the compositor to apply.</param>
            <returns>The compositor instance.</returns>
        </member>
        <member name="M:Engine.Renderer.Viewport.RemoveCompositor(System.String)">
            <summary>
            Removes a compositor from a viewport
            </summary>
            <param name="name">The name of the compositor.</param>
        </member>
        <member name="M:Engine.Renderer.Viewport.GetCompositorInstance(System.String)">
            <summary>
            Gets the compositor instance by name.
            </summary>
            <param name="compositorName">The compositor name.</param>
            <returns>The compositor instance if the item exists; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.Viewport.SetCompositorEnabled(System.String,System.Boolean)">
            <summary>
            Sets the enabled flag of the compositor.
            </summary>
            <param name="name">The compositor name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Engine.Renderer.Viewport.RemoveAllCompositors">
            <summary>
            Removes all compositors.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.BackgroundColor">
            <summary>
            Gets or sets the initial background colour of the viewport (before rendering).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.Dimensions">
            <summary>
            Gets or sets the dimensions (after creation).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.DimensionsInPixels">
            <summary>
            Gets the dimensions of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.ViewportCamera">
            <summary>
            Gets or sets camera for this viewport.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.CompositorInstances">
            <summary>
            Gets the compositor instances collection.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.RenderQueueInvocationSequenceName">
            <summary>
            Gets or sets Sets the use of a custom <see cref="T:Engine.Renderer.RenderQueueInvocationSequence"/> for
            rendering this target.
            </summary>
            <remarks>
            <see cref="T:Engine.Renderer.RenderQueueInvocationSequence"/> instances are managed through Root. By
            setting this, you are indicating that you wish this <see cref="T:Engine.Renderer.RenderTarget"/> to
            be updated using a custom sequence of render queue invocations, with
            potentially customised ordering and render state options. You should
            create the named sequence through Root first, then set the name here.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Viewport.ParentRenderTarget">
            <summary>
            Gets the parent render target.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Viewport.ShadowsEnabled">
            <summary>
            Gets or sets this viewport whether it should display shadows.
            </summary>
            <remarks>
            This setting enables you to disable shadow rendering for a given viewport. The global
            shadow technique set on SceneManager still controls the type and nature of shadows,
            but this flag can override the setting so that no shadows are rendered for a given
            viewport to save processing time where they are not required.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Viewport.MaterialScheme">
            <summary>
            Gets or sets the material scheme which the viewport should use.
            </summary>
            <remarks>
            This allows you to tell the system to use a particular
            material scheme when rendering this viewport, which can 
            involve using different techniques to render your materials.
            </remarks>
            <see cref="P:Engine.Renderer.Technique.SchemeName"/>
        </member>
        <member name="M:Engine.Renderer.HighLevelMaterialManager.Clone(Engine.Renderer.HighLevelMaterial,System.String)">
            <summary>
            Creates a new copy of material with the same settings but a new name.
            </summary>
            <param name="sourceMaterial">The source material.</param>
            <param name="newName">The name for the cloned material.</param>
        </member>
        <member name="T:Engine.Renderer.RenderFrustum">
            <summary>
            A frustum represents a pyramid, capped at the near and far end which is
            used to represent either a visible area or a projection area. Can be used
            for a number of applications.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetFrustumPlane(System.Int32)">
            <summary>
            Retrieves a specified plane of the frustum.
            </summary>
            <param name="index">The plane index.</param>
            <returns>The plane.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.IsIntersectsFast(Engine.MathEx.Bounds)">
            <summary>
            Tests whether the given bounds is visible in the Frustum.
            </summary>
            <remarks>
            Not cull everything outside the frustum.
            </remarks>
            <param name="bounds">The bounds.</param>
            <returns><b>true</b> if the bounds is visibled; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.IsIntersectsFast(Engine.MathEx.Vec3)">
            <summary>
            Tests whether the given point is visible in the Frustum.
            </summary>
            <remarks>
            Not cull everything outside the frustum.
            </remarks>
            <param name="position">The point.</param>
            <returns><b>true</b> if the point is visibled; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.EnableReflection(Engine.MathEx.Plane)">
            <summary>
            Modifies this frustum so it always renders from the reflection of itself through the
            plane specified.
            </summary>
            <param name="plane">The plane.</param>
            <remarks>
            This is obviously useful for performing planar reflections. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.DisableReflection">
            <summary>
            Disables reflection modification previously turned on with <see cref="M:Engine.Renderer.RenderFrustum.EnableReflection(Engine.MathEx.Plane)"/>.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.IsReflected">
            <summary>Returns whether this frustum is being reflected.</summary>
            <returns><b>true</b> if the reflection is enabled; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetReflectionMatrix">
            <summary>Returns the reflection matrix of the frustum if appropriate.</summary>
            <returns>The reflection matrix.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetReflectionPlane">
            <summary>Returns the reflection plane of the frustum if appropriate.</summary>
            <returns>The reflection plane.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.EnableCustomNearClipPlane(Engine.MathEx.Plane)">
            <summary>
            Links the frustum to a custom near clip plane, which can be used
            to clip geometry in a custom manner without using user clip planes.
            </summary>
            <param name="plane">
            The plane to link to to perform the clipping. This plane
            must continue to exist while the camera is linked to it; do not
            destroy it before the frustum.
            </param>
            <remarks>
            <para>
            There are several applications for clipping a scene arbitrarily by
            a single plane; the most common is when rendering a reflection to 
            a texture, and you only want to render geometry that is above the 
            water plane (to do otherwise results in artefacts). Whilst it is
            possible to use user clip planes, they are not supported on all
            cards, and sometimes are not hardware accelerated when they are
            available. Instead, where a single clip plane is involved, this
            technique uses a 'fudging' of the near clip plane, which is 
            available and fast on all hardware, to perform as the arbitrary
            clip plane. This does change the shape of the frustum, leading 
            to some depth buffer loss of precision, but for many of the uses of
            this technique that is not an issue.
            </para>
            <para>
            This version of the method links to a plane, rather than requiring
            a by-value plane definition, and therefore you can 
            make changes to the plane (e.g. by moving / rotating the node it is
            attached to) and they will automatically affect this object.
            </para>
            <para>
            This technique only works for perspective projection.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.DisableCustomNearClipPlane">
            <summary>
            Disables any custom near clip plane.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetWorldSpaceCorners">
            <summary>
            Gets the world space corners of the frustum.
            </summary>
            <returns>The world space corners of the frustum.</returns>
            <remarks>
            The corners are ordered as follows: top-right near, 
            top-left near, bottom-left near, bottom-right near, 
            top-right far, top-left far, bottom-left far, bottom-right far.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetProjectionMatrixRS">
            <summary>
            Gets the projection matrix for this frustum adjusted for the current
            rendersystem specifics (may be right or left-handed, depth range
            may vary).
            </summary>
            <remarks>
            This method retrieves the rendering-API dependent version of the projection
            matrix. If you want a 'typical' projection matrix then use 
            <see cref="M:Engine.Renderer.RenderFrustum.GetProjectionMatrix"/>.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetProjectionMatrixWithRSDepth">
            <summary>
            Gets the depth-adjusted projection matrix for the current rendersystem,
            but one which still conforms to right-hand rules.
            </summary>
            <remarks>
            This differs from the rendering-API dependent <see cref="M:Engine.Renderer.RenderFrustum.GetProjectionMatrix"/>
            in that it always returns a right-handed projection matrix result 
            no matter what rendering API is being used - this is required for
            vertex and fragment programs for example. However, the resulting depth
            range may still vary between render systems since D3D uses [0,1] and 
            GL uses [-1,1], and the range must be kept the same between programmable
            and fixed-function pipelines.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetProjectionMatrix">
            <summary>
            Gets the normal projection matrix for this frustum, ie the 
            projection matrix which conforms to standard right-handed rules and 
            uses depth range [-1,+1].
            </summary>
            <remarks>
            This differs from the rendering-API dependent <see cref="M:Engine.Renderer.RenderFrustum.GetProjectionMatrixRS"/>
            in that it always returns a right-handed projection matrix with depth
            range [-1,+1], result no matter what rendering API is being used - this
            is required for some uniform algebra for example.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Engine.Renderer.RenderFrustum.GetViewMatrix">
            <summary>
            Gets the view matrix for this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Engine.Renderer.RenderFrustum.Fov">
            <summary>
            Gets or sets the Field Of View (FOV) of the frustum.
            </summary>
            <remarks>
            <para>
            Field Of View (FOV) is the angle made between the frustum's position, and the edges
            of the 'screen' onto which the scene is projected. High values (90+ degrees) result in a wide-angle,
            fish-eye kind of view, low values (30- degrees) in a stretched, telescopic kind of view. Typical values
            are between 45 and 60 degrees.
            </para>
            <para>
            This value represents the vertical field-of-view. The horizontal field of view is calculated from
            this depending on the dimensions of the viewport (they will only be the same if the viewport is square).
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderFrustum.NearClipDistance">
            <summary>
            Gets or sets the position of the near clipping plane.
            </summary>
            <remarks>
            The position of the near clipping plane is the distance from the frustums position to the screen
            on which the world is projected. The near plane distance, combined with the field-of-view and the
            aspect ratio, determines the size of the viewport through which the world is viewed (in world
            co-ordinates). Note that this world viewport is different to a screen viewport, which has it's
            dimensions expressed in pixels. The frustums viewport should have the same aspect ratio as the
            screen viewport it renders into to avoid distortion.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderFrustum.FarClipDistance">
            <summary>
            Gets or sets the distance to the far clipping plane.
            </summary>
            <remarks>
            <para>
            The view frustrum is a pyramid created from the frustum 
            position and the edges of the viewport.
            This method sets the distance for the far end of that pyramid. 
            Different applications need different values: e.g. a flight sim
            needs a much further far clipping plane than a first-person 
            shooter. An important point here is that the larger the ratio 
            between near and far clipping planes, the lower the accuracy of
            the Z-buffer used to depth-cue pixels. This is because the
            Z-range is limited to the size of the Z buffer (16 or 32-bit) 
            and the max values must be spread over the gap between near and
            far clip planes. As it happens, you can affect the accuracy far 
            more by altering the near distance rather than the far distance, 
            but keep this in mind.
            </para>
            <para>
            far The distance to the far clipping plane from the frustum in 
            world coordinates.If you specify 0, this means an infinite view
            distance which is useful especially when projecting shadows; but
            be careful not to use a near distance too close.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderFrustum.AspectRatio">
            <summary>
            Gets or sets the aspect ratio for the frustum viewport.
            </summary>
            <remarks>
            <para>
            The ratio between the x and y dimensions of the rectangular area visible through the frustum
            is known as aspect ratio: aspect = width / height .
            </para>
            <para>
            The default for most fullscreen windows is 1.3333 - this is also assumed by Ogre unless you
            use this method to state otherwise.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderFrustum.ProjectionType">
            <summary>
            Gets or sets the type of projection to use (orthographic or perspective).
            Default is perspective.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Material">
            <summary>
            Class encapsulates rendering properties of an object.
            </summary>
            <remarks>
            <para>
            Engine's material class encapsulates ALL aspects of the visual appearance,
            of an object. It also includes other flags which 
            might not be traditionally thought of as material properties such as 
            culling modes and depth buffer settings, but these affect the 
            appearance of the rendered object and are convenient to attach to the 
            material since it keeps all the settings in one place. This is 
            different to Direct3D which treats a material as just the colour 
            components (diffuse, specular) and not texture maps etc. An Engine 
            Material can be thought of as equivalent to a 'Shader'.
            </para>
            <para>
            A Material can be rendered in multiple different ways depending on the
            hardware available. You may configure a Material to use high-complexity
            fragment shaders, but these won't work on every card; therefore a Technique
            is an approach to creating the visual effect you are looking for. You are advised
            to create fallback techniques with lower hardware requirements if you decide to
            use advanced features. In addition, you also might want lower-detail techniques
            for distant geometry.
            </para>
            <para>
            Each technique can be made up of multiple passes. A fixed-function pass
            may combine multiple texture layers using multitexrtuing, but Engine can 
            break that into multiple passes automatically if the active card cannot
            handle that many simultaneous textures. Programmable passes, however, cannot
            be split down automatically, so if the active graphics card cannot handle the
            technique which contains these passes, Engine will try to find another technique
            which the card can do. If, at the end of the day, the card cannot handle any of the
            techniques which are listed for the material, the engine will render the 
            geometry plain white, which should alert you to the problem.
            </para>
            <para>
            Engine comes configured with a number of default settings for a newly 
            created material. These can be changed if you wish by retrieving the 
            default material settings through 
            SceneManager.GetDefaultMaterialSettings. Any changes you make to the 
            Material returned from this method will apply to any materials created 
            from this point onward.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Material.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Material.CreateTechnique">
            <summary>
            Creates a new Technique for this Material.
            </summary>
            <remarks>
            <para>
            A Technique is a single way of rendering geometry in order to achieve the effect
            you are intending in a material. There are many reason why you would want more than
            one - the main one being to handle variable graphics card abilities; you might have
            one technique which is impressive but only runs on 4th-generation graphics cards, 
            for example. In this case you will want to create at least one fallback Technique.
            Engine will work out which Techniques a card can support and pick the best one.
            </para>
            <para>
            If multiple Techniques are available, the order in which they are created is 
            important - the engine will consider lower-indexed Techniques to be preferable
            to higher-indexed Techniques, ie when asked for the 'best' technique it will
            return the first one in the technique list which is supported by the hardware.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Material.RemoveTechnique(System.Int32)">
            <summary>Removes the technique at the given index.</summary>
        </member>
        <member name="M:Engine.Renderer.Material.RemoveAllTechniques">
            <summary>Removes all the techniques in this Material.</summary>
        </member>
        <member name="M:Engine.Renderer.Material.Load">
            <summary>
            Loads the material if it not loaded.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Material.GetBestTechnique">
            <summary>
            Gets the best supported technique.
            </summary>
            <returns>The best supported technique.</returns>
            <remarks>
            This method returns the lowest-index supported Technique in this material
            (since lower-indexed Techniques are considered to be better than higher-indexed ones).
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Material.Touch">
            <summary>
            'Touches' the resource to indicate it has been used.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Material.IsTransparent">
            <summary>
            Determines if the material has any transparency with the rest of the scene 
            (derived from whether any Techniques say they involve transparency).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Material.Name">
            <summary>
            Gets the material name.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Material.FileName">
            <summary>
            Gets the material file name.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Material.Techniques">
            <summary>Gets the techniques collection. <b>Don't modify array items.</b></summary>
        </member>
        <member name="P:Engine.Renderer.Material.ReceiveShadows">
            <summary>
            Gets or sets whether objects using this material will receive shadows.
            </summary>
            <remarks>
            <para>
            This method allows a material to opt out of receiving shadows, if
            it would otherwise do so. Shadows will not be cast on any objects
            unless the scene is set up to support shadows, and not all 
            techniques cast shadows on all objects. In any case, 
            if you have a need to prevent shadows being received by material, 
            this is the method you call to do it.
            </para>
            <para>
            Transparent materials never receive shadows despite this setting. 
            The default is to receive shadows.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Material.ShadowTextureCasterMaterial">
            <summary>
            Gets or sets the material to use for rendering shadow casters.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Bone">
            <summary>
            A bone in a skeleton.
            </summary>
            <remarks>
            See Skeleton for more information about the principles behind skeletal animation.
            This class is a node in the joint hierarchy. Mesh vertices also have assignments
            to bones to define how they move in relation to the skeleton.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Bone.GetDerivedPosition">
            <summary>
            Gets the position of the bone as derived from all parents.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Bone.GetDerivedRotation">
            <summary>
            Gets the rotation of the bone as derived from all parents.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Bone.GetDerivedScale">
            <summary>
            Gets the scaling factor of the bone as derived from all parents.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Name">
            <summary>
            Gets the name of the bone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Handle">
            <summary>
            Gets the numeric handle for this bone (unique within the skeleton).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Position">
            <summary>
            Gets or sets the position of a bone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Rotation">
            <summary>
            Gets or sets the rotation of a bone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Scale">
            <summary>
            Gets or sets the scaling of a bone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.ManuallyControlled">
            <summary>
            Gets or sets whether or not this bone is manually controlled. 
            </summary>
            <remarks>
            Manually controlled bones can be altered by the application at runtime, 
            and their positions will not be reset by the animation routines.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Bone.Children">
            <summary>
            Gets a child bones collection. <b>Don't modify.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Parent">
            <summary>
            Gets the parent bone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Bone.Owner">
            <summary>
            Gets the owner skeleton.
            </summary>
        </member>
        <member name="F:Engine.Renderer.SkeletonAnimationBlendMode.Average">
            <summary>
            Animations are applied by calculating a weighted average of all animations.
            </summary>
        </member>
        <member name="F:Engine.Renderer.SkeletonAnimationBlendMode.Cumulative">
            <summary>
            Animations are applied by calculating a weighted cumulative total.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Skeleton">
            <summary>
            A collection of Bone objects used to animate a skinned mesh.
            </summary>
            <remarks>
            <para>
            Skeletal animation works by having a collection of 'bones' which are 
            actually just joints with a position and orientation, arranged in a tree structure.
            For example, the wrist joint is a child of the elbow joint, which in turn is a
            child of the shoulder joint. Rotating the shoulder automatically moves the elbow
            and wrist as well due to this hierarchy.
            </para>
            <para>
            So how does this animate a mesh? Well every vertex in a mesh is assigned to one or more
            bones which affects it's position when the bone is moved. If a vertex is assigned to 
            more than one bone, then weights must be assigned to determine how much each bone affects
            the vertex (actually a weight of 1.0 is used for single bone assignments). 
            Weighted vertex assignments are especially useful around the joints themselves
            to avoid 'pinching' of the mesh in this region. 
            </para>
            <para>
            Therefore by moving the skeleton using preset animations, we can animate the mesh. The
            advantage of using skeletal animation is that you store less animation data, especially
            as vertex counts increase. In addition, you are able to blend multiple animations together
            (e.g. walking and looking around, running and shooting) and provide smooth transitions
            between animations without incurring as much of an overhead as would be involved if you
            did this on the core vertex data.
            </para>
            <para>
            Skeleton definitions are loaded from datafiles, namely the .skeleton file format. They
            are loaded on demand, especially when referenced by a Mesh.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Skeleton.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Skeleton.GetBone(System.String)">
            <summary>
            Gets a bone by it's name.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Skeleton.CreateBone(Engine.Renderer.Bone,System.String)">
            <summary>
            Creates a brand new Bone owned by this Skeleton. 
            </summary>
            <param name="parent">
            The parent bone or <b>null</b>.
            </param>
            <param name="name">
            The name to give to this new bone - must be unique within this skeleton.
            </param>
            <returns></returns>
        </member>
        <member name="M:Engine.Renderer.Skeleton.SetBindingPose">
            <summary>
            Sets the current position / orientation to be the 'binding pose' ie the layout in which 
            bones were originally bound to a mesh.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Skeleton.Reset(System.Boolean)">
            <summary>
            Resets the position and orientation of all bones in this skeleton to their original 
            binding position.
            </summary>
            <param name="resetManualBones">
            If set to true, causes the state of manual bones to be reset
            too, which is normally not done to allow the manual state to persist even 
            when keyframe animation is applied.
            </param>
            <remarks>
            A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this
            position during animation. This method returns all the bones to their original position and
            orientation.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Skeleton.GetAnimation(System.String)">
            <summary>
            Returns the named <see cref="T:Engine.Renderer.Animation"/> object.
            </summary>
            <param name="name">The name of the animation.</param>
        </member>
        <member name="M:Engine.Renderer.Skeleton.CreateAnimation(System.String,System.Single)">
            <summary>
            Creates a new <see cref="T:Engine.Renderer.Animation"/> object for animating this skeleton.
            </summary>
            <param name="name">The name of this animation.</param>
            <param name="length">The length of the animation in seconds.</param>
        </member>
        <member name="M:Engine.Renderer.Skeleton.RemoveAnimation(System.String)">
            <summary>
            Removes an Animation from this skeleton.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Skeleton.Bones">
            <summary>
            Gets a bones collection. <b>Don't modify.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.Skeleton.RootBones">
            <summary>
            Gets a roots bones collection. <b>Don't modify.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.Skeleton.Animations">
            <summary>
            Gets the animation list.
            </summary>
        </member>
        <member name="T:Engine.Renderer.SkeletonInstance">
            <summary>
            A SkeletonInstance is a single instance of a Skeleton used by a world object.
            </summary>
            <remarks>
            The difference between a Skeleton and a SkeletonInstance is that the
            Skeleton is the 'master' version much like Mesh is a 'master' version of
            Entity. Many SkeletonInstance objects can be based on a single Skeleton, 
            and are copies of it when created. Any changes made to this are not
            reflected in the master copy. The exception is animations; these are
            shared on the Skeleton itself and may not be modified here.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RenderQueueInvocation">
            <summary>
            Class representing the invocation of queue groups in a render queue.
            </summary>
            <remarks>
            <para>
            The default behaviour for Engine's render queue is to render each queue
            group in turn, dealing with shadows automatically, and rendering solids
            in grouped passes, followed by transparent objects in descending order.
            This class, together with RenderQueueInvocationSequence and the ability
            to associate one with a <see cref="T:Engine.Renderer.Viewport"/>, allows you to change that behaviour
            and render queue groups in arbitrary sequence, repeatedly, and to skip
            shadows, change the ordering of solids, or even prevent Engine controlling
            the render state during a particular invocation for special effects.
            </para>
            <para>
            Note that whilst you can change the ordering of rendering solids, you 
            can't change the ordering on transparent objects, since to do this would
            cause them to render incorrectly.
            </para>
            <para>
            As well as using this class directly and using the options it provides you
            with, you can also provide subclasses of it to a 
            <see cref="T:Engine.Renderer.RenderQueueInvocationSequence"/> instance if you want to gain ultimate control.
            </para>
            <para>
            Invocations will be skipped if there are scene-level options preventing
            them being rendered - for example special-case render queues and
            render queue listeners that dictate this.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderQueueInvocation.SuppressShadows">
            <summary>
            Gets or sets whether shadows are suppressed when invoking this queue. 
            </summary>
            <remarks>
            When doing effects you often will want to suppress shadow processing
            if shadows will already have been done by a previous render.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RenderQueueInvocationSequence">
            <summary>
            Class to hold a linear sequence of <see cref="T:Engine.Renderer.RenderQueueInvocation"/> objects. 
            </summary>
            <remarks>
            This is just a simple data holder class which contains a list of 
            <see cref="T:Engine.Renderer.RenderQueueInvocation"/> objects representing the sequence of invocations
            made for a viewport. It's only real purpose is to ensure that 
            <see cref="T:Engine.Renderer.RenderQueueInvocation"/> instances are deleted on shudown, since you can
            provide your own subclass instances on <see cref="T:Engine.Renderer.RenderQueueInvocation"/>. Remember
            that any invocation instances you give to this class will be deleted
            by it when it is cleared / destroyed.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderQueueInvocationSequence.Add(Engine.Renderer.RenderQueueGroupID,System.String)">
            <summary>
            Add a standard invocation to the sequence.
            </summary>
            <param name="renderQueueGroupID">The ID of the render queue group.</param>
            <param name="invocationName">
            Optional name to identify the invocation, useful
            for listeners if a single queue group is invoked more than once.
            </param>
            <returns>A new RenderQueueInvocatin instance which you may customise.</returns>
        </member>
        <member name="T:Engine.Renderer.PolygonMode">
            <summary>The polygon mode to use when rasterising.</summary>
        </member>
        <member name="F:Engine.Renderer.PolygonMode.Points">
            <summary>Only points are rendered.</summary>
        </member>
        <member name="F:Engine.Renderer.PolygonMode.Wireframe">
            <summary>Wireframe models are rendered.</summary>
        </member>
        <member name="F:Engine.Renderer.PolygonMode.Solid">
            <summary>Solid polygons are rendered.</summary>
        </member>
        <member name="T:Engine.Renderer.FogMode">
            <summary>Fog mode.</summary>
        </member>
        <member name="F:Engine.Renderer.FogMode.None">
            <summary>No fog.</summary>
        </member>
        <member name="F:Engine.Renderer.FogMode.Exp">
            <summary>Fog density increases  exponentially from the camera (fog = 1/e^(distance * density)).</summary>
        </member>
        <member name="F:Engine.Renderer.FogMode.Exp2">
            <summary>Fog density increases at the square of <b>Exp</b>, i.e. even quicker (fog = 1/e^(distance * density)^2).</summary>
        </member>
        <member name="F:Engine.Renderer.FogMode.Linear">
            <summary>Fog density increases linearly between the start and end distances.</summary>
        </member>
        <member name="T:Engine.Renderer.TextureFilterOptions">
            <summary>
            High-level filtering options providing shortcuts to settings the
            minification, magnification and mip filters.
            </summary>
        </member>
        <member name="F:Engine.Renderer.TextureFilterOptions.None">
            <summary>
            Equal to: min=<b>FilterOptions.Point</b>, 
            mag=<b>FilterOptions.Point</b>, mip=<b>FilterOptions.None</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.TextureFilterOptions.Bilinear">
            <summary>
            Equal to: min=<b>FilterOptions.Linear</b>,
            mag=<b>FilterOptions.Linear</b>, mip=<b>FilterOptions.Point</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.TextureFilterOptions.Trilinear">
            <summary>
            Equal to: min=<b>FilterOptions.Linear</b>, 
            mag=<b>FilterOptions.Linear</b>, mip=<b>FilterOptions.Linear</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.TextureFilterOptions.Anisotropic">
            <summary>
            Equal to: min=<b>FilterOptions.Anisotropic</b>, max=<b>FilterOptions.Anisotropic</b>, 
            mip=<b>FilterOptions.Linear</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.FilterType.Min">
            <summary>The filter used when shrinking a texture.</summary>
        </member>
        <member name="F:Engine.Renderer.FilterType.Mag">
            <summary>The filter used when magnifiying a texture.</summary>
        </member>
        <member name="F:Engine.Renderer.FilterType.Mip">
            <summary>The filter used when determining the mipmap.</summary>
        </member>
        <member name="T:Engine.Renderer.FilterOptions">
            <summary>Filtering options for textures / mipmaps.</summary>
        </member>
        <member name="F:Engine.Renderer.FilterOptions.None">
            <summary>No filtering, used for <b>FilterType.Mip</b> to turn off mipmapping.</summary>
        </member>
        <member name="F:Engine.Renderer.FilterOptions.Point">
            <summary>Use the closest pixel.</summary>
        </member>
        <member name="F:Engine.Renderer.FilterOptions.Linear">
            <summary>Average of a 2x2 pixel area, denotes bilinear for <b>FilterType.Min</b> and <b>FilterType.Mag</b>, trilinear for <b>FilterType.Mip</b>.</summary>
        </member>
        <member name="F:Engine.Renderer.FilterOptions.Anisotropic">
            <summary>Similar to FO_LINEAR, but compensates for the angle of the texture plane.</summary>
        </member>
        <member name="T:Engine.Renderer.FrameBufferType">
            <summary>Defines the frame buffer types.</summary>
        </member>
        <member name="F:Engine.Renderer.FrameBufferType.Color">
            <summary>The color buffer.</summary>
        </member>
        <member name="F:Engine.Renderer.FrameBufferType.Depth">
            <summary>The depth buffer.</summary>
        </member>
        <member name="F:Engine.Renderer.FrameBufferType.Stencil">
            <summary>The stencil buffer.</summary>
        </member>
        <member name="T:Engine.Renderer.LayerBlendOperation">
            <summary>
            List of valid texture blending operations, for use with 
            <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperation.Replace">
            <summary>Replace all color with texture with no adjustment.</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperation.Add">
            <summary>Add color components together.</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperation.Modulate">
            <summary>Multiply color components together.</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperation.AlphaBlend">
            <summary>Blend based on texture alpha.</summary>
        </member>
        <member name="T:Engine.Renderer.LayerBlendOperationEx">
            <summary>
            Expert list of valid texture blending operations, for use with 
            <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperationEx(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,Engine.MathEx.ColorValue,Engine.MathEx.ColorValue,System.Single)"/> and 
            <see cref="M:Engine.Renderer.TextureUnitState.SetAlphaOperation(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,System.Single,System.Single,System.Single)"/>. It's worth
            noting that these operations are for blending <i>between texture layers</i> and 
            not between rendered objects and the existing scene. Because all of these modes 
            are only supported in multitexture hardware it may be required to set up a fallback 
            operation where this hardware is not available.
            </summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.Source1">
            <summary>use source1 without modification</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.Source2">
            <summary>use source2 without modification</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.Modulate">
            <summary>multiply source1 and source2 together</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.ModulateX2">
            <summary>as LBX_MODULATE but brighten afterwards (x2)</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.ModulateX4">
            <summary>as LBX_MODULATE but brighten more afterwards (x4)</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.Add">
            <summary>add source1 and source2 together</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.AddSigned">
            <summary>as LBX_ADD, but subtract 0.5 from the result</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.AddSmooth">
            <summary>as LBX_ADD, but subtract product from the sum</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.Subtract">
            <summary>subtract source2 from source1</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.BlendDiffuseAlpha">
            <summary>
            use interpolated alpha value from vertices to scale source1, 
            then add source2 scaled by (1-alpha)
            </summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.BlendTextureAlpha">
            <summary>as LBX_BLEND_DIFFUSE_ALPHA, but use alpha from texture</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.BlendCurrentAlpha">
            <summary>as LBX_BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.BlendManual">
            <summary>
            as LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0)
            </summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.DotProduct">
            <summary>dotproduct of color1 and color2</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendOperationEx.BlendDiffuseColor">
            <summary>
            use interpolated color values from vertices to scale source1, 
            then add source2 scaled by (1-color)
            </summary>
        </member>
        <member name="T:Engine.Renderer.LayerBlendSource">
            <summary>
            List of valid sources of values for blending operations used
            in <see cref="M:Engine.Renderer.TextureUnitState.SetColorOperation(Engine.Renderer.LayerBlendOperation)"/> and 
            <see cref="M:Engine.Renderer.TextureUnitState.SetAlphaOperation(Engine.Renderer.LayerBlendOperationEx,Engine.Renderer.LayerBlendSource,Engine.Renderer.LayerBlendSource,System.Single,System.Single,System.Single)"/>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendSource.Current">
            <summary>the colour as built up from previous stages</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendSource.Texture">
            <summary>the colour derived from the texture assigned to this layer</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendSource.Diffuse">
            <summary>the interpolated diffuse colour from the vertices</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendSource.Specular">
            <summary>the interpolated specular colour from the vertices</summary>
        </member>
        <member name="F:Engine.Renderer.LayerBlendSource.Manual">
            <summary>a colour supplied manually as a separate argument</summary>
        </member>
        <member name="T:Engine.Renderer.RenderOperationType">
            <summary>
            The rendering operation type to perform.
            </summary>
        </member>
        <member name="F:Engine.Renderer.RenderOperationType.PointList">
            <summary>A list of points, 1 vertex per point.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderOperationType.LineList">
            <summary>A list of lines, 2 vertices per line.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderOperationType.LineStrip">
            <summary>A strip of connected lines, 1 vertex per line plus 1 start vertex.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderOperationType.TriangleList">
            <summary>A list of triangles, 3 vertices per triangle.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderOperationType.TriangleStrip">
            <summary>A strip of triangles, 3 vertices for the first triangle, and 1 per triangle after that.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderOperationType.TriangleFan">
            <summary>A fan of triangles, 3 vertices for the first triangle, and 1 per triangle after that.</summary>
        </member>
        <member name="T:Engine.Renderer.SceneBlendFactor">
            <summary>
            Blending factors for manually blending objects with the scene. If there isn't a predefined
            SceneBlendType that you like, then you can specify the blending factors directly to affect the
            combination of object and the existing scene.
            </summary>
        </member>
        <member name="T:Engine.Renderer.CullingMode">
            <summary>
            Hardware culling modes based on vertex winding.
            This setting applies to how the hardware API culls triangles it is sent.
            </summary>
        </member>
        <member name="F:Engine.Renderer.CullingMode.None">
            <summary>
            Hardware never culls triangles and renders everything it receives.
            </summary>
        </member>
        <member name="F:Engine.Renderer.CullingMode.Clockwise">
            <summary>
            Hardware culls triangles whose vertices are listed clockwise in the view (default).
            </summary>
        </member>
        <member name="F:Engine.Renderer.CullingMode.Anticlockwise">
            <summary>
            Hardware culls triangles whose vertices are listed anticlockwise in the view.
            </summary>
        </member>
        <member name="T:Engine.Renderer.CompareFunction">
            <summary>
            Comparison functions used for the depth/stencil buffer operations and others.
            </summary>
        </member>
        <member name="T:Engine.Renderer.GpuProgramType">
            <summary>
            Enumerates the types of programs which can run on the GPU.
            </summary>
        </member>
        <member name="T:Engine.Renderer.IlluminationStage">
            <summary>
            Categorisation of passes for the purpose of additive lighting.
            </summary>
        </member>
        <member name="F:Engine.Renderer.IlluminationStage.Ambient">
            <summary>
            Part of the rendering which occurs without any kind of direct lighting.
            </summary>
        </member>
        <member name="F:Engine.Renderer.IlluminationStage.PerLight">
            <summary>
            Part of the rendering which occurs per light.
            </summary>
        </member>
        <member name="F:Engine.Renderer.IlluminationStage.Decal">
            <summary>
            Post-lighting rendering.
            </summary>
        </member>
        <member name="F:Engine.Renderer.IlluminationStage.Unknown">
            <summary>
            Not determined.
            </summary>
        </member>
        <member name="T:Engine.Renderer.PixelFormat">
            <summary>The pixel format used for images, textures, and render surfaces.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Unknown">
            <summary>Unknown pixel format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.L8">
            <summary>8-bit pixel format, all bits luminace.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ByteL">
            <summary>8-bit pixel format, all bits luminace.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.L16">
            <summary>16-bit pixel format, all bits luminace.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ShortL">
            <summary>16-bit pixel format, all bits luminace.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A8">
            <summary>8-bit pixel format, all bits alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ByteA">
            <summary>8-bit pixel format, all bits alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A4L4">
            <summary>8-bit pixel format, 4 bits alpha, 4 bits luminace.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ByteLA">
            <summary>2 byte pixel format, 1 byte luminance, 1 byte alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.R5G6B5">
            <summary>16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.B5G6R5">
            <summary>16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.R3G3B2">
            <summary>8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A4R4G4B4">
            <summary>16-bit pixel format, 4 bits for alpha, red, green and blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A1R5G5B5">
            <summary>16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.R8G8B8">
            <summary>24-bit pixel format, 8 bits for red, green and blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.B8G8R8">
            <summary>24-bit pixel format, 8 bits for blue, green and red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A8R8G8B8">
            <summary>32-bit pixel format, 8 bits for alpha, red, green and blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A8B8G8R8">
            <summary>32-bit pixel format, 8 bits for blue, green, red and alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.B8G8R8A8">
            <summary>32-bit pixel format, 8 bits for blue, green, red and alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.R8G8B8A8">
            <summary>32-bit pixel format, 8 bits for red, green, blue and alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.X8R8G8B8">
            <summary>
            32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue
            like A8R8G8B8, but alpha will get discarded.
            </summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.X8B8G8R8">
            <summary>
            32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red
            like A8B8G8R8, but alpha will get discarded.
            </summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A2R10G10B10">
            <summary>32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.A2B10G10R10">
            <summary>32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.DXT1">
            <summary>DDS (DirectDraw Surface) DXT1 format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.DXT2">
            <summary>DDS (DirectDraw Surface) DXT2 format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.DXT3">
            <summary>DDS (DirectDraw Surface) DXT3 format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.DXT4">
            <summary>DDS (DirectDraw Surface) DXT4 format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.DXT5">
            <summary>DDS (DirectDraw Surface) DXT5 format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float16R">
            <summary>16-bit pixel format, 16 bits (float) for red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float16RGB">
            <summary>48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float16RGBA">
            <summary>64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float32R">
            <summary>16-bit pixel format, 16 bits (float) for red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float32RGB">
            <summary>96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float32RGBA">
            <summary>128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Depth24">
            <summary>Depth texture format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float16GR">
            <summary>32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Float32GR">
            <summary>64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ShortRGBA">
            <summary>64-bit pixel format, 16 bits for red, green, blue and alpha.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ShortGR">
            <summary>32-bit pixel format, 16-bit green, 16-bit red.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.ShortRGB">
            <summary>48-bit pixel format, 16 bits for red, green and blue.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat._3Dc">
            <summary>ATI 3Dc pixel format.</summary>
        </member>
        <member name="F:Engine.Renderer.PixelFormat.Count">
            <summary>Number of pixel formats currently defined.</summary>
        </member>
        <member name="T:Engine.Renderer.CompositionPass">
            <summary>
            Object representing one pass or operation in a composition sequence. This provides a 
            method to conviently interleave RenderSystem commands between Render Queues.
            </summary>
        </member>
        <member name="M:Engine.Renderer.CompositionPass.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.CompositionPass.SetInput(System.Int32,System.String)">
            <summary>Set an input local texture. An empty string clears the input.</summary>
            <param name="id">Input to set. Must be in 0..Max texture layer - 1.</param>
            <param name="input">Texture to bind to this input. An empty string clears the input.</param>
        </member>
        <member name="M:Engine.Renderer.CompositionPass.SetInput(System.Int32)">
            <summary>Set an input local texture. An empty string clears the input.</summary>
            <param name="id">Input to set. Must be in 0..Max texture layer - 1.</param>
        </member>
        <member name="P:Engine.Renderer.CompositionPass.Type">
            <summary>Gets or sets the type of composition pass.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionPass.MaterialName">
            <summary>Sets the material used by this pass.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionPass.Identifier">
            <summary>
            Gets or sets an identifier for this pass. This identifier can be used to
            "listen in" on this pass with an CompositorInstance.
            </summary>
        </member>
        <member name="T:Engine.Renderer.CompositionPass.PassType">
            <summary>Enumeration that enumerates the various composition pass types.</summary>
        </member>
        <member name="F:Engine.Renderer.CompositionPass.PassType.Clear">
            <summary>Clear target to one color.</summary>
        </member>
        <member name="F:Engine.Renderer.CompositionPass.PassType.Stencil">
            <summary>Set stencil operation.</summary>
        </member>
        <member name="F:Engine.Renderer.CompositionPass.PassType.RenderScene">
            <summary>Render the scene or part of it.</summary>
        </member>
        <member name="F:Engine.Renderer.CompositionPass.PassType.RenderQuad">
            <summary>Render a full screen quad.</summary>
        </member>
        <member name="T:Engine.Renderer.TextureManager">
            <summary>
            Class for loading and managing textures.
            </summary>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Load(System.String,Engine.Renderer.Texture.Type,System.Int32,System.Single)">
            <summary>Loads a texture from a file or returns if already loaded.</summary>
            <param name="name">The file to load, or a string identifier in some cases.</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures.</param>
            <param name="numMipmaps">
            The number of pre-filtered mipmaps to generate. If left to default (-1) then
            the TextureManager's default number of mipmaps will be used (see SetDefaultNumMipmaps())
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1.
            </param>
            <param name="gamma">
            The gamma adjustment factor to apply to this texture (brightening/darkening).
            </param>
            <returns><see cref="T:Engine.Renderer.Texture"/> if the texture has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Load(System.String,Engine.Renderer.Texture.Type,System.Int32)">
            <summary>Loads a texture from a file or returns if already loaded.</summary>
            <param name="name">The file to load, or a string identifier in some cases.</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures.</param>
            <param name="numMipmaps">
            The number of pre-filtered mipmaps to generate. If left to default (-1) then
            the TextureManager's default number of mipmaps will be used (see SetDefaultNumMipmaps())
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1.
            </param>
            <returns><see cref="T:Engine.Renderer.Texture"/> if the texture has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Load(System.String,Engine.Renderer.Texture.Type)">
            <summary>Loads a texture from a file or returns if already loaded.</summary>
            <param name="name">The file to load, or a string identifier in some cases.</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures.</param>
            <returns><see cref="T:Engine.Renderer.Texture"/> if the texture has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Load(System.String)">
            <summary>Loads a texture from a file or returns if already loaded.</summary>
            <param name="name">The file to load, or a string identifier in some cases.</param>
            <returns><see cref="T:Engine.Renderer.Texture"/> if the texture has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Create(System.String,Engine.Renderer.Texture.Type,Engine.MathEx.Vec2i,System.Int32,System.Int32,Engine.Renderer.PixelFormat,Engine.Renderer.Texture.Usage)">
            <summary>Create a manual texture with specified width, height and depth (not loaded from a file).</summary>
            <param name="name">The name to give the resulting texture.</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures.</param>
            <param name="size">The size of the texture.</param>
            <param name="depth">The depth of the texture.</param>
            <param name="numMipmaps">
            The number of pre-filtered mipmaps to generate. If left to default (-1) then
            the TextureManager's default number of mipmaps will be used (see SetDefaultNumMipmaps())
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1.
            </param>
            <param name="format">
            The internal format you wish to request; the manager reserves
            the right to create a different format if the one you select is
            not available in this context.
            </param>
            <param name="usage">
            The kind of usage this texture is intended for. It 
            is a combination of <b>STATIC</b>, <b>Dynamic</b>, <b>WriteOnly</b>, 
            <b>AutoMipmap</b> and <b>RenderTarget</b>. You are
            strongly advised to use <b>StaticWriteOnly</b> wherever possible, if you need to 
            update regularly, consider <b>DynamicWriteOnly</b>.
            </param>
            <returns><see cref="T:Engine.Renderer.Texture"/> if the texture has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Create(System.String,Engine.Renderer.Texture.Type,Engine.MathEx.Vec2i,System.Int32,System.Int32,Engine.Renderer.PixelFormat)">
            <summary>Create a manual texture with specified width, height and depth (not loaded from a file).</summary>
            <param name="name">The name to give the resulting texture.</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures.</param>
            <param name="size">The size of the texture.</param>
            <param name="depth">The depth of the texture.</param>
            <param name="numMipmaps">
            The number of pre-filtered mipmaps to generate. If left to default (-1) then
            the TextureManager's default number of mipmaps will be used (see SetDefaultNumMipmaps())
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1.
            </param>
            <param name="format">
            The internal format you wish to request; the manager reserves
            the right to create a different format if the one you select is
            not available in this context.
            </param>
            <returns><see cref="T:Engine.Renderer.Texture"/> if the texture has been created; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.GetUniqueName(System.String)">
            <summary>
            Returns the generated the unique texture name with prefix.
            </summary>
            <param name="prefix">The name prefix.</param>
            <returns>The generated unique the texture name with prefix.</returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.DisposeLoadedTextures">
            <summary>
            Disposed all loaded textures.
            </summary>
        </member>
        <member name="M:Engine.Renderer.TextureManager.Unload(System.String)">
            <summary>
            Unload texture if loaded.
            </summary>
            <param name="name">The file name.</param>
        </member>
        <member name="M:Engine.Renderer.TextureManager.UnloadAll(System.Boolean)">
            <summary>
            Unloads all resources.
            </summary>
            <remarks>
            Unloaded resources are not removed, they simply free up their memory
            as much as they can and wait to be reloaded.
            </remarks>
            <param name="reloadableOnly">
            If <b>true</b>, only unload the resource that
            is reloadable. Because some resources isn't reloadable, they will be
            unloaded but can't load them later. Thus, you might not want to them
            unloaded. Or, you might unload all of them, and then populate them
            manually later.
            </param>
        </member>
        <member name="M:Engine.Renderer.TextureManager.IsFormatSupported(Engine.Renderer.Texture.Type,Engine.Renderer.PixelFormat,Engine.Renderer.Texture.Usage)">
            <summary>
            Returns whether this render system can natively support the precise texture 
            format requested with the given usage options.
            </summary>
            <remarks>
            <para>
            You can still create textures with this format even if this method returns
            <b>false</b>; the texture format will just be altered to one which the device does
            support.
            </para>
            <para>
            Sometimes the device may just slightly change the format, such as reordering the 
            channels or packing the channels differently, without it making and qualitative 
            differences to the texture. If you want to just detect whether the quality of a
            given texture will be reduced, use <see cref="M:Engine.Renderer.TextureManager.IsEquivalentFormatSupported(Engine.Renderer.Texture.Type,Engine.Renderer.PixelFormat,Engine.Renderer.Texture.Usage)"/> instead.
            </para>
            </remarks>
            <param name="textureType">The texture type.</param>
            <param name="format">The pixel format requested.</param>
            <param name="usage">
            The kind of usage this texture is intended for, a combination of the 
            <b>Texture.Usage</b> flags.
            </param>
            <returns>
            <b>true</b> if the format is natively supported, <b>false</b> if a fallback would be used.
            </returns>
        </member>
        <member name="M:Engine.Renderer.TextureManager.IsEquivalentFormatSupported(Engine.Renderer.Texture.Type,Engine.Renderer.PixelFormat,Engine.Renderer.Texture.Usage)">
            <summary>
            Returns whether this render system can support the texture format requested
            with the given usage options, or another format with no quality reduction.
            </summary>
            <param name="textureType">The texture type.</param>
            <param name="format">The pixel format requested.</param>
            <param name="usage">
            The kind of usage this texture is intended for, a combination of the 
            <b>Texture.Usage</b> flags.
            </param>
            <returns>
            <b>true</b> if the format is natively supported, <b>false</b> if a fallback would be used.
            </returns>
        </member>
        <member name="P:Engine.Renderer.TextureManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.TextureManager"/>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RenderTexture">
            <summary>
            This class represents a RenderTarget that renders to a <see cref="T:Engine.Renderer.Texture"/>. There is no 1 on 1
            relation between Textures and RenderTextures, as there can be multiple 
            RenderTargets rendering to different mipmaps, faces (for cubemaps) or slices (for 3D textures)
            of the same <see cref="T:Engine.Renderer.Texture"/>.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderTexture.DisposeInternal">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="T:Engine.Renderer.MaterialManager">
            <summary>
            Class for managing Material settings for Engine.
            </summary>
            <remarks>
            <para>
            Materials control the eventual surface rendering properties of geometry. This class
            manages the library of materials, dealing with programmatic registrations and lookups,
            as well as loading predefined Material settings from scripts.
            </para>
            <para>
            When loaded from a script, a Material is in an 'unloaded' state and only stores the settings
            required. It does not at that stage load any textures. This is because the material settings may be
            loaded 'en masse' from bulk material script files, but only a subset will actually be required.
            </para>
            <para>
            Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or
            archive added to the resource paths/archives. See ResourceManager for details.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.GetByName(System.String)">
            <summary>Returns material by name.</summary>
            <param name="name">The material name.</param>
            <returns><see cref="T:Engine.Renderer.Material"/> if such material is exists; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.Exists(System.String)">
            <summary>To check up existence of a material.</summary>
            <param name="name">The material name.</param>
            <returns><b>true</b> if such material is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.Create(System.String)">
            <summary>Creates new material.</summary>
            <param name="name">The material name.</param>
            <returns>The new material.</returns>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.Clone(Engine.Renderer.Material,System.String)">
            <summary>
            Creates a new copy of material with the same settings but a new name.
            </summary>
            <param name="sourceMaterial">The source material.</param>
            <param name="newName">The name for the cloned material.</param>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.GetUniqueName(System.String)">
            <summary>
            Returns the generated the unique material name with prefix.
            </summary>
            <param name="prefix">The name prefix.</param>
            <returns>The generated unique the material name with prefix.</returns>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.UnloadMaterial(System.String)">
            <summary>Unloads material.</summary>
            <param name="name">The material name.</param>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.ParseFile(System.String)">
            <summary>Reloads material from file.</summary>
            <param name="fileName">The material file name.</param>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.SetDefaultTextureFiltering(Engine.Renderer.TextureFilterOptions)">
            <summary>
            Sets the default texture filtering to be used for loaded textures, 
            for when textures are loaded automatically (e.g. by <see cref="T:Engine.Renderer.Material"/> class) 
            or when 'load' is called with the default parameters by the application.
            </summary>
            <param name="filterOptions">The texture filter options.</param>
        </member>
        <member name="M:Engine.Renderer.MaterialManager.ReadMaterialNamesFromFile(System.String)">
            <summary>
            Returns the material names from file.
            </summary>
            <param name="fileName">The material file name.</param>
            <returns>The material names.</returns>
        </member>
        <member name="P:Engine.Renderer.MaterialManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.MaterialManager"/>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.MaterialManager.DefaultAnisotropy">
            <summary>
            Gets or sets the default anisotropy level to be used for loaded textures, 
            for when textures are loaded automatically (e.g. by <see cref="T:Engine.Renderer.Material"/> class) or 
            when 'load' is called with the default parameters by the application.
            </summary>
        </member>
        <member name="T:Engine.Renderer.ImageManager">
            <summary>
            Class for serialization images.
            </summary>
        </member>
        <member name="M:Engine.Renderer.ImageManager.LoadFromFile(System.String,System.Byte[]@,Engine.MathEx.Vec2i@,System.Int32@,Engine.Renderer.PixelFormat@,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Loads an image file.
            </summary>
            <param name="fileName">The file name.</param>
            <param name="data">The image data.</param>
            <param name="size">The image size.</param>
            <param name="depth">The image depth (in 3d images, numbers of layers, otherwhise 1).</param>
            <param name="format">Pixel format.</param>
            <param name="numFaces">The number of faces the image data has inside (6 for cubemaps, 1 otherwise).</param>
            <param name="numMipmaps">The number of mipmaps the image data has inside.</param>
            <param name="error">Output error string.</param>
            <returns><b>true</b> if image is loaded; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.ImageManager.LoadFromBuffer(System.Byte[],System.String,System.Byte[]@,Engine.MathEx.Vec2i@,System.Int32@,Engine.Renderer.PixelFormat@,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Loads an image from buffer.
            </summary>
            <param name="sourceBuffer">The source buffer.</param>
            <param name="fileType">The file type (file extension).</param>
            <param name="data">The image data.</param>
            <param name="size">The image size.</param>
            <param name="depth">The image depth (in 3d images, numbers of layers, otherwhise 1).</param>
            <param name="format">Pixel format.</param>
            <param name="numFaces">The number of faces the image data has inside (6 for cubemaps, 1 otherwise).</param>
            <param name="numMipmaps">The number of mipmaps the image data has inside.</param>
            <param name="error">Output error string.</param>
            <returns><b>true</b> if image is loaded; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.ImageManager.Save(System.String,System.Byte[],Engine.MathEx.Vec2i,System.Int32,Engine.Renderer.PixelFormat,System.Int32,System.Int32,System.String@)">
            <summary>
            Save the image as a file.
            </summary>
            <param name="fileName">The file name.</param>
            <param name="data">The image data.</param>
            <param name="size">The image size.</param>
            <param name="depth">The image depth (in 3d images, numbers of layers, otherwhise 1).</param>
            <param name="format">Pixel format.</param>
            <param name="numFaces">The number of faces the image data has inside (6 for cubemaps, 1 otherwise).</param>
            <param name="numMipmaps">The number of mipmaps the image data has inside.</param>
            <param name="error">Output error string.</param>
            <returns><b>true</b> if image is currently serialized; otherwise, <b>false</b>.</returns>
        </member>
        <member name="T:Engine.Renderer.HorizontalAlign">
            <summary>
            Specifies the horizontal alignment.
            </summary>
        </member>
        <member name="F:Engine.Renderer.HorizontalAlign.Left">
            <summary>The element is aligned to the left side.</summary>
        </member>
        <member name="F:Engine.Renderer.HorizontalAlign.Center">
            <summary>The element is centered horizontally.</summary>
        </member>
        <member name="F:Engine.Renderer.HorizontalAlign.Right">
            <summary>The element is aligned to the right side.</summary>
        </member>
        <member name="T:Engine.Renderer.VerticalAlign">
            <summary>
            Specifies the vertical alignment.
            </summary>
        </member>
        <member name="F:Engine.Renderer.VerticalAlign.Top">
            <summary>The element is aligned to the top.</summary>
        </member>
        <member name="F:Engine.Renderer.VerticalAlign.Center">
            <summary>The element is centered vertically.</summary>
        </member>
        <member name="F:Engine.Renderer.VerticalAlign.Bottom">
            <summary>The element is aligned to the bottom.</summary>
        </member>
        <member name="T:Engine.Renderer.GuiRenderer">
            <summary>
            Specifies the gui renderer class. The class allows to draw 2d graphic elements.
            It can be configurated so that to draw elements oriented in 3D.
            </summary>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.#ctor(System.Boolean,Engine.Renderer.Viewport)">
            <summary>
            Initializes a new instance of the <see cref="T:Engine.Renderer.GuiRenderer"/> class.
            </summary>
            <param name="isScreen">The screen renderer flag.</param>
            <param name="viewportForScreenGuiRenderer"></param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.SetTransform(Engine.MathEx.Vec3,Engine.MathEx.Quat,Engine.MathEx.Vec3)">
            <summary>
            Sets the 3D gui transformation.
            </summary>
            <param name="position">The position.</param>
            <param name="rotation">The rotation.</param>
            <param name="scale">The scale.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddQuad(Engine.MathEx.Rect,Engine.MathEx.Rect,Engine.Renderer.Texture,Engine.MathEx.ColorValue,System.Boolean,Engine.MathEx.Rect)">
            <summary>
            Add quad to rendering queue.
            </summary>
            <param name="rectangle">The quad rectangle.</param>
            <param name="textureCoordRectangle">The texture coordinates.</param>
            <param name="texture">The quad texture or <b>null</b>.</param>
            <param name="color">The quad color.</param>
            <param name="clamp">The texture clamp.</param>
            <param name="clipRectangle">The clip rectangle.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddQuad(Engine.MathEx.Rect,Engine.MathEx.Rect,Engine.Renderer.Texture,Engine.MathEx.ColorValue,System.Boolean)">
            <summary>
            Add quad to rendering queue.
            </summary>
            <param name="rectangle">The quad rectangle.</param>
            <param name="textureCoordRectangle">The texture coordinates.</param>
            <param name="texture">The quad texture or <b>null</b>.</param>
            <param name="color">The quad color.</param>
            <param name="clamp">The texture clamp.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddQuad(Engine.MathEx.Rect,Engine.MathEx.Rect,Engine.Renderer.Texture,Engine.MathEx.ColorValue)">
            <summary>
            Add quad to rendering queue.
            </summary>
            <param name="rectangle">The quad rectangle.</param>
            <param name="textureCoordRectangle">The texture coordinates.</param>
            <param name="texture">The quad texture or <b>null</b>.</param>
            <param name="color">The quad color.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddQuad(Engine.MathEx.Rect,Engine.MathEx.Rect,Engine.Renderer.Texture)">
            <summary>
            Add quad to rendering queue.
            </summary>
            <param name="rectangle">The quad rectangle.</param>
            <param name="textureCoordRectangle">The texture coordinates.</param>
            <param name="texture">The quad texture or <b>null</b>.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddQuad(Engine.MathEx.Rect,Engine.MathEx.ColorValue)">
            <summary>
            Add quad to rendering queue.
            </summary>
            <param name="rectangle">The quad rectangle.</param>
            <param name="color">The quad color.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddQuad(Engine.MathEx.Rect,Engine.MathEx.ColorValue,Engine.MathEx.Rect)">
            <summary>
            Add quad to rendering queue.
            </summary>
            <param name="rectangle">The quad rectangle.</param>
            <param name="color">The quad color.</param>
            <param name="clipRectangle">The clip rectangle.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddText(Engine.Renderer.Font,System.String,Engine.MathEx.Vec2,Engine.Renderer.HorizontalAlign,Engine.Renderer.VerticalAlign,Engine.MathEx.ColorValue,Engine.MathEx.Rect)">
            <summary>
            Add text to rendering queue.
            </summary>
            <param name="font">The text font.</param>
            <param name="text">The text.</param>
            <param name="position">The text position.</param>
            <param name="horizontalAlign">The text horizontal align.</param>
            <param name="verticalAlign">The text vertical align.</param>
            <param name="color">The text color.</param>
            <param name="clipRectangle">The text clip rectangle.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddText(Engine.Renderer.Font,System.String,Engine.MathEx.Vec2,Engine.Renderer.HorizontalAlign,Engine.Renderer.VerticalAlign,Engine.MathEx.ColorValue)">
            <summary>
            Add text to rendering queue.
            </summary>
            <param name="font">The text font.</param>
            <param name="text">The text.</param>
            <param name="position">The text position.</param>
            <param name="horizontalAlign">The text horizontal align.</param>
            <param name="verticalAlign">The text vertical align.</param>
            <param name="color">The text color.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddText(System.String,Engine.MathEx.Vec2,Engine.Renderer.HorizontalAlign,Engine.Renderer.VerticalAlign,Engine.MathEx.ColorValue,Engine.MathEx.Rect)">
            <summary>
            Add text to rendering queue.
            </summary>
            <param name="text">The text.</param>
            <param name="position">The text position.</param>
            <param name="horizontalAlign">The text horizontal align.</param>
            <param name="verticalAlign">The text vertical align.</param>
            <param name="color">The text color.</param>
            <param name="clipRectangle">The text clip rectangle.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddText(System.String,Engine.MathEx.Vec2,Engine.Renderer.HorizontalAlign,Engine.Renderer.VerticalAlign,Engine.MathEx.ColorValue)">
            <summary>
            Add text to rendering queue.
            </summary>
            <param name="text">The text.</param>
            <param name="position">The text position.</param>
            <param name="horizontalAlign">The text horizontal align.</param>
            <param name="verticalAlign">The text vertical align.</param>
            <param name="color">The text color.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddText(System.String,Engine.MathEx.Vec2,Engine.Renderer.HorizontalAlign,Engine.Renderer.VerticalAlign)">
            <summary>
            Add text to rendering queue.
            </summary>
            <param name="text">The text.</param>
            <param name="position">The text position.</param>
            <param name="horizontalAlign">The text horizontal align.</param>
            <param name="verticalAlign">The text vertical align.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddText(System.String,Engine.MathEx.Vec2)">
            <summary>
            Add text to rendering queue.
            </summary>
            <param name="text">The text.</param>
            <param name="position">The text position.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddTextLines(System.String[],Engine.MathEx.Vec2,Engine.MathEx.Vec2,Engine.Renderer.HorizontalAlign,Engine.Renderer.VerticalAlign,Engine.MathEx.ColorValue)">
            <summary>
            Add text lines to rendering queue.
            </summary>
            <param name="lines">The text lines.</param>
            <param name="pos">The text position.</param>
            <param name="step">The lines step.</param>
            <param name="horizontalAlign">The text horizontal align.</param>
            <param name="verticalAlign">The text vertical align.</param>
            <param name="color">The text color.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddLine(Engine.MathEx.Vec2,Engine.MathEx.Vec2,Engine.MathEx.ColorValue,Engine.MathEx.Rect)">
            <summary>
            Add line to rendering queue.
            </summary>
            <param name="start">The line start position.</param>
            <param name="end">The line end position.</param>
            <param name="color">The text color.</param>
            <param name="clipRectangle">The text clip rectangle.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddLine(Engine.MathEx.Vec2,Engine.MathEx.Vec2,Engine.MathEx.ColorValue)">
            <summary>
            Add line to rendering queue.
            </summary>
            <param name="start">The line start position.</param>
            <param name="end">The line end position.</param>
            <param name="color">The text color.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddRectangle(Engine.MathEx.Rect,Engine.MathEx.ColorValue,Engine.MathEx.Rect)">
            <summary>
            Add rectangle to rendering queue.
            </summary>
            <param name="rectangle">The rectangle.</param>
            <param name="color">The text color.</param>
            <param name="clipRectangle">The text clip rectangle.</param>
        </member>
        <member name="M:Engine.Renderer.GuiRenderer.AddRectangle(Engine.MathEx.Rect,Engine.MathEx.ColorValue)">
            <summary>
            Add rectangle to rendering queue.
            </summary>
            <param name="rectangle">The rectangle.</param>
            <param name="color">The text color.</param>
        </member>
        <member name="P:Engine.Renderer.GuiRenderer.DefaultFont">
            <summary>
            Gets or sets the default font.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GuiRenderer.IsScreen">
            <summary>
            Gets or sets value which indicates what is it renderer is screen renderer.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GuiRenderer.ApplyPostEffectsToScreenRenderer">
            <summary>
            Gets or sets value which indicates what apply a post effects to the screen renderer.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RenderQueueListener">
            <summary>
            Interface which classes must implement if they wish to receive
            events from the render queue. 
            </summary>
            <remarks>
            <para>
            The Engine render queue is divided into several queue groups, as defined by
            uint8. A class may implement this interface, and register itself as a listener by calling 
            <see cref="M:Engine.Renderer.SceneManager.AddRenderQueueListener(Engine.Renderer.RenderQueueListener)"/>. After doing so,
            the class will receive an event before and after each queue group is sent to 
            the rendering system.
            </para>
            <para>
            The event listeners have an option to make a queue either be skipped, or to repeat.
            Note that if multiple listeners are registered, the one registered last has the final
            say, although options set by previous listeners will not be changed if the latest
            does not express a preference.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderQueueListener.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.RenderQueueListener.OnRenderQueueStarted(Engine.Renderer.RenderQueueGroupID,System.String,System.Boolean@)">
            <summary>
            Event raised before a queue group is rendered.
            </summary>
            <param name="queueGroupId">The id of the queue group which is about to be rendered.</param>
            <param name="invocation">Name of the invocation which is causing this to be called.</param>
            <param name="skipThisInvocation">
            A boolean passed by reference which is by default set to 
            false. If the event sets this to true, the queue will be skipped and not
            rendered.
            </param>
            <remarks>
            This method is called by the <see cref="T:Engine.Renderer.SceneManager"/> before 
            each queue group is rendered. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderQueueListener.OnRenderQueueEnded(Engine.Renderer.RenderQueueGroupID,System.String,System.Boolean@)">
            <summary>
            Event raised after a queue group is rendered.
            </summary>
            <param name="queueGroupId">The id of the queue group which has just been rendered.</param>
            <param name="invocation">Name of the invocation which is causing this to be called.</param>
            <param name="repeatThisInvocation">
            A boolean passed by reference which is by default set to 
            false. If the event sets this to true, the queue which has just been
            rendered will be repeated.
            </param>
            <remarks>
            This method is called by the <see cref="T:Engine.Renderer.SceneManager"/> before 
            each queue group is rendered. 
            </remarks>
        </member>
        <member name="T:Engine.Renderer.CompositionTechnique">
            <summary>
            Base composition technique, can be subclassed in plugins.
            </summary>
        </member>
        <member name="M:Engine.Renderer.CompositionTechnique.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.CompositionTechnique.CreateTextureDefinition(System.String)">
            <summary>Creates a new local texture definition.</summary>
            <param name="name">The texture definition name.</param>
            <returns>The texture definition.</returns>
        </member>
        <member name="M:Engine.Renderer.CompositionTechnique.CreateTargetPass">
            <summary>Creates a new target pass.</summary>
            <returns>The target pass.</returns>
        </member>
        <member name="M:Engine.Renderer.CompositionTechnique.GetTextureDefinition(System.String)">
            <summary>Find a texture definition by name.</summary>
            <param name="name">The texture definition name.</param>
            <returns>The texture definition if the texture is exists; otherwise, <b>null</b>.</returns>
        </member>
        <member name="P:Engine.Renderer.CompositionTechnique.TextureDefinitions">
            <summary>Gets the texture definitions collection. <b>Don't modify</b>.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTechnique.TargetPasses">
            <summary>Gets the target passes collection. <b>Don't modify</b>.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTechnique.OutputTargetPass">
            <summary>Gets the output target pass.</summary>
        </member>
        <member name="T:Engine.Renderer.CompositionTechnique.TextureDefinition">
            <summary>Local texture definition.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTechnique.TextureDefinition.Name">
            <summary>Gets or sets the name.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTechnique.TextureDefinition.Size">
            <summary>Gets or sets the texture size. Vec2i(0,0) means adapt to target width.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTechnique.TextureDefinition.FormatList">
            <summary>Gets or sets the pixel formats.</summary>
            <remarks>More than one means MRT.</remarks>
        </member>
        <member name="T:Engine.Renderer.Billboard">
            <summary>A billboard is a primitive which always faces the camera in every frame.</summary>
            <remarks>
            <para>
            Billboards can be used for special effects or some other trickery which requires the
            triangles to always facing the camera no matter where it is. Engine groups billboards into
            sets for efficiency, so you should never create a billboard on it's own (it's ok to have a
            set of one if you need it).
            </para>
            <para>
            Billboards have their geometry generated every frame depending on where the camera is. It is most
            beneficial for all billboards in a set to be identically sized since Engine can take advantage of this and
            save some calculations - useful when you have sets of hundreds of billboards as is possible with special
            effects. You can deviate from this if you wish (example: a smoke effect would probably have smoke puffs
            expanding as they rise, so each billboard will legitimately have it's own size) but be aware the extra
            overhead this brings and try to avoid it if you can.
            </para>
            <para>
            Billboards are just the mechanism for rendering a range of effects such as particles. It is other classes
            which use billboards to create their individual effects, so the methods here are quite generic.
            </para>
            </remarks>
            <seealso cref="T:Engine.Renderer.BillboardSet"/>
        </member>
        <member name="M:Engine.Renderer.Billboard.SetDimensions(Engine.MathEx.Vec2)">
            <summary>Sets the width and height for this billboard.</summary>
            <param name="size">The dimensions.</param>
            <remarks>
            Note that it is most efficient for every billboard in a <see cref="T:Engine.Renderer.BillboardSet"/> to have the same dimensions. If you
            choose to alter the dimensions of an individual billboard the set will be less efficient. Do not call
            this method unless you really need to have different billboard dimensions within the same set.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Billboard.ResetDimensions">
            <summary>Resets this Billboard to use the parent BillboardSet's dimensions instead of it's own.</summary>
        </member>
        <member name="M:Engine.Renderer.Billboard.HasOwnDimensions">
            <summary>
            Returns <b>true</b> if this billboard deviates from the BillboardSet's default dimensions (i.e. if the
            <see cref="M:Engine.Renderer.Billboard.SetDimensions(Engine.MathEx.Vec2)"/> method has been called for this instance).
            </summary>
            <returns><b>true</b> if this billboard deviates from the BillboardSet's default dimensions.</returns>
            <seealso cref="M:Engine.Renderer.Billboard.SetDimensions(Engine.MathEx.Vec2)"/>
        </member>
        <member name="M:Engine.Renderer.Billboard.GetOwnDimensions">
            <summary>Retrieves the billboard's personal dimensions, if <see cref="M:Engine.Renderer.Billboard.HasOwnDimensions"/> is true.</summary>
            <returns>The dimensions.</returns>
        </member>
        <member name="M:Engine.Renderer.Billboard.GetTexCoordRect">
            <summary>
            Returns the individual texture coordinate rect of this billboard will use when rendering.
            </summary>
            <returns>The individual texture coordinate rect of this billboard will use when rendering.</returns>
            <remarks>
            This value is useful only when <see cref="M:Engine.Renderer.Billboard.IsUseTexCoordRect"/> return <b>true</b>.
            </remarks>
            <seealso cref="M:Engine.Renderer.Billboard.IsUseTexCoordRect"/>
            <seealso cref="M:Engine.Renderer.Billboard.SetTexCoordRect(Engine.MathEx.Rect)"/>
        </member>
        <member name="M:Engine.Renderer.Billboard.SetTexCoordRect(Engine.MathEx.Rect)">
            <summary>
            Sets the individual texture coordinate rect of this billboard will use when rendering.
            </summary>
            <param name="rect">The rectangle.</param>
            <remarks>
            The parent billboard set may contain more than one, in
            which case a billboard can be textured with different pieces of a larger texture
            sheet very efficiently.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Billboard.IsUseTexCoordRect">
            <summary>Returns <b>true</b> if this billboard use individual texture coordinate rect.</summary>
            <returns><b>true</b> if this billboard use individual texture coordinate rect.</returns>
            <seealso cref="M:Engine.Renderer.Billboard.IsUseTexCoordRect"/>
            <seealso cref="M:Engine.Renderer.Billboard.SetTexCoordRect(Engine.MathEx.Rect)"/>
        </member>
        <member name="P:Engine.Renderer.Billboard.Rotation">
            <summary>Gets or sets the rotation of the billboard.</summary>
            <remarks>
            This rotation is relative to the center of the billboard.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Billboard.Position">
            <summary>Gets or sets the position of the billboard.</summary>
            <remarks>
            This position is relative to a point on the quad which is the billboard.
            Depending on the <see cref="T:Engine.Renderer.BillboardSet"/>,
            this may be the center of the quad, the top-left etc.
            See <see cref="P:Engine.Renderer.BillboardSet.Origin"/> for more info.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Billboard.Color">
            <summary>Gets or sets the color of this billboard.</summary>
        </member>
        <member name="P:Engine.Renderer.Billboard.TexCoordIndex">
            <summary>
            Gets or sets the texture coordinate index of rect of this billboard.
            </summary>
            <remarks>
            The texture coordinate rect this billboard will use 
            when rendering. The parent billboard set may contain more than one, in which 
            case a billboard can be textured with different pieces of a larger texture 
            sheet very efficiently.
            </remarks>
            <seealso cref="M:Engine.Renderer.Billboard.SetTexCoordRect(Engine.MathEx.Rect)"/>
        </member>
        <member name="T:Engine.Renderer.Billboard.Origin">
            <summary>
            Enum covering what exactly a billboard's position means (center,top-left etc).
            </summary>
            <seealso cref="P:Engine.Renderer.BillboardSet.Origin"/>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.TopLeft">
            <summary>Top left</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.TopCenter">
            <summary>Top center</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.TopRight">
            <summary>Top right</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.CenterLeft">
            <summary>Center left</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.Center">
            <summary>Center</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.CenterRight">
            <summary>Bottom right</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.BottomLeft">
            <summary>Bottom left</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.BottomCenter">
            <summary>Bottom center</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Origin.BottomRight">
            <summary>Bottom right</summary>
        </member>
        <member name="T:Engine.Renderer.Billboard.RotationType">
            <summary>The rotation type of billboard.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.RotationType.Vertex">
            <summary>Rotate the billboard's vertices around their facing direction.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.RotationType.Texcoord">
            <summary>Rotate the billboard's texture coordinates.</summary>
        </member>
        <member name="T:Engine.Renderer.Billboard.Type">
            <summary>The type of billboard to use.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Type.Point">
            <summary>Standard point billboard (default), always faces the camera completely and is always upright.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Type.OrientedCommon">
            <summary>Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Type.OrientedSelf">
            <summary>Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Type.PerpendicularCommon">
            <summary>Billboards are perpendicular to a shared direction vector (used as Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor.</summary>
        </member>
        <member name="F:Engine.Renderer.Billboard.Type.PerpendicularSelf">
            <summary>Billboards are perpendicular to their own direction vector (their own Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor.</summary>
        </member>
        <member name="M:Engine.Renderer.HighLevelMaterial.OnGetEditorShowInformation(System.String[]@,Engine.MathEx.ColorValue@)">
            <summary>
            To receive the line information which will be shown in Resource Editor when entity it is selected.
            </summary>
            <param name="lines">The text.</param>
            <param name="color">The text color.</param>
        </member>
        <member name="T:Engine.Renderer.StaticMeshObject">
            <summary>
            Defines the class for rendering the static geometry.
            </summary>
        </member>
        <member name="M:Engine.Renderer.StaticMeshObject.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="P:Engine.Renderer.StaticMeshObject.Bounds">
            <summary>
            Gets the object world bounds.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RenderQueueGroupID">
            <summary>
            Enumeration of queue groups, by which the application may group queued renderables
            so that they are rendered together with events in between
            </summary>
            <remarks>
            When passed into methods these are actually passed as a uint8 to allow you
            to use values in between if you want to.
            </remarks>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Background">
            <summary>Background queue</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.SkiesEarly">
            <summary>Skies early queue.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue1">
            <summary>Queue 1.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue2">
            <summary>Queue 2.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.WorldGeometry1">
            <summary>World geometry queue.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue3">
            <summary>Queue 3.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue4">
            <summary>Queue 4.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Main">
            <summary>Main queue.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue6">
            <summary>Queue 6.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue7">
            <summary>Queue 7.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.WorldGeometry2">
            <summary>World geometry 2 queue.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue8">
            <summary>Queue 8.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Queue9">
            <summary>Queue 9.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.SkiesLate">
            <summary>Skies late queue.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderQueueGroupID.Overlay">
            <summary>Overlay queue.</summary>
        </member>
        <member name="T:Engine.Renderer.RenderLightType">
            <summary>Defines the type of light.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderLightType.Point">
            <summary>Point light sources give off light equally in all directions, so require only position not direction.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderLightType.Directional">
            <summary>Directional lights simulate parallel light beams from a distant source, hence have direction but no position.</summary>
        </member>
        <member name="F:Engine.Renderer.RenderLightType.Spot">
            <summary>Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff.</summary>
        </member>
        <member name="T:Engine.Renderer.RenderLight">
            <summary>
            Representation of a dynamic light source in the scene.
            </summary>
            <remarks>
            <para>
            Lights are added to the scene like any other object. They contain various
            parameters like type, position, attenuation (how light intensity fades with
            distance), color etc.
            </para>
            <para>
            The defaults when a light is created is pure white diffues light, with no
            attenuation (does not decrease with distance) and a range of 1000 world units.
            </para>
            <para>
            Lights are created by using the <see cref="M:Engine.Renderer.SceneManager.CreateLight"/> method. They can subsequently be
            added to a <see cref="T:Engine.Renderer.SceneNode"/> if required to allow them to move relative to a node in the scene. A light attached
            to a SceneNode is assumed to havea base position of (0,0,0) and a direction of (0,0,1) before modification
            by the SceneNode's own orientation. If not attached to a <see cref="T:Engine.Renderer.SceneNode"/>,
            the light's position and direction is as set using setPosition and setDirection.
            </para>
            <para>
            Remember also that dynamic lights rely on modifying the color of vertices based on the position of
            the light compared to an object's vertex normals. Dynamic lighting will only look good if the
            object being lit has a fair level of tesselation and the normals are properly set. This is particularly
            true for the spotlight which will only look right on highly tesselated models. In the future Engine may be
            extended for certain scene types so an alternative to the standard dynamic lighting may be used, such
            as dynamic lightmaps.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderLight.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderLight.Type">
            <summary>
            Gets or sets the light type.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderLight.Position">
            <summary>
            Gets or sets the position of the light.
            </summary>
            <remarks>
            Applicable to point lights and spotlights only.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.Direction">
            <summary>
            Gets or sets the direction in which a light points.
            </summary>
            <remarks>
            <para>
            Applicable only to the spotlight and directional light types.
            </para>
            <para>
            This will be overridden if the light is attached to a SceneNode.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.DiffuseColor">
            <summary>
            Gets or sets the color of the diffuse light given off by this source.
            </summary>
            <remarks>
            <para>
            Material objects have ambient, diffuse and specular values which indicate how much of each type of
            light an object reflects. This value denotes the amount and color of this type of light the light
            exudes into the scene. The actual appearance of objects is a combination of the two.
            </para>
            <para>
            Diffuse light simulates the typical light emenating from light sources and affects the base color
            of objects together with ambient light.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.SpecularColor">
            <summary>
            Gets or sets the color of the specular light given off by this source.
            </summary>
            <remarks>
            <para>
            Material objects have ambient, diffuse and specular values which indicate how much of each type of
            light an object reflects. This value denotes the amount and color of this type of light the light
            exudes into the scene. The actual appearance of objects is a combination of the two.
            </para>
            <para>
            Specular light affects the appearance of shiny highlights on objects, and is also dependent on the
            'shininess' Material value.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.AttenuationRange">
            <summary>
            Gets or sets the attenuation range parameter of the light source ie how it diminishes with distance.
            </summary>
            <remarks>
            <para>
            Lights normally get fainter the further they are away. Also, each light is given a maximum range
            beyond which it cannot affect any objects.
            </para>
            <para>
            Light attentuation is not applicable to directional lights since they have an infinite range and
            constant intensity.
            </para>
            <para>
            This follows a standard attenuation approach - see any good 3D text for the details of what they mean
            since i don't have room here!
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.AttenuationConstant">
            <summary>
            Gets or sets the attenuation constant parameter of the light source ie how it diminishes with distance.
            </summary>
            <remarks>
            <para>
            Lights normally get fainter the further they are away. Also, each light is given a maximum range
            beyond which it cannot affect any objects.
            </para>
            <para>
            Light attentuation is not applicable to directional lights since they have an infinite range and
            constant intensity.
            </para>
            <para>
            This follows a standard attenuation approach - see any good 3D text for the details of what they mean
            since i don't have room here!
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.AttenuationLinear">
            <summary>
            Gets or sets the attenuation linear parameter of the light source ie how it diminishes with distance.
            </summary>
            <remarks>
            <para>
            Lights normally get fainter the further they are away. Also, each light is given a maximum range
            beyond which it cannot affect any objects.
            </para>
            <para>
            Light attentuation is not applicable to directional lights since they have an infinite range and
            constant intensity.
            </para>
            <para>
            This follows a standard attenuation approach - see any good 3D text for the details of what they mean
            since i don't have room here!
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.AttenuationQuadric">
            <summary>
            Gets or sets the attenuation Quadric parameter of the light source ie how it diminishes with distance.
            </summary>
            <remarks>
            <para>
            Lights normally get fainter the further they are away. Also, each light is given a maximum range
            beyond which it cannot affect any objects.
            </para>
            <para>
            Light attentuation is not applicable to directional lights since they have an infinite range and
            constant intensity.
            </para>
            <para>
            This follows a standard attenuation approach - see any good 3D text for the details of what they mean
            since i don't have room here!
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderLight.SpotlightInnerAngle">
            <summary>
            Gets or sets the angle covered by the spotlights inner cone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderLight.SpotlightOuterAngle">
            <summary>
            Gets or sets the angle covered by the spotlights outer cone.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderLight.SpotlightFalloff">
            <summary>
            Gets or sets the falloff between the inner and outer cones of the spotlight.
            </summary>
        </member>
        <member name="T:Engine.Renderer.MeshManager">
            <summary>
            Handles the management of mesh resources.
            </summary>
            <remarks>
            This class deals with the runtime management of
            mesh data; like other resource managers it handles
            the creation of resources (in this case mesh data),
            working within a fixed memory budget.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.MeshManager.Load(System.String)">
            <summary>Loads mesh or returns already loaded mesh.</summary>
            <param name="name">The mesh name.</param>
            <returns><see cref="T:Engine.Renderer.Mesh"/> if the mesh has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.MeshManager.CreatePlane(System.String,Engine.MathEx.Plane,Engine.MathEx.Vec2,Engine.MathEx.Vec2i,System.Boolean,System.Int32,Engine.MathEx.Vec2,Engine.MathEx.Vec3)">
            <summary>
            Creates a basic plane, by default majoring on the x/y axes facing positive Z.
            </summary>
            <param name="name">The name to give the resulting mesh.</param>
            <param name="plane">The name of the resource group to assign the mesh to.</param>
            <param name="size">The size of the plane in world coordinates.</param>
            <param name="segments">number of segements to the plane.</param>
            <param name="normals">If <b>true</b>, normals are created perpendicular to the plane.</param>
            <param name="numTexCoordSets">
            The number of 2D texture coordinate sets created - by default the corners 
            are created to be the corner of the texture.
            </param>
            <param name="tile">The number of times the texture should be repeated.</param>
            <param name="upVector">The 'Up' direction of the plane.</param>
            <returns>The mesh.</returns>
        </member>
        <member name="M:Engine.Renderer.MeshManager.CreateCurvedIllusionPlane(System.String,Engine.MathEx.Plane,Engine.MathEx.Vec2,System.Single,Engine.MathEx.Vec2i,System.Boolean,System.Int32,Engine.MathEx.Vec2,Engine.MathEx.Vec3,Engine.MathEx.Quat,System.Int32)">
            <summary>
            Creates a plane, which because of it's texture coordinates looks like a curved
            surface, useful for skies in a skybox.
            </summary>
            <param name="name">The name to give the resulting mesh.</param>
            <param name="plane">The orientation of the plane and distance from the origin.</param>
            <param name="size">The size of the plane in world coordinates.</param>
            <param name="curvature">
            The curvature of the plane. Good values are between 2 and 65. Higher values are 
            more curved leading to a smoother effect, lower values are less curved meaning
            more distortion at the horizons but a better distance effect.
            </param>
            <param name="segments">The number of segments to the plane.</param>
            <param name="normals">If true, normals are created perpendicular to the plane.</param>
            <param name="numTexCoordSets">
            The number of 2D texture coordinate sets created - by default the corners
            are created to be the corner of the texture.
            </param>
            <param name="tile">
            The number of times the texture should be repeated in the u and v directions.
            </param>
            <param name="upVector">The 'Up' direction of the plane.</param>
            <param name="orientation">
            The orientation of the overall sphere that's used to create the illusion.
            </param>
            <param name="ySegmentsToKeep">
            The number of segments from the top of the dome downwards to keep. -1 keeps all of 
            them. This can save fillrate if you cannot see much of the sky lower down.
            </param>
            <returns>The mesh.</returns>
        </member>
        <member name="M:Engine.Renderer.MeshManager.GetUniqueName(System.String)">
            <summary>
            Returns the generated the unique mesh name with prefix.
            </summary>
            <param name="prefix">The name prefix.</param>
            <returns>The generated unique the mesh name with prefix.</returns>
        </member>
        <member name="M:Engine.Renderer.MeshManager.DisposeLoadedMeshes">
            <summary>
            Disposed all loaded meshes.
            </summary>
        </member>
        <member name="M:Engine.Renderer.MeshManager.CreateManual(System.String)">
            <summary>
            Creates a new Mesh specifically for manual definition rather 
            than loading from an object file. 
            </summary>
            <remarks>
            Note that once you've defined your mesh, you must call 
            <see cref="M:Engine.Renderer.Mesh.SetBoundsAndRadius(Engine.MathEx.Bounds,System.Single)"/>
            in order to define the bounds of your mesh.
            </remarks>
            <param name="name">The name to give the new mesh.</param>
        </member>
        <member name="M:Engine.Renderer.MeshManager.SaveToFile(Engine.Renderer.Mesh,System.String)">
            <summary>
            Exports a mesh to the file specified.
            </summary>
            <remarks>
            This method takes an externally created Mesh object, and exports both it
            and optionally the Materials it uses to a .mesh file.
            </remarks>
            <param name="mesh">The mesh.</param>
            <param name="realFileName">The destination filename.</param>
            <returns><b>true</b> if the mesh has been saved; otherwise, <b>false</b>.</returns>
        </member>
        <member name="P:Engine.Renderer.MeshManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.MeshManager"/>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.GpuProgram">
            <summary>
            Defines a program which runs on the GPU such as a vertex or fragment program.
            </summary>
            <remarks>
            This class defines the low-level program in assembler code, the sort used to
            directly assemble into machine instructions for the GPU to execute. By nature,
            this means that the assembler source is rendersystem specific, which is why this
            is an abstract class - real instances are created through the <see cref="T:Engine.Renderer.RenderSystem"/>. 
            </remarks>
        </member>
        <member name="M:Engine.Renderer.GpuProgram.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.GpuProgram.Touch">
            <summary>
            'Touches' the resource to indicate it has been used.
            </summary>
        </member>
        <member name="M:Engine.Renderer.GpuProgram.HasCompileError">
            <summary>
            Did this program encounter a compile error when loading?
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.Name">
            <summary>
            Gets the gpu program name.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.FileName">
            <summary>
            Gets the program file name.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.Source">
            <summary>
            Gets or sets the source for this program. 
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.SourceFile">
            <summary>
            Gets or sets the name of the file used as source for this program.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.SyntaxCode">
            <summary>
            Gets or sets the syntax code for this program e.g. arbvp1, fp20, vs_1_1 etc.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.EntryPoint">
            <summary>
            Gets or sets the entry point defined for this program.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.PreprocessorDefines">
            <summary>
            Gets or set the preprocessor defines defined for this program.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.Target">
            <summary>
            Gets or sets the shader target to compile down to, e.g. 'vs_1_1'.
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.DefaultParameters">
            <summary>
            Get a reference to the default parameters which are to be used for all
            uses of this program.
            </summary>
            <remarks>
            A program can be set up with a list of default parameters, which can save time when 
            using a program many times in a material with roughly the same settings. By 
            retrieving the default parameters and populating it with the most used options, 
            any new parameter objects created from this program afterwards will automatically include
            the default parameters; thus users of the program need only change the parameters
            which are unique to their own usage of the program.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.Language">
            <summary>
            Returns a string that specifies the language of the gpu programs as specified
            in a material script. ie: asm, cg, hlsl, glsl
            </summary>
        </member>
        <member name="P:Engine.Renderer.GpuProgram.Type">
            <summary>
            Gets or sets the program type (only valid before load).
            </summary>
        </member>
        <member name="T:Engine.Renderer.CompositorInstance">
            <summary>
            An instance of a <see cref="P:Engine.Renderer.CompositorInstance.Compositor"/> object for one <see cref="T:Engine.Renderer.Viewport"/>. 
            </summary>
        </member>
        <member name="M:Engine.Renderer.CompositorInstance.OnMaterialSetup(System.UInt32,Engine.Renderer.Material)">
            <summary>
            Notification of when a render target operation involving a material (like
            rendering a quad) is compiled, so that miscelleneous parameters that are different
            per Compositor instance can be set up.
            </summary>
            <param name="passId">
            Pass identifier within Compositor instance, this is 
            speficied by the user by CompositionPass.Identifier.
            </param>
            <param name="material">Material, this may be changed at will and will 
            only affect the current instance of the Compositor, not the global material 
            it was cloned from.
            </param>
        </member>
        <member name="M:Engine.Renderer.CompositorInstance.OnMaterialRender(System.UInt32,Engine.Renderer.Material,System.Boolean@)">
            <summary>
            Notification before a render target operation involving a material (like
            rendering a quad), so that material parameters can be varied.
            </summary>
            <param name="passId">
            Pass identifier within Compositor instance, this is 
            speficied by the user by CompositionPass.Identifier.
            </param>
            <param name="material">Material, this may be changed at will and will 
            only affect the current instance of the Compositor, not the global material 
            it was cloned from.
            </param>
            <param name="skipPass">
            Whether it is necessary to skip this pass.
            </param>
        </member>
        <member name="P:Engine.Renderer.CompositorInstance.Compositor">
            <summary>Gets the source compositor.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositorInstance.Owner">
            <summary>
            Gets owner viewport.
            </summary>
        </member>
        <member name="P:Engine.Renderer.CompositorInstance.Enabled">
            <summary>
            Gets or sets the enabled flag of the item.
            </summary>
        </member>
        <member name="P:Engine.Renderer.CompositorInstance.Technique">
            <summary>
            Gets technique used by this instance.
            </summary>
        </member>
        <member name="T:Engine.Renderer.ParticleSystem">
            <summary>
            Class defining particle system based special effects.
            </summary>
            <remarks>
            <para>
            Particle systems are special effects generators which are based on a 
            number of moving points to create the impression of things like like 
            sparkles, smoke, blood spurts, dust etc.
            </para>
            <para>
            This class simply manages a single collection of particles in world space
            with a shared local origin for emission. The visual aspect of the 
            particles is handled by a <see cref="T:Engine.Renderer.ParticleSystemRenderer"/> instance.
            </para>
            <para>
            Particle systems are created using the SceneManager, never directly.
            In addition, like all subclasses of <see cref="T:Engine.Renderer.MovableObject"/>, the ParticleSystem 
            will only be considered for rendering once it has been attached to a 
            <see cref="T:Engine.Renderer.SceneNode"/>. 
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.ParticleSystem.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.ParticleSystem.SetEmittersEnable(System.Boolean)">
            <summary>
            Sets the Enabled flag to all emitters.
            </summary>
            <param name="enable">Enable flag.</param>
        </member>
        <member name="M:Engine.Renderer.ParticleSystem.UpdateAutomaticQuota">
            <summary>
            
            </summary>
            <returns><b>true</b> if quota has been changed; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.ParticleSystem.IsAlwaysEmitted">
            <summary>
            Returns a value which indicates is in system emitters which will be never turn off.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.TemplateName">
            <summary>Gets the template name.</summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.SpeedFactor">
            <summary>
            Gets or sets a 'iteration interval' on this particle system.
            </summary>
            <remarks>
            <para>
            The default Particle system update interval, based on elapsed frame time,
            will cause different behavior between low frame-rate and high frame-rate. 
            By using this option, you can make the particle system update at
            a fixed interval, keeping the behavior the same no matter what frame-rate 
            is.
            </para>
            <para>
            When iteration interval is set to zero, it means the update occurs based 
            on an elapsed frame time, otherwise each iteration will take place 
            at the given interval, repeating until it has used up all the elapsed 
            frame time.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.ParticleCount">
            <summary>
            Gets the number of individual particles in the system right now.
            </summary>
            <remarks>
            The number of particles active in a system at a point in time depends on 
            the number of emitters, their emission rates, the time-to-live (TTL) each particle is
            given on emission (and whether any affectors modify that TTL) and the maximum
            number of particles allowed in this system at once (particle quota).
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.Emitters">
            <summary>
            Gets the emitters collection. <b>Don't modify.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.Affectors">
            <summary>
            Gets the affectors collection. <b>Don't modify.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.Quota">
            <summary>
            Gets or sets the maximum number of particles this system is allowed to have active at once.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.MaterialName">
            <summary>
            Gets or sets the name of the material to be used for this billboard set.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.Size">
            <summary>
            Gets or sets the default dimensions of the particles in this set.
            </summary>
            <remarks>
            All particles in a set are created with these default dimensions. The set will render most efficiently if
            all the particles in the set are the default size. It is possible to alter the size of individual
            particles at the expense of extra calculation. See the Particle class for more info.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.CullIndividually">
            <summary>
            Gets or sets whether or not particles in this are tested individually for culling.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.Sorted">
            <summary>
            Gets or sets whether particles are sorted relative to the camera.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.LocalSpace">
            <summary>
            Gets or sets whether particles (and any affector effects) remain relative 
            to the node the particle system is attached to.
            </summary>
            <remarks>
            By defalt particles are in world space once emitted, so they are not
            affected by movement in the parent node of the particle system. This
            makes the most sense when dealing with completely independent particles, 
            but if you want to constrain them to follow local motion too, you
            can set this to <b>true</b>.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.ParticleSystem.Renderer">
            <summary>
            Gets the <see cref="T:Engine.Renderer.ParticleSystemRenderer"/> to be used to render this particle system.
            </summary>
            <remarks>
            The main ParticleSystem just manages the creation and movement of 
            particles; they are rendered using functions in <see cref="T:Engine.Renderer.ParticleSystemRenderer"/>
            and the ParticleVisual instances they create.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.ProgressiveMeshVertexReductionQuota">
            <summary>The way to derive the quota of vertices which are reduced at each LOD.</summary>
        </member>
        <member name="F:Engine.Renderer.ProgressiveMeshVertexReductionQuota.Constant">
            <summary>A set number of vertices are removed at each reduction.</summary>
        </member>
        <member name="F:Engine.Renderer.ProgressiveMeshVertexReductionQuota.Proportional">
            <summary>
            A proportion of the remaining number of vertices are removed at each reduction.
            </summary>
        </member>
        <member name="T:Engine.Renderer.SubMesh">
            <summary>
            Defines a part of a complete mesh.
            </summary>
            <remarks>
            <para>
            Meshes which make up the definition of a discrete 3D object
            are made up of potentially multiple parts. This is because
            different parts of the mesh may use different materials or
            use different vertex formats, such that a rendering state
            change is required between them.
            </para>
            <para>
            Like the <see cref="T:Engine.Renderer.Mesh"/> class, instatiations of 3D objects in the scene
            share the SubMesh instances, and have the option of overriding
            their material differences on a per-object basis if required.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.SubMesh.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.SubMesh.ToString">
            <summary>
            Returns a string containing the vertices and indices count of the sub mesh.
            </summary>
            <returns>A string containing the vertices and indices count of the sub mesh.</returns>
        </member>
        <member name="M:Engine.Renderer.SubMesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec2}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the sub mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="texCoords0">The vertices texture coordinates.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.SubMesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the sub mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.SubMesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the sub mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.SubMesh.GetSomeGeometry(Engine.MathEx.Vec3[]@,Engine.MathEx.Vec3[]@,Engine.MathEx.Vec2[]@,System.Int32[]@)">
            <summary>
            Gets the sub mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="texCoords0">The vertices texture coordinates.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.SubMesh.GetSomeGeometry(Engine.MathEx.Vec3[]@,Engine.MathEx.Vec3[]@,System.Int32[]@)">
            <summary>
            Gets the sub mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.SubMesh.GetSomeGeometry(Engine.MathEx.Vec3[]@,System.Int32[]@)">
            <summary>
            Gets the sub mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.SubMesh.AddBoneAssignment(System.Int32,System.Int32,System.Single)">
            <summary>
            Assigns a vertex to a bone with a given weight, for skeletal animation.
            </summary>
            <param name="vertexIndex"></param>
            <param name="boneIndex"></param>
            <param name="weight"></param>
            <remarks>
            This method is only valid after calling setSkeletonName.
            Since this is a one-off process there exists only 'AddBoneAssignment' and
            'ClearBoneAssignments' methods, no 'EditBoneAssignment'. You should not need
            to modify bone assignments during rendering (only the positions of bones) and OGRE
            reserves the right to do some internal data reformatting of this information, depending
            on render system requirements.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.SubMesh.ClearBoneAssignments">
            <summary>
            Removes all bone assignments for this submesh.
            </summary>
            <remarks>
            This method is for assigning weights to the geometry of the <see cref="T:Engine.Renderer.SubMesh"/>.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.SubMesh.MaterialName">
            <summary>
            Gets or sets the name of the <see cref="T:Engine.Renderer.Material"/> which this SubMesh will use.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SubMesh.VertexData">
            <summary>
            Gets or sets the vertex data.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SubMesh.IndexData">
            <summary>
            Gets or sets the index data.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SubMesh.UseSharedVertices">
            <summary>
            Gets or sets a value indicates if this submesh shares vertex data with other meshes 
            or whether it has it's own vertices.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Mesh">
            <summary>
            Resource holding data about 3D mesh.
            </summary>
            <remarks>
            <para>
            This class holds the data used to represent a discrete
            3-dimensional object. Mesh data usually contains more
            than just vertices and triangle information; it also
            includes references to materials (and the faces which use them),
            level-of-detail reduction information, convex hull definition,
            skeleton/bones information, keyframe animation etc.
            However, it is important to note the emphasis on the word
            'discrete' here. This class does not cover the large-scale
            sprawling geometry found in level / landscape data.
            </para>
            <para>
            Multiple world objects can (indeed should) be created from a
            single mesh object - see the <see cref="T:Engine.Renderer.MeshObject"/> class for more info.
            The mesh object will have it's own default
            material properties, but potentially each world instance may
            wish to customise the materials from the original. When the object
            is instantiated into a scene node, the mesh material properties
            will be taken by default but may be changed. These properties
            are actually held at the <see cref="T:Engine.Renderer.SubMesh"/> level since a single mesh may
            have parts with different materials.
            </para>
            <para>
            As described above, because the mesh may have sections of differing
            material properties, a mesh is inherently a compound contruct,
            consisting of one or more <see cref="T:Engine.Renderer.SubMesh"/> objects.
            However, it strongly 'owns' it's SubMeshes such that they
            are loaded / unloaded at the same time. This is contrary to
            the approach taken to hierarchically related (but loosely owned)
            scene nodes, where data is loaded / unloaded separately. Note
            also that mesh sub-sections (when used in an instantiated object)
            share the same scene node as the parent.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Mesh.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Mesh.CreateSubMesh">
            <summary>
            Creates a new SubMesh.
            </summary>
            <summary>
            Method for manually creating geometry for the mesh.
            Note - use with extreme caution - you must be sure that
            you have set up the geometry properly.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Mesh.BuildTangentVectors(Engine.Renderer.VertexElementSemantic,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method builds a set of tangent vectors for a given mesh into a 3D 
            texture coordinate buffer.
            </summary>
            <remarks>
            <para>
            Tangent vectors are vectors representing the local 'X' axis for a given vertex based
            on the orientation of the 2D texture on the geometry. They are built from a combination
            of existing normals, and from the 2D texture coordinates already baked into the model.
            They can be used for a number of things, but most of all they are useful for 
            vertex and fragment programs, when you wish to arrive at a common space for doing
            per-pixel calculations.
            </para>
            <para>
            The prerequisites for calling this method include that the vertex data used by every
            SubMesh has both vertex normals and 2D texture coordinates.
            </para>
            </remarks>
            <param name="targetSemantic">
            The semantic to store the tangents in. Defaults to 
            the explicit tangent binding, but note that this is only usable on more
            modern hardware (Shader Model 2), so if you need portability with older
            cards you should change this to a texture coordinate binding instead.
            </param>
            <param name="sourceTexCoordSet">
            The texture coordinate index which should be used as the source
            of 2D texture coordinates, with which to calculate the tangents.
            </param>
            <param name="index">
            The element index, ie the texture coordinate set which should be used to store the 3D
            coordinates representing a tangent vector per vertex, if targetSemantic is 
            TextureCoordinates. If this already exists, it will be overwritten.
            </param>
            <param name="storeParityInW">
            If <b>true</b>, store tangents as a 4-vector and include parity in w.
            </param>
        </member>
        <member name="M:Engine.Renderer.Mesh.Reload">
            <summary>
            Reloads mesh data from file.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Mesh.Save(System.String)">
            <summary>
            Saves mesh data to file.
            </summary>
            <returns><b>true</b> if the mesh successfully saved; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec2}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="texCoords0">The vertices texture coordinates.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{System.Int32}@,System.Boolean)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="indices">The indices.</param>
            <param name="ignoreSubMeshesWithDisabledCollision">Ignore sub meshes who has property "AllowCollision" is equal <b>false</b>.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(System.Collections.Generic.List{Engine.MathEx.Vec3}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(Engine.MathEx.Vec3[]@,Engine.MathEx.Vec3[]@,Engine.MathEx.Vec2[]@,System.Int32[]@)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="texCoords0">The vertices texture coordinates.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(Engine.MathEx.Vec3[]@,Engine.MathEx.Vec3[]@,System.Int32[]@)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="normals">The vertices normals.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetSomeGeometry(Engine.MathEx.Vec3[]@,System.Int32[]@)">
            <summary>
            Gets the mesh geometry data.
            </summary>
            <param name="positions">The vertices positions.</param>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.IsLodManual">
            <summary>
            Returns true if this mesh is using manual LOD.
            </summary>
            <remarks>
            A mesh can either use automatically generated LOD, or it can use alternative
            meshes as provided by an artist. A mesh can only use either all manual LODs 
            or all generated LODs, not a mixture of both.
            </remarks>
            <returns><b>true</b> if LODs are manual created; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetLodLevels">
            <summary>Returns the the LOD levels array.</summary>
            <returns>The LOD levels array.</returns>
        </member>
        <member name="M:Engine.Renderer.Mesh.GenerateLodLevels(System.Single[],Engine.Renderer.ProgressiveMeshVertexReductionQuota,System.Single)">
            <summary>
            Automatically generates lower level of detail versions of this mesh for use
            when a simpler version of the model is acceptable for rendering.
            </summary>
            <remarks>
            <para>
            There are 2 ways that you can create level-of-detail (LOD) versions of a mesh;
            the first is to call this method, which does fairly extensive calculations to
            work out how to simplify the mesh whilst having the minimum affect on the model.
            The alternative is to actually create simpler versions of the mesh yourself in 
            a modelling tool, and having exported them, tell the 'master' mesh to use these
            alternative meshes for lower detail versions; this is done by calling the 
            createManualLodLevel method.
            </para>
            <para>
            As well as creating the lower detail versions of the mesh, this method will
            also associate them with depth values. As soon as an object is at least as far
            away from the camera as the depth value associated with it's LOD, it will drop 
            to that level of detail. 
            </para>
            </remarks>
            <param name="lodDistances">
            A list of depth values indicating the distances at which new lods should be generated. 
            </param>
            <param name="reductionMethod">
            The way to determine the number of vertices collapsed per LOD.
            </param>
            <param name="reductionValue">
            Meaning depends on reductionMethod, typically either the proportion
            of remaining vertices to collapse or a fixed number of vertices.
            </param>
        </member>
        <member name="M:Engine.Renderer.Mesh.CreateManualLodLevel(System.Single,System.String)">
            <summary>Adds a new manual level-of-detail entry to this Mesh.</summary>
            <remarks>
            As an alternative to generating lower level of detail versions of a mesh, you can
            use your own manually modelled meshes as lower level versions. This lets you 
            have complete control over the LOD, and in addition lets you scale down other
            aspects of the model which cannot be done using the generated method; for example, 
            you could use less detailed materials and / or use less bones in the skeleton if
            this is an animated mesh. Therefore for complex models you are likely to be better off
            modelling your LODs yourself and using this method, whilst for models with fairly
            simple materials and no animation you can just use the generateLodLevels method.
            </remarks>
            <param name="fromDepth">
            Adds a new manual level-of-detail entry to this Mesh.
            </param>
            <param name="meshName">
            The name of the mesh which will be the lower level detail version.
            </param>
        </member>
        <member name="M:Engine.Renderer.Mesh.RemoveLodLevels">
            <summary>Removes all LOD data from this Mesh.</summary>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetIndicesCount(System.Int32)">
            <summary>
            Gets indices count from LOD level.
            </summary>
            <param name="lodIndex">The LOD index.</param>
            <returns>The indices count.</returns>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetAnimation(System.String)">
            <summary>
            Returns the named vertex Animation object.
            </summary>
            <param name="name">The name of the animation.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.CreateAnimation(System.String,System.Single)">
            <summary>
            Creates a new Animation object for vertex animating this mesh.
            </summary>
            <param name="name">The name of this animation.</param>
            <param name="length">The length of the animation in seconds.</param>
            <returns>The animation.</returns>
        </member>
        <member name="M:Engine.Renderer.Mesh.GetPose(System.String)">
            <summary>
            Returns the named Pose object.
            </summary>
            <param name="name">The name of the pose.</param>
        </member>
        <member name="M:Engine.Renderer.Mesh.CreatePose(System.UInt16,System.String)">
            <summary>
            Creates a new Pose object for vertex animating this mesh.
            </summary>
            <param name="target">Index of target submesh.</param>
            <param name="name">The name of this pose.</param>
            <returns>The pose.</returns>
        </member>
        <member name="M:Engine.Renderer.Mesh.RemoveAnimation(System.String)">
            <summary>
            Removes vertex Animation from this mesh.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Mesh.PrepareForShadowVolume">
            <summary>
            This method prepares the mesh for generating a renderable shadow volume.
            </summary>
            <remarks>
            <para>
            Preparing a mesh to generate a shadow volume involves firstly ensuring that the 
            vertex buffer containing the positions for the mesh is a standalone vertex buffer,
            with no other components in it. This method will therefore break apart any existing
            vertex buffers this mesh holds if position is sharing a vertex buffer. 
            Secondly, it will double the size of this vertex buffer so that there are 2 copies of 
            the position data for the mesh. The first half is used for the original, and the second 
            half is used for the 'extruded' version of the mesh. The vertex count of the main 
            <see cref="T:Engine.Renderer.VertexData"/> used to render the mesh will remain the same though, 
            so as not to add any overhead to regular rendering of the object.
            Both copies of the position are required in one buffer because shadow volumes stretch 
            from the original mesh to the extruded version. 
            </para>
            <para>
            Because shadow volumes are rendered in turn, no additional
            index buffer space is allocated by this method, a shared index buffer allocated by the
            shadow rendering algorithm is used for addressing this extended vertex buffer.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Mesh.Name">
            <summary>
            Gets the mesh file name.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.SubMeshes">
            <summary>
            Gets the sub meshes collection. <b>Don't modify.</b>
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.SharedVertexData">
            <summary>
            Gets the shared vertex data. <b>Don't modify.</b>
            </summary>
            <remarks>
            <para>
            This vertex data can be shared among multiple submeshes. SubMeshes may not have
            their own VertexData, they may share this one.
            </para>
            <para>
            The use of shared or non-shared buffers is determined when
            model data is converted to the OGRE .mesh format.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Mesh.EdgeList">
            <summary>
            Gets or sets whether this mesh has an attached edge list.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.Bounds">
            <summary>
            Gets the mesh bounds.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.BoundingSphereRadius">
            <summary>
            Gets the radius of the bounding sphere surrounding this mesh.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.VertexBufferUsage">
            <summary>
            Gets the usage setting for this meshes vertex buffers.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.IndexBufferUsage">
            <summary>
            Gets the usage setting for this meshes index buffers.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.Skeleton">
            <summary>
            Gets a linked Skeleton.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.Animations">
            <summary>
            Gets the animation list.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.Poses">
            <summary>
            Gets the pose list.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Mesh.LodUsage">
            <summary>A way of recording the way each LODs is recorded this Mesh.</summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.LodUsage.FromDepth">
            <summary>Gets the Z value from which this LOD will apply.</summary>
        </member>
        <member name="P:Engine.Renderer.Mesh.LodUsage.ManualName">
            <summary>
            Only relevant if <see cref="M:Engine.Renderer.Mesh.IsLodManual"/> is <b>true</b>, 
            the name of the alternative mesh to use.
            </summary>
        </member>
        <member name="T:Engine.Renderer.IndexData">
            <summary>
            Summary class collecting together index data source information.
            </summary>
        </member>
        <member name="M:Engine.Renderer.IndexData.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.IndexData.SetIndexBuffer(Engine.Renderer.HardwareIndexBuffer,System.Boolean)">
            <summary>
            Sets the index buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="shouldDispose">Should dispose buffer when vertex data will be disposed.</param>
        </member>
        <member name="M:Engine.Renderer.IndexData.OptimizeVertexCacheTriangleList">
            <summary>
            Re-order the indexes in this index data structure to be more
            vertex cache friendly; that is to re-use the same vertices as close
            together as possible. 
            </summary>
            <remarks>
            Can only be used for index data which consists of triangle lists.
            It would in fact be pointless to use it on triangle strips or fans
            in any case.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.IndexData.Clone(System.Boolean)">
            <summary>
            Clones this index data, potentially including replicating the index buffer.
            </summary>
            <param name="copyData">Need copy data or not.</param>
            <returns>The cloned index data.</returns>
            <remarks>
            The caller is expected to delete the returned pointer when finished.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.IndexData.Clone">
            <summary>
            Clones this index data, potentially including replicating the index buffer.
            </summary>
            <returns>The cloned index data.</returns>
            <remarks>
            The caller is expected to delete the returned pointer when finished.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.IndexData.GetIndices(System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the indices list.
            </summary>
            <param name="indices">The indices.</param>
        </member>
        <member name="M:Engine.Renderer.IndexData.GetIndices">
            <summary>
            Generates the indices array.
            </summary>
        </member>
        <member name="M:Engine.Renderer.IndexData.CreateFromList(System.Collections.Generic.List{System.Int32},System.Boolean)">
            <summary>
            Creates the index data from list.
            </summary>
            <param name="indices">The indices.</param>
            <param name="optimizeVertexCache">
            Re-order the indexes in this index data structure to be more
            vertex cache friendly; that is to re-use the same vertices as close
            together as possible. 
            </param>
        </member>
        <member name="M:Engine.Renderer.IndexData.CreateFromArray(System.Int32*,System.Int32,System.Boolean)">
            <summary>
            Creates the index data from array.
            </summary>
            <param name="indices">The indices.</param>
            <param name="length">The number of indices to copy.</param>
            <param name="optimizeVertexCache">
            Re-order the indexes in this index data structure to be more
            vertex cache friendly; that is to re-use the same vertices as close
            together as possible. 
            </param>
        </member>
        <member name="M:Engine.Renderer.IndexData.CreateFromArray(System.Int32[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates the index data from array.
            </summary>
            <param name="indices">The indices.</param>
            <param name="startIndex">The index in the indices at which data begins.</param>
            <param name="length">The number of indices to copy.</param>
            <param name="optimizeVertexCache">
            Re-order the indexes in this index data structure to be more
            vertex cache friendly; that is to re-use the same vertices as close
            together as possible. 
            </param>
        </member>
        <member name="P:Engine.Renderer.IndexData.IndexBuffer">
            <summary>
            Gets the index buffer.
            </summary>
        </member>
        <member name="P:Engine.Renderer.IndexData.IndexStart">
            <summary>
            Gets or sets index in the buffer to start from for this operation.
            </summary>
        </member>
        <member name="P:Engine.Renderer.IndexData.IndexCount">
            <summary>
            Gets or sets The number of indexes to use from the buffer.
            </summary>
        </member>
        <member name="T:Engine.Renderer.CompositorManager">
            <summary>
            Class for managing Compositor settings for Engine. Compositors provide the means
            to flexibly "composite" the final rendering result from multiple scene renders
            and intermediate operations like rendering fullscreen quads. This makes
            it possible to apply postfilter effects, HDRI postprocessing, and shadow
            effects to a <see cref="T:Engine.Renderer.Viewport"/>.
            </summary>
            <remarks>
            <para>
            When loaded from a script, a Compositor is in an 'unloaded' state and only stores the settings
            required. It does not at that stage load any textures. This is because the material settings may be
            loaded 'en masse' from bulk material script files, but only a subset will actually be required.
            </para>
            <para>
            Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or
            archive added to the resource paths/archives. See ResourceManager for details.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.CompositorManager.Create(System.String)">
            <summary>Creates a new compositor.</summary>
            <param name="name">The compositor name.</param>
            <returns>The compositor.</returns>
        </member>
        <member name="M:Engine.Renderer.CompositorManager.GetByName(System.String)">
            <summary>Returns compositor by name.</summary>
            <param name="name">The compositor name.</param>
            <returns><see cref="P:Engine.Renderer.CompositorManager.Compositor"/> if he exists; otherwise, <b>null</b>.</returns>
        </member>
        <member name="P:Engine.Renderer.CompositorManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.CompositorManager"/>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.SkeletonManager">
            <summary>
            Handles the management of skeleton resources.
            </summary>
            <remarks>
            This class deals with the runtime management of
            skeleton data; like other resource managers it handles
            the creation of resources (in this case skeleton data),
            working within a fixed memory budget.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.SkeletonManager.Load(System.String)">
            <summary>Loads skeleton or returns already loaded skeleton.</summary>
            <param name="name">The skeleton name.</param>
            <returns><see cref="T:Engine.Renderer.Skeleton"/> if the skeleton has been loaded; otherwise, <b>null</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.SkeletonManager.GetUniqueName(System.String)">
            <summary>
            Returns the generated the unique skeleton name with prefix.
            </summary>
            <param name="prefix">The name prefix.</param>
            <returns>The generated unique the skeleton name with prefix.</returns>
        </member>
        <member name="M:Engine.Renderer.SkeletonManager.DisposeLoadedSkeletons">
            <summary>
            Disposed all loaded skeletons.
            </summary>
        </member>
        <member name="M:Engine.Renderer.SkeletonManager.Create(System.String)">
            <summary>
            Creates a new blank resource, but does not immediately load it.
            </summary>
            <remarks>
            Resource managers handle disparate types of resources, so if you want
            to get at the detailed interface of this resource, you'll have to 
            cast the result to the subclass you know you're creating.
            </remarks>
            <param name="name">The name to give the new skeleton.</param>
        </member>
        <member name="M:Engine.Renderer.SkeletonManager.SaveToFile(Engine.Renderer.Skeleton,System.String)">
            <summary>
            Exports a skeleton to the file specified. 
            </summary>
            <remarks>
            This method takes an externally created Skeleton object, and exports both it
            and animations it uses to a .skeleton file.
            </remarks>
            <param name="skeleton">The skeleton.</param>
            <param name="realFileName">The destination filename.</param>
            <returns><b>true</b> if the skeleton has been saved; otherwise, <b>false</b>.</returns>
        </member>
        <member name="P:Engine.Renderer.SkeletonManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.SkeletonManager"/>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RenderSystemCapabilities">
            <summary>
            Singleton class for storing the capabilities of the graphics card. 
            </summary>
            <remarks>
            This class stores the capabilities of the graphics card.  This
            information is set by the individual render systems.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.NumWorldMatrices">
            <summary>The number of world matricies available.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.NumTextureUnits">
            <summary>The number of texture units available.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.StencilBufferBitDepth">
            <summary>The stencil buffer bit depth.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.NumVertexBlendMatrices">
            <summary>The number of matrices available for hardware blending.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VertexProgramConstantFloatCount">
            <summary>The number of floating-point constants vertex programs support.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VertexProgramConstantIntCount">
            <summary>The number of integer constants vertex programs support.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VertexProgramConstantBoolCount">
            <summary>The number of boolean constants vertex programs support.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.FragmentProgramConstantFloatCount">
            <summary>The number of floating-point constants fragment programs support.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.FragmentProgramConstantIntCount">
            <summary>The number of integer constants fragment programs support.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.FragmentProgramConstantBoolCount">
            <summary>The number of boolean constants fragment programs support.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.NumMultiRenderTargets">
            <summary>The number of simultaneous render targets supported.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.MaxPointSize">
            <summary>The maximum point size.</summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.AutoMipmap">
            <summary>
            Supports generating mipmaps in hardware.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.Blending">
            <summary>
            Supports blending.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.Anisotropy">
            <summary>
            Supports anisotropic texture filtering.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.DOT3">
            <summary>
            Supports fixed-function DOT3 texture blend.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.CubeMapping">
            <summary>
            Supports cube mapping.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.HardwareStencil">
            <summary>
            Supports hardware stencil buffer.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VBO">
            <summary>
            Supports hardware vertex and index buffers.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VertexProgram">
            <summary>
            Supports vertex programs (vertex shaders).
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.FragmentProgram">
            <summary>
            Supports fragment programs (pixel shaders).
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.TextureCompression">
            <summary>
            Supports compressed textures.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.TextureCompressionDXT">
            <summary>
            Supports compressed textures in the DXT/ST3C formats.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.TextureCompressionVTC">
            <summary>
            Supports compressed textures in the VTC format.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.ScissorTest">
            <summary>
            Supports performing a scissor test to exclude areas of the screen.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.TwoSidedStencil">
            <summary>
            Supports separate stencil updates for both front and back faces.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.StencilWrap">
            <summary>
            Supports wrapping the stencil value at the range extremeties.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.HardwareOcclusion">
            <summary>
            Supports hardware occlusion queries.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.UserClipPlanes">
            <summary>
            Supports user clipping planes.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VertexFormatUByte4">
            <summary>
            Supports the VET_UBYTE4 vertex element type.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.InfiniteFarPlane">
            <summary>
            Supports infinite far plane projection.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.HardwareRenderToTexture">
            <summary>
            Supports hardware render-to-texture (bigger than framebuffer).
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.TextureFloat">
            <summary>
            Supports float textures and render targets.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.NonPowerOf2Textures">
            <summary>
            Supports non-power of two textures.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.Texture3D">
            <summary>
            Supports 3d (volume) textures.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.PointSprites">
            <summary>
            Supports basic point sprite rendering.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.PointExtendedParameters">
            <summary>
            Supports extra point parameters (minsize, maxsize, attenuation).
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.VertexTextureFetch">
            <summary>
            Supports vertex texture fetch.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.MipMapLODBias">
            <summary>
            Supports mipmap LOD biasing.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.MRTDifferentBitDepths">
            <summary>
            Supports MRTs with different bit depths.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystemCapabilities.AlphaToCoverage">
            <summary>
            Supports Alpha to Coverage (A2C).
            </summary>
        </member>
        <member name="T:Engine.Renderer.DummyMovableObject">
            <summary>Defines the class for a special internal purposes.</summary>
        </member>
        <member name="M:Engine.Renderer.DummyMovableObject.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="T:Engine.Renderer.RendererWorld">
            <summary>The root class of the Renderer system.</summary>
        </member>
        <member name="M:Engine.Renderer.RendererWorld.SetVerticalSync(System.Boolean)">
            <summary>Gets or sets the vertical sync flag.</summary>
            <param name="value">The vertical sync flag.</param>
        </member>
        <member name="M:Engine.Renderer.RendererWorld.DisableAllCompositors">
            <summary>Disposes all compositors.</summary>
        </member>
        <member name="M:Engine.Renderer.RendererWorld.CreateRenderQueueInvocationSequence(System.String)">
            <summary>
            Creates a new RenderQueueInvocationSequence, useful for linking to
            <see cref="T:Engine.Renderer.Viewport"/> instances to perform custom rendering.
            </summary>
            <param name="name">The sequence name.</param>
            <returns>The new RenderQueueInvocationSequence object.</returns>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.ColorDepth">
            <summary>Gets or sets the color depth.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.ExternalWindowHandle">
            <summary>Gets or sets the external window handle.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.FullSceneAntialiasing">
            <summary>Gets or sets the full-scene antialiasing flag.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.RendererWorld"/>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.RenderWindow">
            <summary>Gets the render window.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.DefaultCamera">
            <summary>Gets the default camera.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.DefaultViewport">
            <summary>Gets the default viewport.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.ForceEnableCompositors">
            <summary>Gets or sets the force enable compositors flag.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.DriverName">
            <summary>Gets the renderer driver name.</summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.Statistics">
            <summary>
            Gets the render statistics.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.FrameRenderTime">
            <summary>
            Gets frame render time.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RendererWorld.RenderTargets">
            <summary>
            Gets the render targets collection.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RendererWorld.MaxPixelShadersVersions">
            <summary>
            Defines enumeration for configurate maximum pixel shaders supported.
            </summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.RecommendedSetting">
            <summary>No limitation</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS0">
            <summary>No pixel shaders</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS11">
            <summary>Pixel shaders 1.1</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS12">
            <summary>Pixel shaders 1.2</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS13">
            <summary>Pixel shaders 1.3</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS14">
            <summary>Pixel shaders 1.4</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS20">
            <summary>Pixel shaders 2.0</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS20a">
            <summary>Pixel shaders 2.0a</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS20b">
            <summary>Pixel shaders 2.0b</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxPixelShadersVersions.PS30">
            <summary>Pixel shaders 3.0</summary>
        </member>
        <member name="T:Engine.Renderer.RendererWorld.MaxVertexShadersVersions">
            <summary>
            Defines enumeration for configurate maximum vertex shaders supported.
            </summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxVertexShadersVersions.RecommendedSetting">
            <summary>No limitation</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxVertexShadersVersions.VS0">
            <summary>No vertex shaders</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxVertexShadersVersions.VS11">
            <summary>Vertex shaders 1.1</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxVertexShadersVersions.VS20">
            <summary>Vertex shaders 2.0</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxVertexShadersVersions.VS20a">
            <summary>Vertex shaders 2.0a</summary>
        </member>
        <member name="F:Engine.Renderer.RendererWorld.MaxVertexShadersVersions.VS30">
            <summary>Vertex shaders 3</summary>
        </member>
        <member name="T:Engine.Renderer.GpuProgramParameters">
            <summary>
            Collects together the program parameters used for a GpuProgram.
            </summary>
            <remarks>
            <para>
            Gpu program state includes constant parameters used by the program, and
            bindings to render system state which is propagated into the constants 
            by the engine automatically if requested.
            </para>
            <para>
            GpuProgramParameters objects should be created through the <see cref="T:Engine.Renderer.GpuProgramManager"/> 
            and may be shared between multiple <see cref="T:Engine.Renderer.GpuProgram"/> instances. For this reason they
            are managed using a shared pointer, which will ensure they are automatically
            deleted when no program is using them anymore.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedConstant(System.String,System.Single)">
            <summary>
            Sets a single value constant floating-point parameter to the program.
            </summary>
            <remarks>
            <para>
            Different types of GPU programs support different types of constant parameters.
            For example, it's relatively common to find that vertex programs only support
            floating point constants, and that fragment programs only support integer (fixed point)
            parameters. This can vary depending on the program version supported by the
            graphics card being used. You should consult the documentation for the type of
            low level program you are using, or alternatively use the methods
            provided on RenderSystemCapabilities to determine the options.
            </para>
            <para>
            Another possible limitation is that some systems only allow constants to be set
            on certain boundaries, e.g. in sets of 4 values for example. Again, see
            RenderSystemCapabilities for full details.
            </para>
            <para>
            His named option will only work if you are using a parameters object created
            from a high-level program (HighLevelGpuProgram).
            deleted when no program is using them anymore.
            </para>
            </remarks>
            <param name="name">The constant name.</param>
            <param name="value">The value.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedConstant(System.String,Engine.MathEx.Vec3)">
            <summary>
            Sets a Vec3 parameter to the program.
            </summary>
            <param name="name">The constant name.</param>
            <param name="value">The value.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedConstant(System.String,Engine.MathEx.Vec4)">
            <summary>
            Sets a Vec4 parameter to the program.
            </summary>
            <param name="name">The constant name.</param>
            <param name="value">The value.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedConstant(System.String,Engine.MathEx.Mat4)">
            <summary>
            Sets a Mat4 parameter to the program.
            </summary>
            <param name="name">The constant name.</param>
            <param name="value">The value.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedConstant(System.String,Engine.MathEx.Vec4[])">
            <summary>
            Sets a multiple value constant floating-point parameter to the program.
            </summary>
            <remarks>
            <para>
            Some systems only allow constants to be set on certain boundaries, 
            e.g. in sets of 4 values for example. The 'multiple' parameter allows
            you to control that although you should only change it if you know
            your chosen language supports that (at the time of writing, only
            GLSL allows constants which are not a multiple of 4).
            </para>
            <para>
            This named option will only work if you are using a parameters object created
            from a high-level program (HighLevelGpuProgram).
            </para>
            </remarks>
            <param name="name">The name of the parameter.</param>
            <param name="value">The array of values.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedAutoConstant(System.String,Engine.Renderer.GpuProgramParameters.AutoConstantType,System.Int32)">
            <summary>
            Sets up a constant which will automatically be updated by the system.
            </summary>
            <remarks>
            <para>
            Vertex and fragment programs often need parameters which are to do with the
            current render state, or particular values which may very well change over time,
            and often between objects which are being rendered. This feature allows you 
            to set up a certain number of predefined parameter mappings that are kept up to 
            date for you.
            </para>
            <para>
            This named option will only work if you are using a parameters object created
            from a high-level program.
            </para>
            </remarks>
            <param name="name">The name of the parameter.</param>
            <param name="constantType">The type of automatic constant to set.</param>
            <param name="extraInfo">
            If the constant type needs more information (like a light index) put it here.
            </param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedAutoConstant(System.String,Engine.Renderer.GpuProgramParameters.AutoConstantType)">
            <summary>
            Sets up a constant which will automatically be updated by the system.
            </summary>
            <remarks>
            <para>
            Vertex and fragment programs often need parameters which are to do with the
            current render state, or particular values which may very well change over time,
            and often between objects which are being rendered. This feature allows you 
            to set up a certain number of predefined parameter mappings that are kept up to 
            date for you.
            </para>
            <para>
            This named option will only work if you are using a parameters object created
            from a high-level program.
            </para>
            </remarks>
            <param name="name">The name of the parameter.</param>
            <param name="constantType">The type of automatic constant to set.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.GpuProgramParameters.SetNamedAutoConstantFloat(System.String,Engine.Renderer.GpuProgramParameters.AutoConstantType,System.Single)">
            <summary>
            Sets up a constant which will automatically be updated by the system.
            </summary>
            <remarks>
            <para>
            Vertex and fragment programs often need parameters which are to do with the
            current render state, or particular values which may very well change over time,
            and often between objects which are being rendered. This feature allows you 
            to set up a certain number of predefined parameter mappings that are kept up to 
            date for you.
            </para>
            <para>
            This named option will only work if you are using a parameters object created
            from a high-level program.
            </para>
            </remarks>
            <param name="name">The name of the parameter.</param>
            <param name="constantType">The type of automatic constant to set.</param>
            <param name="data">If the constant type needs more information put it here.</param>
            <returns><b>true</b> if the contant is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_WORLD_MATRIX">
            The current world matrix
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_WORLD_MATRIX">
            The current world matrix, inverted
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TRANSPOSE_WORLD_MATRIX">
            Provides transpose of world matrix.
            			Equivalent to RenderMonkey's "WorldTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TRANSPOSE_WORLD_MATRIX">
            The current world matrix, inverted and transposed
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_WORLD_MATRIX_ARRAY_3x4">
            The current array of world matrices, as a 3x4 matrix, used for blending
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_WORLD_MATRIX_ARRAY">
            The current array of world matrices, used for blending
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEW_MATRIX">
            The current view matrix
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_VIEW_MATRIX">
            The current view matrix, inverted
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TRANSPOSE_VIEW_MATRIX">
            Provides transpose of view matrix.
            			Equivalent to RenderMonkey's "ViewTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TRANSPOSE_VIEW_MATRIX">
            Provides inverse transpose of view matrix.
            			Equivalent to RenderMonkey's "ViewInverseTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_PROJECTION_MATRIX">
            The current projection matrix
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_PROJECTION_MATRIX">
            Provides inverse of projection matrix.
            			Equivalent to RenderMonkey's "ProjectionInverse".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TRANSPOSE_PROJECTION_MATRIX">
            Provides transpose of projection matrix.
            			Equivalent to RenderMonkey's "ProjectionTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX">
            Provides inverse transpose of projection matrix.
            			Equivalent to RenderMonkey's "ProjectionInverseTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEWPROJ_MATRIX">
            The current view and projection matrices concatenated
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_VIEWPROJ_MATRIX">
            Provides inverse of concatenated view and projection matrices.
            			Equivalent to RenderMonkey's "ViewProjectionInverse".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TRANSPOSE_VIEWPROJ_MATRIX">
            Provides transpose of concatenated view and projection matrices.
            			Equivalent to RenderMonkey's "ViewProjectionTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX">
            Provides inverse transpose of concatenated view and projection matrices.
            			Equivalent to RenderMonkey's "ViewProjectionInverseTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_WORLDVIEW_MATRIX">
            The current world and view matrices concatenated
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_WORLDVIEW_MATRIX">
            The current world and view matrices concatenated, then inverted
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TRANSPOSE_WORLDVIEW_MATRIX">
            Provides transpose of concatenated world and view matrices.
            				Equivalent to RenderMonkey's "WorldViewTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX">
            The current world and view matrices concatenated, then inverted and transposed
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_WORLDVIEWPROJ_MATRIX">
            The current world, view and projection matrices concatenated
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_WORLDVIEWPROJ_MATRIX">
            Provides inverse of concatenated world, view and projection matrices.
            			Equivalent to RenderMonkey's "WorldViewProjectionInverse".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX">
            Provides transpose of concatenated world, view and projection matrices.
            			Equivalent to RenderMonkey's "WorldViewProjectionTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX">
            Provides inverse transpose of concatenated world, view and projection
            			matrices. Equivalent to RenderMonkey's "WorldViewProjectionInverseTranspose".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_RENDER_TARGET_FLIPPING">
            render target related values
            -1 if requires texture flipping, +1 otherwise. It's useful when you bypassed
            			projection matrix transform, still able use this value to adjust transformed y position.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_FOG_COLOUR">
            Fog colour
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_FOG_PARAMS">
            Fog params: density, linear start, linear end, 1/(end-start)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SURFACE_AMBIENT_COLOUR">
            Surface ambient colour, as set in Pass::setAmbient
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SURFACE_DIFFUSE_COLOUR">
            Surface diffuse colour, as set in Pass::setDiffuse
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SURFACE_SPECULAR_COLOUR">
            Surface specular colour, as set in Pass::setSpecular
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SURFACE_EMISSIVE_COLOUR">
            Surface emissive colour, as set in Pass::setSelfIllumination
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SURFACE_SHININESS">
            Surface shininess, as set in Pass::setShininess
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_COUNT">
            The number of active light sources (better than gl_MaxLights)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_AMBIENT_LIGHT_COLOUR">
            The ambient light colour set in the scene
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIFFUSE_COLOUR">
            Light diffuse colour (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_SPECULAR_COLOUR">
            Light specular colour (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_ATTENUATION">
            Light attenuation parameters, Vector4(range, constant, linear, quadric)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SPOTLIGHT_PARAMS">
            Spotlight parameters, Vector4(innerFactor, outerFactor, falloff, isSpot)
            				innerFactor and outerFactor are cos(angle/2)
            				The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
            				Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POSITION">
            A light position in world space (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POSITION_OBJECT_SPACE">
            A light position in object space (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POSITION_VIEW_SPACE">
            A light position in view space (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIRECTION">
            A light direction in world space (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIRECTION_OBJECT_SPACE">
            A light direction in object space (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIRECTION_VIEW_SPACE">
            A light direction in view space (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DISTANCE_OBJECT_SPACE">
            The distance of the light from the center of the object
            				a useful approximation as an alternative to per-vertex distance
            				calculations.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POWER_SCALE">
            Light power level, a single scalar as set in Light::setPowerScale  (index determined by setAutoConstant call) 
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED">
            Light diffuse colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED">
            Light specular colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIFFUSE_COLOUR_ARRAY">
            Array of light diffuse colours (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_SPECULAR_COLOUR_ARRAY">
            Array of light specular colours (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY">
            Array of light diffuse colours scaled by light power (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY">
            Array of light specular colours scaled by light power (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_ATTENUATION_ARRAY">
            Array of light attenuation parameters, Vector4(range, constant, linear, quadric) (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POSITION_ARRAY">
            Array of light positions in world space (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY">
            Array of light positions in object space (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY">
            Array of light positions in view space (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIRECTION_ARRAY">
            Array of light directions in world space (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY">
            Array of light directions in object space (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY">
            Array of light directions in view space (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY">
            Array of distances of the lights from the center of the object
            			a useful approximation as an alternative to per-vertex distance
            			calculations. (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_POWER_SCALE_ARRAY">
            Array of light power levels, a single scalar as set in Light::setPowerScale 
            			 (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SPOTLIGHT_PARAMS_ARRAY">
            Spotlight parameters array of Vector4(innerFactor, outerFactor, falloff, isSpot)
            			innerFactor and outerFactor are cos(angle/2)
            			The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
            			Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively.
            			(count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_DERIVED_AMBIENT_LIGHT_COLOUR">
            The derived ambient light colour, with 'r', 'g', 'b' components filled with
            				 product of surface ambient colour and ambient light colour, respectively,
            				 and 'a' component filled with surface ambient alpha component.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_DERIVED_SCENE_COLOUR">
            The derived scene colour, with 'r', 'g' and 'b' components filled with sum
            				 of derived ambient light colour and surface emissive colour, respectively,
            				 and 'a' component filled with surface diffuse alpha component.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_DERIVED_LIGHT_DIFFUSE_COLOUR">
            The derived light diffuse colour (index determined by setAutoConstant call),
            				 with 'r', 'g' and 'b' components filled with product of surface diffuse colour,
            			light power scale and light diffuse colour, respectively, and 'a' component filled with surface
            				 diffuse alpha component.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_DERIVED_LIGHT_SPECULAR_COLOUR">
            The derived light specular colour (index determined by setAutoConstant call),
            				 with 'r', 'g' and 'b' components filled with product of surface specular colour
            				 and light specular colour, respectively, and 'a' component filled with surface
            				 specular alpha component.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY">
            Array of derived light diffuse colours (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY">
            Array of derived light specular colours (count set by extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_NUMBER">
            The absolute light number of a local light index. Each pass may have
            				a number of lights passed to it, and each of these lights will have
            				an index in the overall light list, which will differ from the local
            				light index due to factors like setStartLight and setIteratePerLight.
            				This binding provides the global light index for a local index.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LIGHT_CASTS_SHADOWS">
            Returns (int) 1 if the  given light casts shadows, 0 otherwise (index set in extra param)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SHADOW_EXTRUSION_DISTANCE">
            The distance a shadow volume should be extruded when using
            			    finite extrusion programs.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_CAMERA_POSITION">
            The current camera's position in world space
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_CAMERA_POSITION_OBJECT_SPACE">
            The current camera's position in object space 
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXTURE_VIEWPROJ_MATRIX">
            The view/projection matrix of the assigned texture projection frustum
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY">
            Array of view/projection matrices of the first n texture projection frustums
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXTURE_WORLDVIEWPROJ_MATRIX">
            The view/projection matrix of the assigned texture projection frustum, 
            				combined with the current world matrix
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY">
            Array of world/view/projection matrices of the first n texture projection frustums
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SPOTLIGHT_VIEWPROJ_MATRIX">
            The view/projection matrix of a given spotlight
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX">
            The view/projection matrix of a given spotlight projection frustum, 
            			combined with the current world matrix
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_CUSTOM">
            A custom parameter which will come from the renderable, using 'data' as the identifier
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME">
            provides current elapsed time
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME_0_X">
            Single float value, which repeats itself based on given as
            			parameter "cycle time". Equivalent to RenderMonkey's "Time0_X".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_COSTIME_0_X">
            Cosine of "Time0_X". Equivalent to RenderMonkey's "CosTime0_X".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SINTIME_0_X">
            Sine of "Time0_X". Equivalent to RenderMonkey's "SinTime0_X".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TANTIME_0_X">
            Tangent of "Time0_X". Equivalent to RenderMonkey's "TanTime0_X".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME_0_X_PACKED">
            Vector of "Time0_X", "SinTime0_X", "CosTime0_X", 
            			"TanTime0_X". Equivalent to RenderMonkey's "Time0_X_Packed".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME_0_1">
            Single float value, which represents scaled time value [0..1],
            			which repeats itself based on given as parameter "cycle time".
            			Equivalent to RenderMonkey's "Time0_1".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_COSTIME_0_1">
            Cosine of "Time0_1". Equivalent to RenderMonkey's "CosTime0_1".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SINTIME_0_1">
            Sine of "Time0_1". Equivalent to RenderMonkey's "SinTime0_1".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TANTIME_0_1">
            Tangent of "Time0_1". Equivalent to RenderMonkey's "TanTime0_1".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME_0_1_PACKED">
            Vector of "Time0_1", "SinTime0_1", "CosTime0_1",
            			"TanTime0_1". Equivalent to RenderMonkey's "Time0_1_Packed".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME_0_2PI">
            Single float value, which represents scaled time value [0..2*Pi],
            			which repeats itself based on given as parameter "cycle time".
            			Equivalent to RenderMonkey's "Time0_2PI".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_COSTIME_0_2PI">
            Cosine of "Time0_2PI". Equivalent to RenderMonkey's "CosTime0_2PI".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SINTIME_0_2PI">
            Sine of "Time0_2PI". Equivalent to RenderMonkey's "SinTime0_2PI".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TANTIME_0_2PI">
            Tangent of "Time0_2PI". Equivalent to RenderMonkey's "TanTime0_2PI".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TIME_0_2PI_PACKED">
            Vector of "Time0_2PI", "SinTime0_2PI", "CosTime0_2PI",
            			"TanTime0_2PI". Equivalent to RenderMonkey's "Time0_2PI_Packed".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_FRAME_TIME">
            provides the scaled frame time, returned as a floating point value.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_FPS">
            provides the calculated frames per second, returned as a floating point value.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEWPORT_WIDTH">
            viewport-related values
            Current viewport width (in pixels) as floating point value.
            			Equivalent to RenderMonkey's "ViewportWidth".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEWPORT_HEIGHT">
            Current viewport height (in pixels) as floating point value.
            			Equivalent to RenderMonkey's "ViewportHeight".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_VIEWPORT_WIDTH">
            This variable represents 1.0/ViewportWidth. 
            			Equivalent to RenderMonkey's "ViewportWidthInverse".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_VIEWPORT_HEIGHT">
            This variable represents 1.0/ViewportHeight.
            			Equivalent to RenderMonkey's "ViewportHeightInverse".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEWPORT_SIZE">
            Packed of "ViewportWidth", "ViewportHeight", "ViewportWidthInverse",
            			"ViewportHeightInverse".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEW_DIRECTION">
            view parameters
            This variable provides the view direction vector (world space).
            			Equivalent to RenderMonkey's "ViewDirection".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEW_SIDE_VECTOR">
            This variable provides the view side vector (world space).
            			Equivalent to RenderMonkey's "ViewSideVector".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_VIEW_UP_VECTOR">
            This variable provides the view up vector (world space).
            			Equivalent to RenderMonkey's "ViewUpVector".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_FOV">
            This variable provides the field of view as a floating point value.
            			Equivalent to RenderMonkey's "FOV".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_NEAR_CLIP_DISTANCE">
            This variable provides the near clip distance as a floating point value.
            			Equivalent to RenderMonkey's "NearClipPlane".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_FAR_CLIP_DISTANCE">
            This variable provides the far clip distance as a floating point value.
            			Equivalent to RenderMonkey's "FarClipPlane".
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_PASS_NUMBER">
            provides the pass index number within the technique
            				 of the active materil.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_PASS_ITERATION_NUMBER">
            provides the current iteration number of the pass. The iteration
            				 number is the number of times the current render operation has
            				 been drawn for the active pass.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_ANIMATION_PARAMETRIC">
            Provides a parametric animation value [0..1], only available
            				where the renderable specifically implements it.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXEL_OFFSETS">
            Provides the texel offsets required by this rendersystem to map
            				texels to pixels. Packed as 
            				float4(absoluteHorizontalOffset, absoluteVerticalOffset, 
            					horizontalOffset / viewportWidth, verticalOffset / viewportHeight)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SCENE_DEPTH_RANGE">
            Provides information about the depth range of the scene as viewed
            				from the current camera. 
            				Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SHADOW_SCENE_DEPTH_RANGE">
            Provides information about the depth range of the scene as viewed
            			from a given shadow camera. Requires an index parameter which maps
            			to a light index relative to the current light list.
            			Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_SHADOW_COLOUR">
            Provides the fixed shadow colour as configured via SceneManager::setShadowColour;
            				useful for integrated modulative shadows.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXTURE_SIZE">
            Provides texture size of the texture unit (index determined by setAutoConstant
            				 call). Packed as float4(width, height, depth, 1)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_INVERSE_TEXTURE_SIZE">
            Provides inverse texture size of the texture unit (index determined by setAutoConstant
            				 call). Packed as float4(1 / width, 1 / height, 1 / depth, 1)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_PACKED_TEXTURE_SIZE">
            Provides packed texture size of the texture unit (index determined by setAutoConstant
            				 call). Packed as float4(width, height, 1 / width, 1 / height)
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_TEXTURE_MATRIX">
            Provides the current transform matrix of the texture unit (index determined by setAutoConstant
            				call), as seen by the fixed-function pipeline. 
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LOD_CAMERA_POSITION">
            Provides the position of the LOD camera in world space, allowing you 
            				to perform separate LOD calculations in shaders independent of the rendering
            				camera. If there is no separate LOD camera then this is the real camera
            				position. See Camera::setLodCamera.
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantTypeInternal.ACT_LOD_CAMERA_POSITION_OBJECT_SPACE">
            Provides the position of the LOD camera in object space, allowing you 
            			to perform separate LOD calculations in shaders independent of the rendering
            			camera. If there is no separate LOD camera then this is the real camera
            			position. See Camera::setLodCamera.
        </member>
        <member name="T:Engine.Renderer.GpuProgramParameters.AutoConstantType">
            <summary>
            Defines the types of automatically updated values that may be bound to 
            <see cref="T:Engine.Renderer.GpuProgram"/> parameters, or used to modify parameters on a per-object basis.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.WorldMatrix">
            <summary>The current world matrix.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseWorldMatrix">
            <summary>The current world matrix, inverted.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TransposeWorldMatrix">
            <summary>
            Provides transpose of world matrix. Equivalent to RenderMonkey's "WorldTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTransposeWorldMatrix">
            <summary>The current world matrix, inverted and transposed.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.WorldMatrixArray3x4">
            <summary>The current array of world matrices, as a 3x4 matrix, used for blending.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.WorldMatrixArray">
            <summary>The current array of world matrices, used for blending.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewMatrix">
            <summary>The current view matrix.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseViewMatrix">
            <summary>The current view matrix, inverted.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TransposeViewMatrix">
            <summary>
            Provides transpose of view matrix. Equivalent to RenderMonkey's "ViewTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTransposeViewMatrix">
            <summary>
            Provides inverse transpose of view matrix.
            Equivalent to RenderMonkey's "ViewInverseTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ProjectionMatrix">
            <summary>The current projection matrix.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseProjectionMatrix">
            <summary>
            Provides inverse of projection matrix.
            Equivalent to RenderMonkey's "ProjectionInverse".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TransposeProjectionMatrix">
            <summary>
            Provides transpose of projection matrix.
            Equivalent to RenderMonkey's "ProjectionTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTransposeProjectionMatrix">
            <summary>
            Provides inverse transpose of projection matrix.
            Equivalent to RenderMonkey's "ProjectionInverseTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewProjMatrix">
            <summary>The current view and projection matrices concatenated.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseViewProjMatrix">
            <summary>
            Provides inverse of concatenated view and projection matrices.
            Equivalent to RenderMonkey's "ViewProjectionInverse".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TransposeViewProjMatrix">
            <summary>
            Provides transpose of concatenated view and projection matrices.
            Equivalent to RenderMonkey's "ViewProjectionTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTransposeViewProjMatrix">
            <summary>
            Provides inverse transpose of concatenated view and projection matrices.
            Equivalent to RenderMonkey's "ViewProjectionInverseTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.WorldViewMatrix">
            <summary>The current world and view matrices concatenated.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseWorldViewMatrix">
            <summary>The current world and view matrices concatenated, then inverted.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TransposeWorldViewMatrix">
            <summary>
            Provides transpose of concatenated world and view matrices.
            Equivalent to RenderMonkey's "WorldViewTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTransposeWorldViewMatrix">
            <summary>
            The current world and view matrices concatenated, then inverted and tranposed.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.WorldViewProjMatrix">
            <summary>The current world, view and projection matrices concatenated.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseWorldViewProjMatrix">
            <summary>
            Provides inverse of concatenated world, view and projection matrices.
            Equivalent to RenderMonkey's "WorldViewProjectionInverse".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TransposeWorldViewProjMatrix">
            <summary>
            Provides transpose of concatenated world, view and projection matrices.
            Equivalent to RenderMonkey's "WorldViewProjectionTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTransposeWorldViewProjMatrix">
            <summary>
            Provides inverse transpose of concatenated world, view and projection
            matrices. Equivalent to RenderMonkey's "WorldViewProjectionInverseTranspose".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.RenderTargetFlipping">
            <summary>
            -1 if requires texture flipping, +1 otherwise. It's useful when you bypassed
            projection matrix transform, still able use this value to adjust transformed y position.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.FogColor">
            <summary>Fog color.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.FogParams">
            <summary>Fog params: density, linear start, linear end, 1/(end-start).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SufraceAmbientColor">
            <summary>Surface ambient color.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SufraceDiffuseColor">
            <summary>Surface diffuse color.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SufraceSpecularColor">
            <summary>Surface specular color.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SufraceEmissiveColor">
            <summary>Surface emissive color.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SufraceShininess">
            <summary>Surface shininess.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightCount">
            <summary>The number of active light sources (better than gl_MaxLights).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.AmbientLightColor">
            <summary>The ambient light color set in the scene.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDiffuseColor">
            <summary>Light diffuse color (index determined by SetAutoConstant call).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightSpecularColor">
            <summary>Light specular color (index determined by SetAutoConstant call).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightAttenuation">
            <summary>Light attenuation parameters, Vector4(range, constant, linear, quadric).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SpotLightParams">
            <summary>
            Spotlight parameters, Vector4(innerFactor, outerFactor, falloff, isSpot)
            innerFactor and outerFactor are cos(angle/2).
            The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
            Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPosition">
            <summary>
            A light position in world space (index determined by SetAutoConstant call).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPositionObjectSpace">
            <summary>
            A light position in object space (index determined by SetAutoConstant call).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPositionViewSpace">
            <summary>
            A light position in view space (index determined by SetAutoConstant call).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDirection">
            <summary>
            A light direction in world space (index determined by SetAutoConstant call).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDirectionObjectSpace">
            <summary>
            A light direction in object space (index determined by SetAutoConstant call).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDirectionViewSpace">
            <summary>
            A light direction in view space (index determined by SetAutoConstant call).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDistanceObjectSpace">
            <summary>
            The distance of the light from the center of the object
            a useful approximation as an alternative to per-vertex distance
            calculations.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPowerScale">
            <summary>
            Light power level, a single scalar as set in Light.PowerScale 
            (index determined by SetAutoConstant call)
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDiffuseColorPowerScaled">
            <summary>
            Light diffuse colour pre-scaled by power scale.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightSpecularColorPowerScaled">
            <summary>
            Light specular colour pre-scaled by power scale.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDiffuseColorArray">
            <summary>Array of light diffuse colors (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightSpecularColorArray">
            <summary>Array of light specular colors (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDiffuseColorPowerScaledArray">
            <summary>
            Array of light diffuse colours scaled by light power (count set by extra param).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightSpecularColorPowerScaledArray">
            <summary>
            Array of light specular colours scaled by light power (count set by extra param).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightAttenuationArray">
            <summary>
            Array of light attenuation parameters, Vector4(range, constant, linear, quadric) 
            (count set by extra param).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPositionArray">
            <summary>Array of light positions in world space (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPositionObjectSpaceArray">
            <summary>Array of light positions in object space (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPositionViewSpaceArray">
            <summary>Array of light positions in view space (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDirectionArray">
            <summary>Array of light directions in world space (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDirectionObjectSpaceArray">
            <summary>Array of light directions in object space (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDirectionViewSpaceArray">
            <summary>Array of light directions in view space (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightDistanceObjectSpaceArray">
            <summary>
            Array of distances of the lights from the center of the object
            a useful approximation as an alternative to per-vertex distance
            calculations. (count set by extra param).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightPowerScaleArray">
            <summary>
            Array of light power levels, a single scalar as set in Light.PowerScale 
            (count set by extra param).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SpotLightParamsArray">
            <summary>
            Spotlight parameters array of Vector4(innerFactor, outerFactor, falloff, isSpot)
            innerFactor and outerFactor are cos(angle/2)
            The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
            Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively.
            (count set by extra param).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.DerivedAmbientLightColor">
            <summary>
            The derived ambient light color, with 'r', 'g', 'b' components filled with
            product of surface ambient color and ambient light color, respectively,
            and 'a' component filled with surface ambient alpha component.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.DerivedSceneColor">
            <summary>
            The derived scene color, with 'r', 'g' and 'b' components filled with sum
            of derived ambient light color and surface emissive color, respectively,
            and 'a' component filled with surface diffuse alpha component.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.DerivedLightDiffuseColor">
            <summary>
            The derived light diffuse color (index determined by SetAutoConstant call),
            with 'r', 'g' and 'b' components filled with product of surface diffuse color
            and light diffuse color, respectively, and 'a' component filled with surface
            diffuse alpha component.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.DerivedLightSpecularColor">
            <summary>
            The derived light specular color (index determined by SetAutoConstant call),
            with 'r', 'g' and 'b' components filled with product of surface specular color
            and light specular color, respectively, and 'a' component filled with surface
            specular alpha component.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.DerivedLightColorArray">
            <summary>Array of derived light diffuse colors (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.DerivedLightSpecularColorArray">
            <summary>Array of derived light specular colors (count set by extra param).</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LightNumber">
            <summary>
            The absolute light number of a local light index. Each pass may have
            a number of lights passed to it, and each of these lights will have
            an index in the overall light list, which will differ from the local
            light index due to factors like setStartLight and setIteratePerLight.
            This binding provides the global light index for a local index.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ShadowExtrusionDistance">
            <summary>
            The distance a shadow volume should be extruded when using
            finite extrusion programs.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.CameraPosition">
            <summary>The current camera's position in world space.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.CameraPositionObjectSpace">
            <summary>The current camera's position in object space.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TextureViewProjMatrix">
            <summary>The view/projection matrix of the assigned texture projection frustum.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TextureViewProjMatrixArray">
            <summary>
            Array of view/projection matrices of the first n texture projection frustums.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TextureWorldViewProjMatrix">
            <summary>
            The view/projection matrix of the assigned texture projection frustum, 
            combined with the current world matrix.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TextureWorldViewProjMatrixArray">
            <summary>
            Array of world/view/projection matrices of the first n texture projection frustums.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SpotLightViewProjMatrix">
            <summary>
            The view/projection matrix of a given spotlight.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SpotLightWorldViewProjMatrix">
            <summary>
            The view/projection matrix of a given spotlight projection frustum, 
            combined with the current world matrix.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Custom">
            <summary>
            A custom parameter which will come from the renderable, using 'data' as the identifier.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time">
            <summary>provides current elapsed time.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time0X">
            <summary>
            Single float value, which repeats itself based on given as
            parameter "cycle time". Equivalent to RenderMonkey's "Time0_X".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.CosTime0X">
            <summary>Cosine of "Time0_X". Equivalent to RenderMonkey's "CosTime0_X".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SinTime0X">
            <summary>Sine of "Time0_X". Equivalent to RenderMonkey's "SinTime0_X".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TanTime0X">
            <summary>Tangent of "Time0_X". Equivalent to RenderMonkey's "TanTime0_X".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time0XPacked">
            <summary>
            Vector of "Time0_X", "SinTime0_X", "CosTime0_X", 
            "TanTime0_X". Equivalent to RenderMonkey's "Time0_X_Packed".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time01">
            <summary>
            Single float value, which represents scaled time value [0..1],
            which repeats itself based on given as parameter "cycle time".
            Equivalent to RenderMonkey's "Time0_1".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.CosTime01">
            <summary>Cosine of "Time0_1". Equivalent to RenderMonkey's "CosTime0_1".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SinTime01">
            <summary>Sine of "Time0_1". Equivalent to RenderMonkey's "SinTime0_1".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TanTime01">
            <summary>Tangent of "Time0_1". Equivalent to RenderMonkey's "TanTime0_1".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time01Packed">
            <summary>
            Vector of "Time0_1", "SinTime0_1", "CosTime0_1",
            "TanTime0_1". Equivalent to RenderMonkey's "Time0_1_Packed".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time02PI">
            <summary>
            Single float value, which represents scaled time value [0..2*Pi],
            which repeats itself based on given as parameter "cycle time".
            Equivalent to RenderMonkey's "Time0_2PI".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.CosTime02PI">
            <summary>Cosine of "Time0_2PI". Equivalent to RenderMonkey's "CosTime0_2PI".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SinTime02PI">
            <summary>Sine of "Time0_2PI". Equivalent to RenderMonkey's "SinTime0_2PI".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TanTime02PI">
            <summary>Tangent of "Time0_2PI". Equivalent to RenderMonkey's "TanTime0_2PI".</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.Time02PIPacked">
            <summary>
            Vector of "Time0_2PI", "SinTime0_2PI", "CosTime0_2PI",
            "TanTime0_2PI". Equivalent to RenderMonkey's "Time0_2PI_Packed".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.FrameTime">
            <summary>Provides the scaled frame time, returned as a floating point value.</summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.FPS">
            <summary>
            Provides the calculated frames per second, returned as a floating point value.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewportWidth">
            <summary>
            Current viewport width (in pixels) as floating point value.
            Equivalent to RenderMonkey's "ViewportWidth".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewportHeight">
            <summary>
            Current viewport height (in pixels) as floating point value.
            Equivalent to RenderMonkey's "ViewportHeight".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseViewportWidth">
            <summary>
            This variable represents 1.0/ViewportWidth. 
            Equivalent to RenderMonkey's "ViewportWidthInverse".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseViewportHeight">
            <summary>
            This variable represents 1.0/ViewportHeight.
            Equivalent to RenderMonkey's "ViewportHeightInverse".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewportSize">
            <summary>
            Packed of "ViewportWidth", "ViewportHeight", "ViewportWidthInverse",
            "ViewportHeightInverse".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewDirection">
            <summary>
            This variable provides the view direction vector (world space).
            Equivalent to RenderMonkey's "ViewDirection".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewSideVector">
            <summary>
            This variable provides the view side vector (world space).
            Equivalent to RenderMonkey's "ViewSideVector".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ViewUpVector">
            <summary>
            This variable provides the view up vector (world space).
            Equivalent to RenderMonkey's "ViewUpVector".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.FOV">
            <summary>
            This variable provides the field of view as a floating point value.
            Equivalent to RenderMonkey's "FOV".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.NearClipDistance">
            <summary>
            This variable provides the near clip distance as a floating point value.
            Equivalent to RenderMonkey's "NearClipPlane".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.FarClipDistance">
            <summary>
            This variable provides the far clip distance as a floating point value.
            Equivalent to RenderMonkey's "FarClipPlane".
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.PassNumber">
            <summary>
            Provides the pass index number within the technique
            of the active materil.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.PassIterationNumber">
            <summary>
            Provides the current iteration number of the pass. The iteration
            number is the number of times the current render operation has
            been drawn for the acitve pass.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.AnimationParametric">
            <summary>
            Provides a parametric animation value [0..1], only available
            where the renderable specifically implements it.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TexelOffsets">
            <summary>
            Provides the texel offsets required by this rendersystem to map
            texels to pixels. Packed as 
            float4(absoluteHorizontalOffset, absoluteVerticalOffset, 
            horizontalOffset / viewportWidth, verticalOffset / viewportHeight).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.SceneDepthRange">
            <summary>
            Provides information about the depth range of the scene as viewed
            from the current camera. 
            Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ShadowSceneDepthRange">
            <summary>
            Provides information about the depth range of the scene as viewed
            from a given shadow camera. Requires an index parameter which maps
            to a light index relative to the current light list.
            Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ShadowColor">
            <summary>
            Provides the fixed shadow colour as configured via <see>SceneManager.ShadowColor</see>;
            useful for integrated modulative shadows.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TextureSize">
            <summary>
            Provides texture size of the texture unit (index determined by SetAutoConstant
            call). Packed as float4(width, height, depth, 1).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.InverseTextureSize">
            <summary>
            Provides inverse texture size of the texture unit (index determined by SetAutoConstant
            call). Packed as float4(1 / width, 1 / height, 1 / depth, 1).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.PackedTextureSize">
            <summary>
            Provides packed texture size of the texture unit (index determined by SetAutoConstant
            call). Packed as float4(width, height, 1 / width, 1 / height).
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.TextureMatrix">
            <summary>
            Provides the current transform matrix of the texture unit (index determined 
            by SetAutoConstant call), as seen by the fixed-function pipeline.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LodCameraPosition">
            <summary>
            Provides the position of the LOD camera in world space, allowing you 
            to perform separate LOD calculations in shaders independent of the rendering
            camera. If there is no separate LOD camera then this is the real camera
            position. See Camera.SetLodCamera.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.LodCameraPositionObjectSpace">
            <summary>
            Provides the position of the LOD camera in object space, allowing you 
            to perform separate LOD calculations in shaders independent of the rendering
            camera. If there is no separate LOD camera then this is the real camera
            position. See Camera.SetLodCamera.
            </summary>
        </member>
        <member name="F:Engine.Renderer.GpuProgramParameters.AutoConstantType.ShadowTextureSizes">
            <summary>
            x - point light, y - directional light, z - spot light.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Font">
            <summary>
            Class representing a font in the system.
            </summary>
            <remarks>
            <para>
            This class is simply a way of getting a font textures into the engine system and
            to easily retrieve the texture coordinates required to accurately render them.
            Fonts can either be loaded from precreated textures, or the texture can be generated
            using a truetype font.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Font.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Font.ToString">
            <summary>
            Returns the font name and height in the form of a string.
            </summary>
            <returns>The font name and height in the form of a string.</returns>
        </member>
        <member name="M:Engine.Renderer.Font.GetCharacterWidth(Engine.Renderer.GuiRenderer,System.Char)">
            <summary>
            Returns the character screen width.
            </summary>
            <param name="forRenderer"></param>
            <param name="c">The character.</param>
            <returns>The character screen width.</returns>
        </member>
        <member name="M:Engine.Renderer.Font.GetTextLength(Engine.Renderer.GuiRenderer,System.String)">
            <summary>
            Returns the text screen width.
            </summary>
            <param name="forRenderer"></param>
            <param name="text">The text.</param>
            <returns>The text screen width.</returns>
        </member>
        <member name="P:Engine.Renderer.Font.Name">
            <summary>Gets the font name.</summary>
        </member>
        <member name="P:Engine.Renderer.Font.Language">
            <summary>Gets the font language.</summary>
        </member>
        <member name="P:Engine.Renderer.Font.Height">
            <summary>Gets the font screen height.</summary>
        </member>
        <member name="T:Engine.Renderer.ParticleSystemManager">
            <summary>
            Manages particle systems, particle system scripts (templates) and the 
            available emitter and affector factories.
            </summary>
            <remarks>
            <para>
            This singleton class is responsible for creating and managing particle 
            systems. All particle systems must be created and destroyed using this 
            object, although the user interface to creating them is via
            <see cref="T:Engine.Renderer.SceneManager"/>. Remember that like all other <see cref="T:Engine.Renderer.MovableObject"/>
            subclasses, ParticleSystems do not get rendered until they are 
            attached to a <see cref="T:Engine.Renderer.SceneNode"/> object.
            </para>
            <para>
            This class also manages factories for <see cref="T:Engine.Renderer.ParticleEmitter"/> and 
            <see cref="T:Engine.Renderer.ParticleAffector"/> classes. To enable easy extensions to the types of 
            emitters (particle sources) and affectors (particle modifiers), the
            ParticleSystemManager lets plugins or applications register factory 
            classes which submit new subclasses to <see cref="T:Engine.Renderer.ParticleEmitter"/> and 
            <see cref="T:Engine.Renderer.ParticleAffector"/>. Engine comes with a number of them already provided,
            such as cone, sphere and box-shaped emitters, and simple affectors such
            as constant directional force and colour faders. However using this 
            registration process, a plugin can create any behaviour required.
            </para>
            <para>
            This class also manages the loading and parsing of particle system 
            scripts, which are text files describing named particle system 
            templates. Instances of particle systems using these templates can
            then be created easily through the <see cref="M:Engine.Renderer.SceneManager.CreateParticleSystem(System.String)"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.ParticleSystemManager.UnloadTemplate(System.String)">
            <summary>Unloads template.</summary>
            <param name="templateName">The template name.</param>
        </member>
        <member name="M:Engine.Renderer.ParticleSystemManager.ParseFile(System.String)">
            <summary>Reloads template from file.</summary>
            <param name="fileName">The template file name.</param>
        </member>
        <member name="M:Engine.Renderer.ParticleSystemManager.Exists(System.String)">
            <summary>To check up existence of a particle system template.</summary>
            <param name="templateName">The particle system template name.</param>
            <returns><b>true</b> if such particle system template is exists; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.ParticleSystemManager.GetUniqueName(System.String)">
            <summary>
            Returns the generated the unique particle system template name with prefix.
            </summary>
            <param name="prefix">The name prefix.</param>
            <returns>The generated unique the particle system template name with prefix.</returns>
        </member>
        <member name="P:Engine.Renderer.ParticleSystemManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.ParticleSystemManager"/>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystemManager.PropertyEmitterTypes">
            <summary>Gets the particle emitter types collection. <b>Don't modify</b>.</summary>
        </member>
        <member name="P:Engine.Renderer.ParticleSystemManager.PropertyAffectorTypes">
            <summary>Gets the particle affector types collection. <b>Don't modify</b>.</summary>
        </member>
        <member name="T:Engine.Renderer.HardwareOcclusionQuery">
            <summary>
            This is a class that that provides the interface for the query class for hardware occlusion.
            </summary>
        </member>
        <member name="M:Engine.Renderer.HardwareOcclusionQuery.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.HardwareOcclusionQuery.BeginOcclusionQuery">
            <summary>Starts the hardware occlusion query.</summary>
        </member>
        <member name="M:Engine.Renderer.HardwareOcclusionQuery.EndOcclusionQuery">
            <summary>Ends the hardware occlusion test.</summary>
        </member>
        <member name="M:Engine.Renderer.HardwareOcclusionQuery.PullOcclusionQuery(System.UInt32@)">
            <summary>
            Pulls the hardware occlusion query.
            </summary>
            <remarks>
            Waits until the query result is available; use <see cref="M:Engine.Renderer.HardwareOcclusionQuery.IsStillOutstanding"/>
            if just want to test if the result is available.
            </remarks>
            <param name="numOfFragments">Will get the resulting number of fragments.</param>
            <returns><b>true</b> if success; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareOcclusionQuery.IsStillOutstanding">
            <summary>
            Lets you know when query is done, or still be processed by the Hardware.
            </summary>
            <returns><b>true</b> if query isn't finished; otherwise, <b>false</b>.</returns>
        </member>
        <member name="T:Engine.Renderer.HardwareBufferManager">
            <summary>
            Abstract singleton class for managing hardware buffers, a concrete instance
            of this will be created by the <see cref="T:Engine.Renderer.RenderSystem"/>.
            </summary>
        </member>
        <member name="M:Engine.Renderer.HardwareBufferManager.CreateIndexBuffer(Engine.Renderer.HardwareIndexBuffer.IndexType,System.Int32,Engine.Renderer.HardwareBuffer.Usage,System.Boolean)">
            <summary>
            Create a hardware index buffer.
            </summary>
            <param name="type">
            The type in index, either 16- or 32-bit, depending on how many vertices you need 
            to be able to address
            </param>
            <param name="indexCount">The number of indexes in the buffer.</param>
            <param name="usage">One or more members of the HardwareBuffer.Usage enumeration.</param>
            <param name="useShadowBuffer">
            If set to true, this buffer will be 'shadowed' by one stored in 
            system memory rather than GPU or AGP memory. You should set this flag if you intend 
            to read data back from the index buffer, because reading data from a buffer
            in the GPU or AGP memory is very expensive, and is in fact impossible if you
            specify <b>WriteOnly</b> for the main buffer. If you use this option, all 
            reads and writes will be done to the shadow buffer, and the shadow buffer will
            be synchronised with the real buffer at an appropriate time.
            </param>
            <returns>The hardware index buffer.</returns>
            <remarks>
            Note that because buffers can be shared, they are reference
            counted so you do not need to worry about destroying themm this will be done
            automatically.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.HardwareBufferManager.CreateIndexBuffer(Engine.Renderer.HardwareIndexBuffer.IndexType,System.Int32,Engine.Renderer.HardwareBuffer.Usage)">
            <summary>
            Create a hardware index buffer.
            </summary>
            <param name="type">
            The type in index, either 16- or 32-bit, depending on how many vertices you need 
            to be able to address
            </param>
            <param name="indexCount">The number of indexes in the buffer.</param>
            <param name="usage">One or more members of the HardwareBuffer.Usage enumeration.</param>
            <returns>The hardware index buffer.</returns>
            <remarks>
            Note that because buffers can be shared, they are reference
            counted so you do not need to worry about destroying themm this will be done
            automatically.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.HardwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Engine.Renderer.HardwareBuffer.Usage,System.Boolean)">
            <summary>
            Create a hardware vertex buffer.
            </summary>
            <param name="vertexSize">
            The size in bytes of each vertex in this buffer; you must calculate
            this based on the kind of data you expect to populate this buffer with.
            </param>
            <param name="vertexCount">The number of indexes in the buffer.</param>
            <param name="usage">
            One or more members of the <see cref="T:Engine.Renderer.HardwareBuffer.Usage"/> enumeration; you are
            strongly advised to use <b>StaticWriteOnly</b> wherever possible, if you need to 
            update regularly, consider <b>DynamicWriteOnly</b> and useShadowBuffer = true.
            </param>
            <param name="useShadowBuffer">
            If set to true, this buffer will be 'shadowed' by one stored in 
            system memory rather than GPU or AGP memory. You should set this flag if you intend 
            to read data back from the vertex buffer, because reading data from a buffer
            in the GPU or AGP memory is very expensive, and is in fact impossible if you
            specify <b>WriteOnly</b> for the main buffer. If you use this option, all 
            reads and writes will be done to the shadow buffer, and the shadow buffer will
            be synchronised with the real buffer at an appropriate time.
            </param>
            <returns>The hardware vertex buffer.</returns>
            <remarks>
            <para>
            This method creates a new vertex buffer; this will act as a source of geometry
            data for rendering objects. Note that because the meaning of the contents of
            the vertex buffer depends on the usage, this method does not specify a
            vertex format; the user of this buffer can actually insert whatever data 
            they wish, in any format. However, in order to use this with a RenderOperation,
            the data in this vertex buffer will have to be associated with a semantic element
            of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            using the <see cref="T:Engine.Renderer.VertexDeclaration"/> class, which itself contains 
            <see cref="T:Engine.Renderer.VertexElement"/> structures referring to the source data.
            </para>
            <para>
            Note that because vertex buffers can be shared, they are reference
            counted so you do not need to worry about destroying themm this will be done
            automatically.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.HardwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Engine.Renderer.HardwareBuffer.Usage)">
            <summary>
            Create a hardware vertex buffer.
            </summary>
            <param name="vertexSize">
            The size in bytes of each vertex in this buffer; you must calculate
            this based on the kind of data you expect to populate this buffer with.
            </param>
            <param name="vertexCount">The number of indexes in the buffer.</param>
            <param name="usage">
            One or more members of the <see cref="T:Engine.Renderer.HardwareBuffer.Usage"/> enumeration; you are
            strongly advised to use <b>StaticWriteOnly</b> wherever possible, if you need to 
            update regularly, consider <b>DynamicWriteOnly</b> and useShadowBuffer = <b>true</b>.
            </param>
            <returns>The hardware vertex buffer.</returns>
            <remarks>
            <para>
            This method creates a new vertex buffer; this will act as a source of geometry
            data for rendering objects. Note that because the meaning of the contents of
            the vertex buffer depends on the usage, this method does not specify a
            vertex format; the user of this buffer can actually insert whatever data 
            they wish, in any format.
            </para>
            <para>
            Note that because vertex buffers can be shared, they are reference
            counted so you do not need to worry about destroying themm this will be done
            automatically.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.HardwareBufferManager.CreateVertexDeclaration">
            <summary>
            Creates a new vertex declaration.
            </summary>
            <returns>The vertex declaration.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwareBufferManager.DestroyVertexDeclaration(Engine.Renderer.VertexDeclaration)">
            <summary>
            Destroys a vertex declaration.
            </summary>
            <param name="declaration">The vertex declaration.</param>
        </member>
        <member name="P:Engine.Renderer.HardwareBufferManager.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.HardwareBufferManager"/>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Camera">
            <summary>
            A viewpoint from which the scene will be rendered.
            </summary>
            <remarks>
            <para>
            Engine renders scenes from a camera viewpoint into a buffer of
            some sort, normally a window or a texture (a subclass of
            <see cref="T:Engine.Renderer.RenderTarget"/>).
            Engine cameras support both perspective projection (the default,
            meaning objects get smaller the further away they are) and
            orthographic projection (blueprint-style, no decrease in size
            with distance). Each camera carries with it a style of rendering,
            e.g. full textured, flat shaded, wireframe), field of view,
            rendering distances etc, allowing you to use Engine to create
            complex multi-window views if required. In addition, more than
            one camera can point at a single render target if required,
            each rendering to a subset of the target, allowing split screen
            and picture-in-picture views.
            </para>
            <para>
            Cameras maintain their own aspect ratios, field of view, and frustrum,
            and project co-ordinates into a space measured from -1 to 1 in x and y,
            and 0 to 1 in z. At render time, the camera will be rendering to a
            Viewport which will translate these parametric co-ordinates into real screen
            co-ordinates. Obviously it is advisable that the viewport has the same
            aspect ratio as the camera to avoid distortion (unless you want it!).
            </para>
            <para>
            Note that a Camera can be attached to a <see cref="T:Engine.Renderer.SceneNode"/>, using the method
            <see cref="M:Engine.Renderer.SceneNode.Attach(Engine.Renderer.MovableObject)"/>. If this is done the Camera will combine it's own
            position/orientation settings with it's parent <see cref="T:Engine.Renderer.SceneNode"/>. 
            This is useful for implementing more complex Camera / object
            relationships i.e. having a camera attached to a world object.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Camera.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Camera.LookAt(Engine.MathEx.Vec3)">
            <summary>
            Get or sets the camera's up vector.
            </summary>
            <param name="target">A vector specifying the look at point.</param>
            <remarks>
            This is a helper method to automatically generate the
            direction vector for the camera, based on it's current position
            and the supplied look-at point.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Camera.ProjectToScreenCoordinates(Engine.MathEx.Vec3,Engine.MathEx.Vec2@)">
            <summary>
            Projects world position to screen coordinates.
            </summary>
            <param name="position">The world position.</param>
            <param name="screenPosition">The result screen coordinates.</param>
            <returns>
            <b>true</b> if screen position successfully received; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:Engine.Renderer.Camera.GetCameraToViewportRay(Engine.MathEx.Vec2)">
            <summary>
            Generates world ray from screen coordinates.
            </summary>
            <param name="screenPosition">The screen coordinates.</param>
            <returns>The ray.</returns>
        </member>
        <member name="P:Engine.Renderer.Camera.Position">
            <summary>Get or sets the camera's position.</summary>
        </member>
        <member name="P:Engine.Renderer.Camera.DerivedPosition">
            <summary>
            Gets the derived position of the camera, including any
            translation inherited from a reflection matrix.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Camera.Direction">
            <summary>Get or sets the camera's direction.</summary>
        </member>
        <member name="P:Engine.Renderer.Camera.DerivedDirection">
            <summary>
            Gets the derived direction vector of the camera, including any
            rotation inherited from a reflection matrix.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Camera.Up">
            <summary>Gets or sets the camera's up vector.</summary>
        </member>
        <member name="P:Engine.Renderer.Camera.FixedUp">
            <summary>Gets or sets the camera's fixed up vector.</summary>
        </member>
        <member name="P:Engine.Renderer.Camera.Rotation">
            <summary>
            Gets the camera's current orientation.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Camera.DerivedRotation">
            <summary>
            Gets the derived orientation of the camera, including any
            rotation inherited from a reflection matrix.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Camera.PolygonMode">
            <summary>
            Gets or sets the level of rendering detail required from this camera.
            </summary>
            <remarks>
            Each camera is set to render at full detail by default, that is
            with full texturing, lighting etc. This method lets you change
            that behaviour, allowing you to make the camera just render a
            wireframe view, for example.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RibbonTrail">
            <summary>
            Subclass of BillboardChain which automatically leaves a trail behind
            one or more Node instances.
            </summary>
            <remarks>
            <para>
            An instance of this class will watch one or more Node instances, and
            automatically generate a trail behind them as they move. Because this
            class can monitor multiple modes, it generates its own geometry in 
            world space and thus, even though it has to be attached to a SceneNode
            to be visible, changing the position of the scene node it is attached to
            makes no difference to the geometry rendered.
            </para>
            <para>
            The 'head' element grows smoothly in size until it reaches the required size,
            then a new element is added. If the segment is full, the tail element
            shrinks by the same proportion as the head grows before disappearing.
            </para>
            <para>
            Elements can be faded out on a time basis, either by altering their colour
            or altering their alpha. The width can also alter over time.
            </para>
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RibbonTrail.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.RibbonTrail.AddNode(Engine.Renderer.SceneNode)">
            <summary>
            Adds a node to be tracked.
            </summary>
            <param name="node">The node that will be tracked.</param>
        </member>
        <member name="M:Engine.Renderer.RibbonTrail.RemoveNode(Engine.Renderer.SceneNode)">
            <summary>
            Removes tracking on a given node.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.TrailLength">
            <summary>
            Gets or sets the length of the trail.
            </summary>
            <remarks>
            This sets the length of the trail, in world units. It also sets how
            far apart each segment will be, ie length / max_elements. 
            </remarks>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.ChainCount">
            <summary>
            Gets or sets the number of chains.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.Chains">
            <summary>
            Gets the chains collection. <b>Don't modify</b>.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RibbonTrail.Chain">
            <summary>
            Defines the ribbon trail chain.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.Chain.InitialColor">
            <summary>
            Gets or sets the starting ribbon colour for a given segment.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.Chain.InitialWidth">
            <summary>
            Gets or sets the starting ribbon width in world units.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.Chain.ChangeColor">
            <summary>
            Gets or sets the per-second fading amount.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RibbonTrail.Chain.ChangeWidth">
            <summary>
            Gets or sets the change in ribbon width per second.
            </summary>
        </member>
        <member name="T:Engine.Renderer.HardwareVertexBuffer">
            <summary>
            Specialisation of HardwareBuffer for a vertex buffer.
            </summary>
        </member>
        <member name="M:Engine.Renderer.HardwareVertexBuffer.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="P:Engine.Renderer.HardwareVertexBuffer.VertexCount">
            <summary>Get the number of vertices in this buffer.</summary>
        </member>
        <member name="P:Engine.Renderer.HardwareVertexBuffer.VertexSizeInBytes">
            <summary>Gets the size in bytes of a single vertex in this buffer.</summary>
        </member>
        <member name="T:Engine.Renderer.PixelBox">
            <summary>
            A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.
            In case of a rectangle, depth must be 1. 
            Pixels are stored as a succession of "depth" slices, each containing "height" rows of 
            "width" pixels.
            </summary>
        </member>
        <member name="M:Engine.Renderer.PixelBox.WriteData(System.Int32,System.Byte[])">
            <summary>
            Writes data to buffer.
            </summary>
            <param name="position">The position offset to write in bytes.</param>
            <param name="buffer">The buffer.</param>
        </member>
        <member name="M:Engine.Renderer.PixelBox.WriteDataUnmanaged(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Writes data to buffer.
            </summary>
            <param name="position">The position offset to write in bytes.</param>
            <param name="buffer">The buffer pointer.</param>
            <param name="length">The buffer length.</param>
        </member>
        <member name="P:Engine.Renderer.PixelBox.Data">
            <summary>Gets the data buffer.</summary>
        </member>
        <member name="P:Engine.Renderer.PixelBox.Format">
            <summary>Gets the pixel format.</summary>
        </member>
        <member name="P:Engine.Renderer.PixelBox.RowPitch">
            <summary>Gets the row pitch.</summary>
        </member>
        <member name="P:Engine.Renderer.PixelBox.SlicePitch">
            <summary>Gets the slice pitch.</summary>
        </member>
        <member name="T:Engine.Renderer.HardwarePixelBuffer">
            <summary>
            Specialisation of HardwareBuffer for a pixel buffer. The
            HardwarePixelbuffer abstracts an 1D, 2D or 3D quantity of pixels
            stored by the rendering API. The buffer can be located on the card
            or in main memory depending on its usage. One mipmap level of a
            texture is an example of a HardwarePixelBuffer.
            </summary>
        </member>
        <member name="M:Engine.Renderer.HardwarePixelBuffer.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.HardwarePixelBuffer.GetRenderTarget(System.Int32)">
            <summary>
            Get a render target for this PixelBuffer, or a slice of it. The texture this
            was acquired from must have <b>RenderTarget</b> set.
            </summary>
            <param name="slice">Which slice.</param>
            <returns>A pointer to the render target. This pointer has the lifespan of this PixelBuffer.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwarePixelBuffer.GetRenderTarget">
            <summary>
            Get a render target for this PixelBuffer, or a slice of it. The texture this
            was acquired from must have <b>RenderTarget</b> set.
            </summary>
            <returns>A render target. This pointer has the lifespan of this PixelBuffer.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwarePixelBuffer.GetCurrentLock">
            <summary>
            Returns the current lock as PixelBox.
            </summary>
            <returns>The PixelBox.</returns>
        </member>
        <member name="M:Engine.Renderer.HardwarePixelBuffer.BlitToMemory(Engine.Renderer.PixelBox)">
            <summary>
            Convience function that blits this entire buffer to a pixelbox.
            </summary>
            <remarks>
            <para>
            The image is scaled as needed.
            </para>
            <para>
            Only call this function when the buffer is unlocked.
            </para>
            </remarks>
            <param name="destination">
            PixelBox containing the destination pixels and format in memory.
            </param>
        </member>
        <member name="T:Engine.Renderer.ParticleSystemRenderer">
            <summary>
            Abstract class defining the interface required to be implemented
            by classes which provide rendering capability to ParticleSystem instances.
            </summary>
        </member>
        <member name="M:Engine.Renderer.ParticleSystemRenderer.ToString">
            <summary>
            Gets the name of type of this renderer.
            </summary>
            <returns>The name of type of this renderer.</returns>
        </member>
        <member name="T:Engine.Renderer.CompositionTargetPass">
            <summary>
            Object representing one render to a <see cref="T:Engine.Renderer.RenderTarget"/> or <see cref="T:Engine.Renderer.Viewport"/> 
            in the Composition framework.
            </summary>
        </member>
        <member name="M:Engine.Renderer.CompositionTargetPass.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.CompositionTargetPass.CreatePass">
            <summary>Create a new pass, and return a pointer to it.</summary>
            <returns>A pass.</returns>
        </member>
        <member name="P:Engine.Renderer.CompositionTargetPass.InputMode">
            <summary>Gets or sets input mode of this TargetPass.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTargetPass.OutputName">
            <summary>Gets or sets output local texture name.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTargetPass.OnlyInitial">
            <summary>
            Gets or sets "only initial" flag. This makes that this target pass is 
            only executed initially after the effect has been enabled.
            </summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTargetPass.Passes">
            <summary>Gets the passes collection. <b>Don't modify</b>.</summary>
        </member>
        <member name="P:Engine.Renderer.CompositionTargetPass.MaterialScheme">
            <summary>
            Gets or sets the material scheme used by this target pass.
            </summary>
            <remarks>
            Only applicable to targets that render the scene as one of their passes.
            </remarks>
            <see cref="P:Engine.Renderer.Technique.SchemeName"/>
        </member>
        <member name="T:Engine.Renderer.CompositionTargetPass.PassInputMode">
            <summary>Input mode of a TargetPass.</summary>
        </member>
        <member name="F:Engine.Renderer.CompositionTargetPass.PassInputMode.None">
            <summary>No input.</summary>
        </member>
        <member name="F:Engine.Renderer.CompositionTargetPass.PassInputMode.Previous">
            <summary>Output of previous Composition in chain.</summary>
        </member>
        <member name="T:Engine.Renderer.BillboardParticleRenderer">
            <summary>
            Specialisation of ParticleSystemRenderer to render particles using a <see cref="T:Engine.Renderer.BillboardSet"/>. 
            </summary>
            <remarks>
            This renderer has a few more options than the standard particle system,
            which will be passed to it automatically when the particle system itself
            does not understand them.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.AccurateFacing">
            <summary>
            Gets or sets whether or not billboards use an 'accurate' facing model
            based on the vector from each billboard to the camera, rather than 
            an optimised version using just the camera direction.
            </summary>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.BillboardType">
            <summary>
            Gets or sets the type of billboard to render.
            </summary>
            <remarks>
            <para>
            The default sort of billboard (<b>Point</b>), always has both x and y axes parallel to 
            the camera's local axes. This is fine for 'point' style billboards (e.g. flares,
            smoke, anything which is symmetrical about a central point) but does not look good for
            billboards which have an orientation (e.g. an elongated raindrop). In this case, the
            oriented billboards are more suitable (<b>OrientedCommon</b> or <b>OrientedSelf</b>) since
            they retain an independant Y axis and only the X axis is generated, perpendicular to both
            the local Y and the camera Z.
            </para>
            <para>
            In some case you might want the billboard has fixed Z axis and doesn't need to face to
            camera (e.g. an aureola around the player and parallel to the ground). You can use
            <b>PerpendicularSelf</b> which the billboard plane perpendicular to the billboard own
            direction. Or <b>PerpendicularCommon</b> which the billboard plane perpendicular to the
            common direction.
            </para>
            <para>
            <b>PerpendicularSelf</b> and <b>PerpendicularCommon</b> can't guarantee 
            counterclockwise, you might use double-side material 
            (<b>cull_hardware node</b>) to ensure no billboard are culled.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.BillboardOrigin">
            <summary>
            Gets or sets the point which acts as the origin point for all billboards in this set.
            </summary>
            <remarks>
            This setting controls the fine tuning of where a billboard appears in relation to it's
            position. It could be that a billboard's position represents it's center (e.g. for fireballs),
            it could mean the center of the bottom edge (e.g. a tree which is positioned on the ground),
            the top-left corner (e.g. a cursor).
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.BillboardRotation">
            <summary>
            Gets or sets billboard rotation type.
            </summary>
            <remarks>
            This setting controls the billboard rotation type, you can deciding rotate 
            the billboard's vertices around their facing direction or rotate the 
            billboard's texture coordinates.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.CommonDirection">
            <summary>
            Gets or sets common direction.
            </summary>
            <remarks>
            <para>
            Use this to specify the common direction given to billboards of type 
            <b>OrientedCommon</b> or <b>PerpendicularCommon</b>.
            </para>
            <para>
            Use <b>OrientedCommon</b> when you want oriented billboards but you 
            know they are always going to be oriented the same way (e.g. rain in calm weather).
            It is faster for the system to calculate the billboard vertices if they 
            have a common direction.
            </para>
            </remarks>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.CommonUpVector">
            <summary>
            Gets or sets common up vector.
            </summary>
            <remarks>
            Use <b>PerpendicularSelf</b> or <b>PerpendicularCommon</b> when you want 
            oriented billboards perpendicular to specify direction vector (or, Z axis), 
            and doesn't face to camera. 
            In this case, we need an additional up-vector to determine the billboard X and Y axis.
            The generated billboard plane and X-axis guarantee perpendicular to specify direction.
            </remarks>
            <seealso cref="P:Engine.Renderer.BillboardParticleRenderer.CommonDirection"/>
        </member>
        <member name="P:Engine.Renderer.BillboardParticleRenderer.PointRendering">
            <summary>
            Gets or sets whether or not the BillboardSet will use point rendering
            rather than manually generated quads.
            </summary>
            <remarks>
            By default a billboardset is rendered by generating geometry for a
            textured quad in memory, taking into account the size and 
            orientation settings, and uploading it to the video card. 
            The alternative is to use hardware point rendering, which means that
            only one position needs to be sent per billboard rather than 4 and
            the hardware sorts out how this is rendered based on the render
            state.
            </remarks>
        </member>
        <member name="T:Engine.Renderer.Texture">
            <summary>
            Class representing a Texture resource.
            </summary>
            <remarks>
            The actual concrete subclass which will exist for a texture
            is dependent on the rendering system in use (Direct3D, OpenGL etc).
            This class represents the commonalities, and is the one 'used'
            by programmers even though the real implementation could be
            different in reality. Texture objects are created through
            the 'create' method of the <see cref="T:Engine.Renderer.TextureManager"/> concrete subclass.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Texture.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Texture.GetBuffer(System.Int32,System.Int32)">
            <summary>
            Return hardware pixel buffer for a surface. This buffer can then
            be used to copy data from and to a particular level of the texture.
            </summary>
            <param name="face">
            Face number, in case of a cubemap texture. Must be 0
            for other types of textures. For cubemaps, this is one of 
            +X (0), -X (1), +Y (2), -Y (3), +Z (4), -Z (5).
            </param>
            <param name="mipmap">
            Mipmap level. This goes from 0 for the first, largest
            mipmap level to GetNumMipmaps()-1 for the smallest.
            </param>
            <returns>A hardware pixel buffer.</returns>
            <remarks>
            The buffer is invalidated when the resource is unloaded or destroyed.
            Do not use it after the lifetime of the containing texture.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Texture.GetBuffer(System.Int32)">
            <summary>
            Return hardware pixel buffer for a surface. This buffer can then
            be used to copy data from and to a particular level of the texture.
            </summary>
            <param name="face">
            Face number, in case of a cubemap texture. Must be 0
            for other types of textures. For cubemaps, this is one of 
            +X (0), -X (1), +Y (2), -Y (3), +Z (4), -Z (5).
            </param>
            <returns>A hardware pixel buffer.</returns>
            <remarks>
            The buffer is invalidated when the resource is unloaded or destroyed.
            Do not use it after the lifetime of the containing texture.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Texture.GetBuffer">
            <summary>
            Return hardware pixel buffer for a surface. This buffer can then
            be used to copy data from and to a particular level of the texture.
            </summary>
            <returns>A hardware pixel buffer.</returns>
            <remarks>
            The buffer is invalidated when the resource is unloaded or destroyed.
            Do not use it after the lifetime of the containing texture.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Texture.Touch">
            <summary>'Touches' the resource to indicate it has been used.</summary>
        </member>
        <member name="M:Engine.Renderer.Texture.ToString">
            <summary>Returns the name of the texture.</summary>
            <returns>The name of the texture.</returns>
        </member>
        <member name="M:Engine.Renderer.Texture.IsDisposed">
            <summary>Returns the disposed flag of the texture.</summary>
            <returns><b>true</b> if such texture is disposed; otherwise, <b>false</b>.</returns>
        </member>
        <member name="P:Engine.Renderer.Texture.Name">
            <summary>Gets the name of the texture.</summary>
        </member>
        <member name="P:Engine.Renderer.Texture.Size">
            <summary>Gets the size of the texture.</summary>
        </member>
        <member name="P:Engine.Renderer.Texture.SourceSize">
            <summary>
            Gets the size of the original input texture (may differ due to hardware requirements).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Texture.Format">
            <summary>Gets the pixel format for the texture surface.</summary>
        </member>
        <member name="P:Engine.Renderer.Texture.SourceFormat">
            <summary>
            Gets the pixel format of the original input texture (may differ due to
            hardware requirements and pixel format convertion).
            </summary>
        </member>
        <member name="P:Engine.Renderer.Texture.MipmapCount">
            <summary>Gets the number of mipmaps to be used for this texture.</summary>
        </member>
        <member name="T:Engine.Renderer.Texture.Usage">
            <summary>Enum describing buffer usage; not mutually exclusive.</summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.Static">
            <summary>
            Static buffer which the application rarely modifies once created. Modifying 
            the contents of this buffer will involve a performance hit.
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.Dynamic">
            <summary>
            Indicates the application would like to modify this buffer with the CPU
            fairly often. 
            Buffers created with this flag will typically end up in AGP memory rather 
            than video memory.
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.WriteOnly">
            <summary>
            Indicates the application will never read the contents of the buffer back, 
            it will only ever write data. Locking a buffer with this flag will ALWAYS 
            return a pointer to new, blank memory rather than the memory associated 
            with the contents of the buffer; this avoids DMA stalls because you can 
            write to a new memory area while the previous one is being used. 
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.StaticWriteOnly">
            <summary>
            Combination of <b>Static</b> and <b>WriteOnly</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.DynamicWriteOnly">
            <summary>
            Combination of <b>Dynamic</b> and <b>WriteOnly</b>. If you use 
            this, strongly consider using <b>DynamicWriteOnlyDiscardable</b>
            instead if you update the entire contents of the buffer very 
            regularly. 
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.DynamicWriteOnlyDiscardable">
            <summary>
            Combination of <b>Dynamic</b>, <b>WriteOnly</b> and <b>Discardable</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.AutoMipmap">
            <summary>
            Mipmaps will be automatically generated for this texture.
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.RenderTarget">
            <summary>
            This texture will be a render target, ie. used as a target for render to texture
            setting this flag will ignore all other texture usages except <b>AutoMipmap</b>.
            </summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Usage.Default">
            <summary>
            Default to automatic mipmap generation static textures.
            </summary>
        </member>
        <member name="T:Engine.Renderer.Texture.Type">
            <summary>Enum identifying the texture type.</summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Type.Type1D">
            <summary>1D texture, used in combination with 1D texture coordinates.</summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Type.Type2D">
            <summary>2D texture, used in combination with 2D texture coordinates (default).</summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Type.Type3D">
            <summary>3D volume texture, used in combination with 3D texture coordinates.</summary>
        </member>
        <member name="F:Engine.Renderer.Texture.Type.CubeMap">
            <summary>3D cube map, used in combination with 3D texture coordinates.</summary>
        </member>
        <member name="T:Engine.Renderer.SceneNode">
            <summary>
            Class representing a node in the scene graph.
            </summary>
            <remarks>
            A SceneNode is used to organise objects in a scene.
            Child nodes are contained within the bounds of the parent, and so on down the
            tree, allowing for fast culling.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.SceneNode.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.SceneNode.Attach(Engine.Renderer.MovableObject)">
            <summary>
            Adds an instance of a scene object to this node.
            </summary>
            <remarks>
            Scene objects can include <see cref="T:Engine.Renderer.MeshObject"/> objects, 
            <see cref="T:Engine.Renderer.Camera"/> objects, <see cref="T:Engine.Renderer.RenderLight"/> objects, 
            <see cref="T:Engine.Renderer.ParticleSystem"/> objects etc.
            Anything that subclasses from <see cref="T:Engine.Renderer.MovableObject"/>.
            </remarks>
            <param name="obj">The movable object.</param>
        </member>
        <member name="M:Engine.Renderer.SceneNode.Detach(Engine.Renderer.MovableObject)">
            <summary>
            Detaches the indexed object from this scene node.
            </summary>
            <param name="obj">The movable object.</param>
        </member>
        <member name="M:Engine.Renderer.SceneNode.GetWorldBounds(Engine.MathEx.Bounds@)">
            <summary>
            Gets the bounds of a node.
            </summary>
            <param name="result">The bounds of a node.</param>
        </member>
        <member name="M:Engine.Renderer.SceneNode.GetWorldBounds">
            <summary>
            Gets the bounds of a node.
            </summary>
            <returns>The bounds of a node.</returns>
        </member>
        <member name="P:Engine.Renderer.SceneNode.Position">
            <summary>
            Gets or sets the position of a node.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneNode.Rotation">
            <summary>
            Gets or sets the rotation of a node.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneNode.Scale">
            <summary>
            Gets or sets the scaling of a node.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneNode.Visible">
            <summary>
            Gets or sets value which sets a visibility of a node.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneNode.MovableObjects">
            <summary>
            Gets the movable objects collection. <b>Don't modify</b>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.SceneNode.UserData">
            <summary>
            Gets or sets user data.
            </summary>
        </member>
        <member name="T:Engine.Renderer.RenderSystem">
            <summary>
            Defines the functionality of a 3D API.
            </summary>
            <remarks>
            The RenderSystem class provides a base interface
            which abstracts the general functionality of the 3D API
            e.g. Direct3D or OpenGL. Whilst a few of the general
            methods have implementations, most of this class is
            abstract, requiring a subclass based on a specific API
            to be constructed to provide the full functionality.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.ConvertColorValue(Engine.MathEx.ColorValue@)">
            <summary>
            Generates a packed data version of the passed in <see cref="T:Engine.MathEx.ColorValue"/> suitable for
            use as with this RenderSystem.
            </summary>
            <param name="color">The colour to convert.</param>
            <returns>The uint value.</returns>
            <remarks>
            Since different render systems have different colour data formats (eg
            RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.ConvertColorValue(Engine.MathEx.ColorValue)">
            <summary>
            Generates a packed data version of the passed in <see cref="T:Engine.MathEx.ColorValue"/> suitable for
            use as with this RenderSystem.
            </summary>
            <param name="color">The colour to convert.</param>
            <returns>The uint value.</returns>
            <remarks>
            Since different render systems have different colour data formats (eg
            RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.GetActiveViewport">
            <summary>
            Get the current active viewport for rendering.
            </summary>
            <returns>The current active viewport for rendering.</returns>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.ClearFrameBuffer(Engine.Renderer.FrameBufferType,Engine.MathEx.ColorValue,System.Single,System.UInt16)">
            <summary>
            Clears one or more frame buffers on the active render target.
            </summary>
            <param name="buffers">
            Combination of one or more elements of FrameBufferType
            denoting which buffers are to be cleared.
            </param>
            <param name="color">The color to clear the colour buffer with, if enabled.</param>
            <param name="depth">The value to initialise the depth buffer with, if enabled.</param>
            <param name="stencil">The value to initialise the stencil buffer with, if enabled.</param>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.ClearFrameBuffer(Engine.Renderer.FrameBufferType,Engine.MathEx.ColorValue,System.Single)">
            <summary>
            Clears one or more frame buffers on the active render target.
            </summary>
            <param name="buffers">
            Combination of one or more elements of FrameBufferType
            denoting which buffers are to be cleared.
            </param>
            <param name="color">The color to clear the colour buffer with, if enabled.</param>
            <param name="depth">The value to initialise the depth buffer with, if enabled.</param>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.ClearFrameBuffer(Engine.Renderer.FrameBufferType,Engine.MathEx.ColorValue)">
            <summary>
            Clears one or more frame buffers on the active render target.
            </summary>
            <param name="buffers">
            Combination of one or more elements of FrameBufferType
            denoting which buffers are to be cleared.
            </param>
            <param name="color">The color to clear the colour buffer with, if enabled.</param>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.ClearFrameBuffer(Engine.Renderer.FrameBufferType)">
            <summary>
            Clears one or more frame buffers on the active render target.
            </summary>
            <param name="buffers">
            Combination of one or more elements of FrameBufferType
            denoting which buffers are to be cleared.
            </param>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.IsDeviceLost">
            <summary>
            D3D specific method to return whether the device has been lost.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.IsDeviceLostByTestCooperativeLevel">
            <summary>
            D3D specific method to return whether the device has been lost.
            </summary>
        </member>
        <member name="M:Engine.Renderer.RenderSystem.CreateHardwareOcclusionQuery">
            <summary>
            Create an object for performing hardware occlusion queries.
            </summary>
            <returns>An object for performing hardware occlusion queries.</returns>
        </member>
        <member name="P:Engine.Renderer.RenderSystem.Instance">
            <summary>
            Gets an instance of the <see cref="T:Engine.Renderer.RenderSystem"/>.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystem.Name">
            <summary>
            Gets the name of the rendering system.
            </summary>
        </member>
        <member name="P:Engine.Renderer.RenderSystem.Capabilities">
            <summary>
            Gets the capabilities of the render system.
            </summary>
        </member>
        <member name="E:Engine.Renderer.RenderSystem.RenderSystemEvent">
            <summary>
            Occurs when the render system event is generated.
            </summary>
            <remarks>
            <para>
            Some render systems have quite specific, internally generated events 
            that the application may wish to be notified of. Many applications
            don't have to worry about these events, and can just trust engine to 
            handle them, but if you want to know, you can add a listener here.
            </para>
            <para>
            Perhaps the most common example of a render system specific event is the 
            loss and restoration of a device in DirectX; which engine deals with, 
            but you may wish to know when it happens. 
            </para>
            </remarks>
        </member>
        <member name="T:Engine.Renderer.RenderSystem.RenderSystemEventDelegate">
            <summary>
            Represents the method that handles a <see cref="E:Engine.Renderer.RenderSystem.RenderSystemEvent"/> event.
            </summary>
            <param name="name">The event name.</param>
        </member>
        <member name="T:Engine.Renderer.Compositor">
            <summary>
            Class representing a Compositor object. Compositors provide the means 
            to flexibly "composite" the final rendering result from multiple scene renders
            and intermediate operations like rendering fullscreen quads. This makes 
            it possible to apply postfilter effects, HDRI postprocessing, and shadow 
            effects to a <see cref="T:Engine.Renderer.Viewport"/>.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Compositor.Dispose">
            <summary>Releases the resources that are used by the object.</summary>
        </member>
        <member name="M:Engine.Renderer.Compositor.CreateTechnique">
            <summary>Create a new technique.</summary>
            <returns>The technique.</returns>
        </member>
        <member name="M:Engine.Renderer.Compositor.IsSupported">
            <summary>
            Determine if this compositor is supported on the current rendering device.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Compositor.Name">
            <summary>Gets the compositor name.</summary>
        </member>
        <member name="P:Engine.Renderer.Compositor.Techniques">
            <summary>Gets the techniques collection. <b>Don't modify</b>.</summary>
        </member>
        <member name="T:Engine.Renderer.Animation">
            <summary>
            An animation sequence.
            </summary>
            <remarks>
            This class defines the interface for a sequence of animation, whether that
            be animation of a mesh, a path along a spline, or possibly more than one
            type of animation in one. An animation is made up of many 'tracks', which are
            the more specific types of animation.
            </remarks>
        </member>
        <member name="M:Engine.Renderer.Animation.CreateVertexTrack(System.Int32,Engine.Renderer.VertexAnimationType)">
            <summary>
            Creates a VertexAnimationTrack for animating vertex position data.
            </summary>
            <param name="handle">
            Handle to give the track, used for accessing the track later. 
            Must be unique within this Animation, and is used to identify the target. For example
            when applied to a <see cref="T:Engine.Renderer.Mesh"/>, the handle must reference the index 
            of the geometry being modified; 0 for the shared geometry, 
            and 1+ for <see cref="T:Engine.Renderer.SubMesh"/> geometry with the same index-1.
            </param>
            <param name="animationType">Either morph or pose animation.</param>
        </member>
        <member name="M:Engine.Renderer.Animation.CreateVertexTrack(System.Int32,Engine.Renderer.VertexData,Engine.Renderer.VertexAnimationType)">
            <summary>
            Creates a VertexAnimationTrack for animating vertex position data.
            </summary>
            <param name="handle">
            Handle to give the track, used for accessing the track later. 
            Must be unique within this Animation, and is used to identify the target. For example
            when applied to a <see cref="T:Engine.Renderer.Mesh"/>, the handle must reference the index 
            of the geometry being modified; 0 for the shared geometry, 
            and 1+ for <see cref="T:Engine.Renderer.SubMesh"/> geometry with the same index-1.
            </param>
            <param name="targetData"></param>
            <param name="animationType">Either morph or pose animation.</param>
        </member>
        <member name="M:Engine.Renderer.Animation.DestroyVertexTrack(System.Int32)">
            <summary>
            Destroys the Vertex track with the given handle.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Animation.CreateNodeTrack(System.Int32)">
            <summary>
            Creates a <see cref="T:Engine.Renderer.NodeAnimationTrack"/> for animating a Node.
            </summary>
            <param name="handle">
            Handle to give the track, used for accessing the track later. 
            Must be unique within this <see cref="T:Engine.Renderer.Animation"/>.
            </param>
            <returns></returns>
        </member>
        <member name="M:Engine.Renderer.Animation.DestroyNodeTrack(System.Int32)">
            <summary>
            Destroys the Node track with the given handle.
            </summary>
        </member>
        <member name="M:Engine.Renderer.Animation.CreateNodeTrack(System.Int32,Engine.Renderer.Bone)">
            <summary>
            Creates a new <see cref="T:Engine.Renderer.AnimationTrack"/> automatically associated with 
            a <see cref="T:Engine.Renderer.Bone"/>.
            </summary>
            <param name="handle">
            Numeric handle to give the track, used for accessing the track later. 
            Must be unique within this <see cref="T:Engine.Renderer.Animation"/>.
            </param>
            <param name="bone">
            A reference to the <see cref="T:Engine.Renderer.Bone"/> object which will be affected 
            by this track.
            </param>
            <returns></returns>
            <remarks>
            This method creates a standard <see cref="T:Engine.Renderer.AnimationTrack"/>, but also 
            associates it with a target <see cref="T:Engine.Renderer.Bone"/> which will receive all 
            keyframe effects.
            </remarks>
        </member>
        <member name="P:Engine.Renderer.Animation.Name">
            <summary>
            Gets the name of this animation.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Animation.Length">
            <summary>
            Gets the total length of the animation.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Animation.VertexTracks">
            <summary>
            Gets the vertex track list.
            </summary>
        </member>
        <member name="P:Engine.Renderer.Animation.NodeTracks">
            <summary>
            Gets the node track list.
            </summary>
        </member>
    </members>
</doc>
